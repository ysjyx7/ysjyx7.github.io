<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.3/css/all.min.css" integrity="sha256-2H3fkXt6FEmrReK448mDVGKb3WW2ZZw35gI7vqHOE4Y=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"ysjyx7.github.io","root":"/","images":"/images","scheme":"Gemini","version":"8.7.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>


<script type="text/javascript" src="/js/cursor/zjAdd.js"></script>

<div class="musicwyy2" style="position:fixed;left:0px;bottom:0px;z-index:105;opacity: 1; 
    width: 30px;
    height: 110px;    font-size: 15px;
    font-family: 'Long Cang';">

  <button type="button" style="
    width: 30px;
    height: 66px;
    margin-top: 10px;
    margin-bottom: 10px;
    border-width: 0px;
    background: #f5f5f5;
    z-index:200;" onclick="musicChange()"> 播放器</button>

</div> 



<div class="musicwyy1" style="position:fixed;left:0px;bottom:0px;z-index:100;opacity: 1; 
    width: 300px;
    height: 110px;font-size: 0;">

  <div class="aplayer-miniswitcher" style="
    height: 110px;
    width: 20px;
    display: inline-block; overflow: hidden;">



  </div>

  <div style="
    width: calc(100% - 30px);
    height: 110px;
    display: inline-block;" id="musicZJ">

<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=1923542870&auto=1&height=66"></iframe>

  </div>
  
</div>
<meta name="description" content="总结了从运算器、存储器、CPU的重点知识，总结如何从逻辑门逐步构建一个CPU，并且总结了四个实验的简单思路">
<meta property="og:type" content="article">
<meta property="og:title" content="组原总结">
<meta property="og:url" content="https://ysjyx7.github.io/2022/06/19/%E7%BB%84%E5%8E%9F%E6%80%BB%E7%BB%93/index.html">
<meta property="og:site_name" content="ysjhust">
<meta property="og:description" content="总结了从运算器、存储器、CPU的重点知识，总结如何从逻辑门逐步构建一个CPU，并且总结了四个实验的简单思路">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220619132545903.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220619135509423.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220619152126714.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220619152251865.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220619152518068.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220619163901577.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220619160640702.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220619161819917.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220619205142385.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220619205216929.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220620094142248.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220620094547449.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220620094806016.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220620102126045.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220620112805886.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220620123602187.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220620125723038.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220620130114615.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220620152758047.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220620153821835.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220620155614721.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220620160121900.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220620160912766.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220620162001291.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220620163129504.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220620163453411.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220620193810901.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220620200108375.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220620201724805.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220620204512504.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220620212605651.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220621091127467.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220621092617212.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220621094109281.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220621094938952.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220621095616070.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220621100320599.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220621101613536.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220621102949894.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220621104445770.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220621104944481.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220621105158299.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220621110217033.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220621133257788.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220621133952686.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220621134745228.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220621142229462.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220621163732007.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220621163943305.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220621164616948.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220621165450575.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220621170234651.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220621182858605.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220621192211680.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220621192522645.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220621192735037.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220621193723726.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220621195604969.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220621195833928.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220621202030268.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220622082857870.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220622084149693.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220622090207744.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220622091218589.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220622092903542.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220622095438874.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220622100238184.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220622100617543.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220622101720839.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220622102524451.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220622102835939.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220622103904010.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220622104220609.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220622104338529.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220622111005329.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220622111820692.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220622112353018.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220622113400732.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220622114719302.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220622133535076.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220622135205427.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220622135944841.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220622141515487.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220622140643324.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220622141052241.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220622142148627.png">
<meta property="article:published_time" content="2022-06-19T03:59:37.000Z">
<meta property="article:modified_time" content="2022-06-22T06:22:56.215Z">
<meta property="article:author" content="ysjhust">
<meta property="article:tag" content="专业课学习">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220619132545903.png">


<link rel="canonical" href="https://ysjyx7.github.io/2022/06/19/%E7%BB%84%E5%8E%9F%E6%80%BB%E7%BB%93/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://ysjyx7.github.io/2022/06/19/%E7%BB%84%E5%8E%9F%E6%80%BB%E7%BB%93/","path":"2022/06/19/组原总结/","title":"组原总结"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>组原总结 | ysjhust</title>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">ysjhust</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">https://ysjyx7.github.io</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0"><span class="nav-number">1.</span> <span class="nav-text">计算机系统概述</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A1%AC%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%BB%84%E6%88%90"><span class="nav-number">1.1.</span> <span class="nav-text">计算机硬件系统的组成</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87"><span class="nav-number">1.2.</span> <span class="nav-text">计算机性能指标</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87"><span class="nav-number">1.2.1.</span> <span class="nav-text">基本性能指标</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%92%8C%E6%97%B6%E9%97%B4%E6%9C%89%E5%85%B3%E7%9A%84%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87"><span class="nav-number">1.2.2.</span> <span class="nav-text">和时间有关的性能指标</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA"><span class="nav-number">2.</span> <span class="nav-text">数据信息的表示</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E5%80%BC%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA"><span class="nav-number">2.1.</span> <span class="nav-text">数值数据的表示</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E7%9A%84%E6%9C%BA%E5%99%A8%E7%A0%81%E8%A1%A8%E7%A4%BA"><span class="nav-number">2.1.1.</span> <span class="nav-text">数的机器码表示</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9A%E7%82%B9%E6%95%B0%E8%A1%A8%E7%A4%BA"><span class="nav-number">2.1.2.</span> <span class="nav-text">定点数表示</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B5%AE%E7%82%B9%E6%95%B0%E8%A1%A8%E7%A4%BA"><span class="nav-number">2.1.3.</span> <span class="nav-text">浮点数表示</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9D%9E%E6%95%B0%E5%80%BC%E6%95%B0%E6%8D%AE%E8%A1%A8%E7%A4%BA%E6%B3%95"><span class="nav-number">2.2.</span> <span class="nav-text">非数值数据表示法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E4%BF%A1%E6%81%AF%E7%9A%84%E6%A0%A1%E9%AA%8C"><span class="nav-number">2.3.</span> <span class="nav-text">数据信息的校验</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A0%81%E8%B7%9D%E4%B8%8E%E6%A0%A1%E9%AA%8C"><span class="nav-number">2.3.1.</span> <span class="nav-text">码距与校验</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A5%87%E5%81%B6%E6%A0%A1%E9%AA%8C"><span class="nav-number">2.3.2.</span> <span class="nav-text">奇偶校验</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BE%AA%E7%8E%AF%E5%86%97%E4%BD%99%E6%A0%A1%E9%AA%8C"><span class="nav-number">2.3.3.</span> <span class="nav-text">循环冗余校验</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E8%A1%A8%E7%A4%BA%E5%AE%9E%E9%AA%8C"><span class="nav-number">3.</span> <span class="nav-text">数据表示实验</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%BD%E6%A0%87%E8%BD%AC%E5%8C%BA%E4%BD%8D%E7%A0%81"><span class="nav-number">3.1.</span> <span class="nav-text">国标转区位码</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%81%B6%E6%A0%A1%E9%AA%8C%E7%BC%96%E7%A0%81"><span class="nav-number">3.2.</span> <span class="nav-text">偶校验编码</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%81%B6%E6%A0%A1%E9%AA%8C%E6%A3%80%E9%94%99"><span class="nav-number">3.3.</span> <span class="nav-text">偶校验检错</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CRC%E7%BC%96%E7%A0%81"><span class="nav-number">3.4.</span> <span class="nav-text">CRC编码</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CRC%E6%A3%80%E9%94%99%E4%B8%8E%E7%BA%A0%E9%94%99"><span class="nav-number">3.5.</span> <span class="nav-text">CRC检错与纠错</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CRC%E7%BC%96%E7%A0%81%E6%B5%81%E6%B0%B4%E7%BA%BF%E4%BC%A0%E8%BE%93"><span class="nav-number">3.6.</span> <span class="nav-text">CRC编码流水线传输</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95%E4%B8%8E%E8%BF%90%E7%AE%97%E5%99%A8"><span class="nav-number">4.</span> <span class="nav-text">运算方法与运算器</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9A%E7%82%B9%E5%8A%A0%E5%87%8F%E6%B3%95%E8%BF%90%E7%AE%97"><span class="nav-number">4.1.</span> <span class="nav-text">定点加减法运算</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9A%E7%82%B9%E4%B9%98%E6%B3%95%E8%BF%90%E7%AE%97"><span class="nav-number">4.2.</span> <span class="nav-text">定点乘法运算</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8E%9F%E7%A0%81%E4%B8%80%E4%BD%8D%E4%B9%98%E6%B3%95"><span class="nav-number">4.2.1.</span> <span class="nav-text">原码一位乘法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A1%A5%E7%A0%81%E4%B8%80%E4%BD%8D%E4%B9%98%E6%B3%95"><span class="nav-number">4.2.2.</span> <span class="nav-text">补码一位乘法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B5%AE%E7%82%B9%E8%BF%90%E7%AE%97"><span class="nav-number">4.3.</span> <span class="nav-text">浮点运算</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B5%AE%E7%82%B9%E5%8A%A0%E5%87%8F%E6%B3%95%E8%BF%90%E7%AE%97"><span class="nav-number">4.3.1.</span> <span class="nav-text">浮点加减法运算</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B5%AE%E7%82%B9%E4%B9%98%E6%B3%95%E8%BF%90%E7%AE%97"><span class="nav-number">4.3.2.</span> <span class="nav-text">浮点乘法运算</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B5%AE%E7%82%B9%E9%99%A4%E6%B3%95%E8%BF%90%E7%AE%97"><span class="nav-number">4.3.3.</span> <span class="nav-text">浮点除法运算</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%90%E7%AE%97%E5%99%A8"><span class="nav-number">4.4.</span> <span class="nav-text">运算器</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%BF%90%E7%AE%97%E5%99%A8%E5%AE%9E%E9%AA%8C"><span class="nav-number">5.</span> <span class="nav-text">运算器实验</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#8%E4%BD%8D%E5%8F%AF%E6%8E%A7%E5%8A%A0%E5%87%8F%E6%B3%95%E5%99%A8"><span class="nav-number">5.1.</span> <span class="nav-text">8位可控加减法器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4%E4%BD%8D%E5%85%88%E8%A1%8C%E8%BF%9B%E4%BD%8D%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1"><span class="nav-number">5.2.</span> <span class="nav-text">4位先行进位电路设计</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4%E4%BD%8D%E5%BF%AB%E9%80%9F%E5%8A%A0%E6%B3%95%E5%99%A8%E8%AE%BE%E8%AE%A1"><span class="nav-number">5.3.</span> <span class="nav-text">4位快速加法器设计</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#16%E4%BD%8D%E5%BF%AB%E9%80%9F%E5%8A%A0%E6%B3%95%E5%99%A8%E8%AE%BE%E8%AE%A1"><span class="nav-number">5.4.</span> <span class="nav-text">16位快速加法器设计</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#32%E4%BD%8D%E5%BF%AB%E9%80%9F%E5%8A%A0%E6%B3%95%E5%99%A8%E8%AE%BE%E8%AE%A1"><span class="nav-number">5.5.</span> <span class="nav-text">32位快速加法器设计</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%89%E7%AC%A6%E5%8F%B7%E4%B8%8E%E6%97%A0%E7%AC%A6%E5%8F%B7%E9%98%B5%E5%88%97%E4%B9%98%E6%B3%95%E5%99%A8"><span class="nav-number">5.6.</span> <span class="nav-text">有符号与无符号阵列乘法器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B9%98%E6%B3%95%E6%B5%81%E6%B0%B4%E7%BA%BF%E8%AE%BE%E8%AE%A1"><span class="nav-number">5.7.</span> <span class="nav-text">乘法流水线设计</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8E%9F%E7%A0%81%E4%B8%80%E4%BD%8D%E4%B9%98%E6%B3%95%E5%99%A8%E8%AE%BE%E8%AE%A1"><span class="nav-number">5.8.</span> <span class="nav-text">原码一位乘法器设计</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A1%A5%E7%A0%81%E4%B8%80%E4%BD%8D%E4%B9%98%E6%B3%95%E5%99%A8%E8%AE%BE%E8%AE%A1"><span class="nav-number">5.9.</span> <span class="nav-text">补码一位乘法器设计</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MIPS%E8%BF%90%E7%AE%97%E5%99%A8%E8%AE%BE%E8%AE%A1"><span class="nav-number">5.10.</span> <span class="nav-text">MIPS运算器设计</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F"><span class="nav-number">6.</span> <span class="nav-text">存储系统</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E5%99%A8%E6%A6%82%E8%BF%B0"><span class="nav-number">6.1.</span> <span class="nav-text">存储器概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E5%99%A8%E5%88%86%E7%B1%BB"><span class="nav-number">6.1.1.</span> <span class="nav-text">存储器分类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E5%99%A8%E6%8A%80%E6%9C%AF%E6%8C%87%E6%A0%87"><span class="nav-number">6.1.2.</span> <span class="nav-text">存储器技术指标</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84"><span class="nav-number">6.2.</span> <span class="nav-text">存储系统层次结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BB%E5%AD%98%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84"><span class="nav-number">6.3.</span> <span class="nav-text">主存基本结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BB%E5%AD%98%E7%9A%84%E7%BB%84%E7%BB%87%E4%B8%8ECPU%E7%9A%84%E8%BF%9E%E6%8E%A5"><span class="nav-number">6.4.</span> <span class="nav-text">主存的组织与CPU的连接</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B9%B6%E8%A1%8C%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F"><span class="nav-number">6.5.</span> <span class="nav-text">并行存储系统</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%AB%98%E9%80%9F%E7%BC%93%E5%86%B2%E5%AD%98%E5%82%A8%E5%99%A8"><span class="nav-number">6.6.</span> <span class="nav-text">高速缓冲存储器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#cache%E5%8E%9F%E7%90%86%E4%B8%8E%E7%A8%8B%E5%BA%8F%E5%B1%80%E9%83%A8%E6%80%A7"><span class="nav-number">6.6.1.</span> <span class="nav-text">cache原理与程序局部性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#cache%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-number">6.6.2.</span> <span class="nav-text">cache基本概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#cache%E8%AF%BB%E5%86%99%E6%B5%81%E7%A8%8B%E4%B8%8E%E5%85%B3%E9%94%AE%E6%8A%80%E6%9C%AF"><span class="nav-number">6.6.3.</span> <span class="nav-text">cache读写流程与关键技术</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%B8%E8%81%94%E5%AD%98%E5%82%A8%E5%99%A8"><span class="nav-number">6.6.4.</span> <span class="nav-text">相联存储器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9C%B0%E5%9D%80%E6%98%A0%E5%B0%84"><span class="nav-number">6.6.5.</span> <span class="nav-text">地址映射</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9B%BF%E6%8D%A2%E7%AD%96%E7%95%A5"><span class="nav-number">6.6.6.</span> <span class="nav-text">替换策略</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%99%E5%85%A5%E7%AD%96%E7%95%A5"><span class="nav-number">6.6.7.</span> <span class="nav-text">写入策略</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#cache%E5%BA%94%E7%94%A8"><span class="nav-number">6.6.8.</span> <span class="nav-text">cache应用</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E5%AE%9E%E9%AA%8C"><span class="nav-number">7.</span> <span class="nav-text">存储系统设计实验</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B1%89%E5%AD%97%E5%AD%97%E5%BA%93%E5%AD%98%E5%82%A8%E8%8A%AF%E7%89%87%E6%89%A9%E5%B1%95%E5%AE%9E%E9%AA%8C"><span class="nav-number">7.1.</span> <span class="nav-text">汉字字库存储芯片扩展实验</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MIPS%E5%AF%84%E5%AD%98%E5%99%A8%E6%96%87%E4%BB%B6%E8%AE%BE%E8%AE%A1"><span class="nav-number">7.2.</span> <span class="nav-text">MIPS寄存器文件设计</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MIPSRAM%E8%AE%BE%E8%AE%A1"><span class="nav-number">7.3.</span> <span class="nav-text">MIPSRAM设计</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2%E8%B7%AF%E7%BB%84%E7%9B%B8%E8%81%94cache%E8%AE%BE%E8%AE%A1"><span class="nav-number">7.4.</span> <span class="nav-text">2路组相联cache设计</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F"><span class="nav-number">8.</span> <span class="nav-text">指令系统</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0"><span class="nav-number">8.1.</span> <span class="nav-text">指令系统概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8C%87%E4%BB%A4%E6%A0%BC%E5%BC%8F"><span class="nav-number">8.2.</span> <span class="nav-text">指令格式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%87%E4%BB%A4%E5%AD%97%E9%95%BF%E5%BA%A6"><span class="nav-number">8.2.1.</span> <span class="nav-text">指令字长度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%87%E4%BB%A4%E5%9C%B0%E5%9D%80%E7%A0%81"><span class="nav-number">8.2.2.</span> <span class="nav-text">指令地址码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%87%E4%BB%A4%E6%93%8D%E4%BD%9C%E7%A0%81"><span class="nav-number">8.2.3.</span> <span class="nav-text">指令操作码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F"><span class="nav-number">8.3.</span> <span class="nav-text">寻址方式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8C%87%E4%BB%A4%E6%A0%BC%E5%BC%8F%E8%AE%BE%E8%AE%A1"><span class="nav-number">8.4.</span> <span class="nav-text">指令格式设计</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CISC%E5%92%8CRISC"><span class="nav-number">8.5.</span> <span class="nav-text">CISC和RISC</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8"><span class="nav-number">9.</span> <span class="nav-text">中央处理器</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#CPU%E6%A6%82%E8%BF%B0"><span class="nav-number">9.1.</span> <span class="nav-text">CPU概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8C%87%E4%BB%A4%E5%91%A8%E6%9C%9F"><span class="nav-number">9.2.</span> <span class="nav-text">指令周期</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E9%80%9A%E8%B7%AF%E5%8F%8A%E6%8C%87%E4%BB%A4%E6%93%8D%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="nav-number">9.3.</span> <span class="nav-text">数据通路及指令操作流程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E9%80%9A%E8%B7%AF%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%AE%9A%E6%97%B6"><span class="nav-number">9.3.1.</span> <span class="nav-text">数据通路模型与定时</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%95%E6%80%BB%E7%BA%BF%E7%BB%93%E6%9E%84%E7%9A%84%E6%95%B0%E6%8D%AE%E9%80%9A%E8%B7%AF"><span class="nav-number">9.3.2.</span> <span class="nav-text">单总线结构的数据通路</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%97%B6%E5%BA%8F%E4%B8%8E%E6%8E%A7%E5%88%B6"><span class="nav-number">9.4.</span> <span class="nav-text">时序与控制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A1%AC%E5%B8%83%E7%BA%BF%E6%8E%A7%E5%88%B6%E5%99%A8"><span class="nav-number">9.5.</span> <span class="nav-text">硬布线控制器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BE%AE%E7%A8%8B%E5%BA%8F%E6%8E%A7%E5%88%B6%E5%99%A8"><span class="nav-number">9.6.</span> <span class="nav-text">微程序控制器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8%E4%B8%8E%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86"><span class="nav-number">9.7.</span> <span class="nav-text">异常与中断处理</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#CPU%E5%AE%9E%E9%AA%8C"><span class="nav-number">10.</span> <span class="nav-text">CPU实验</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%98%E9%95%BF%E6%8C%87%E4%BB%A4%E5%91%A8%E6%9C%9F3%E7%BA%A7%E6%97%B6%E5%BA%8F%E7%B3%BB%E7%BB%9F"><span class="nav-number">10.1.</span> <span class="nav-text">变长指令周期3级时序系统</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#MIPS%E6%8C%87%E4%BB%A4%E8%AF%91%E7%A0%81%E5%99%A8"><span class="nav-number">10.1.1.</span> <span class="nav-text">MIPS指令译码器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%B6%E5%BA%8F%E5%8F%91%E7%94%9F%E5%99%A8%E8%AE%BE%E8%AE%A1"><span class="nav-number">10.1.2.</span> <span class="nav-text">时序发生器设计</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A1%AC%E5%B8%83%E7%BA%BF%E7%BB%84%E5%90%88%E9%80%BB%E8%BE%91%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83"><span class="nav-number">10.1.3.</span> <span class="nav-text">硬布线组合逻辑控制单元</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A1%AC%E5%B8%83%E7%BA%BF%E6%8E%A7%E5%88%B6%E5%99%A8-1"><span class="nav-number">10.1.4.</span> <span class="nav-text">硬布线控制器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%98%E9%95%BF%E6%8C%87%E4%BB%A4%E5%91%A8%E6%9C%9F%E5%8D%95%E6%80%BB%E7%BA%BFCPU"><span class="nav-number">10.1.5.</span> <span class="nav-text">变长指令周期单总线CPU</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%95%E6%80%BB%E7%BA%BF%E7%8E%B0%E4%BB%A3%E6%97%B6%E5%BA%8FCPU"><span class="nav-number">10.2.</span> <span class="nav-text">单总线现代时序CPU</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#MIPS%E6%8C%87%E4%BB%A4%E8%AF%91%E7%A0%81%E5%99%A8-1"><span class="nav-number">10.2.1.</span> <span class="nav-text">MIPS指令译码器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BE%AE%E7%A8%8B%E5%BA%8F%E5%85%A5%E5%8F%A3%E6%9F%A5%E6%89%BE%E9%80%BB%E8%BE%91"><span class="nav-number">10.2.2.</span> <span class="nav-text">微程序入口查找逻辑</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BE%AE%E7%A8%8B%E5%BA%8F%E6%9D%A1%E4%BB%B6%E5%88%A4%E5%88%AB%E6%B5%8B%E8%AF%95%E9%80%BB%E8%BE%91"><span class="nav-number">10.2.3.</span> <span class="nav-text">微程序条件判别测试逻辑</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%95%E6%80%BB%E7%BA%BFCPU%E5%BE%AE%E7%A8%8B%E5%BA%8F%E6%8E%A7%E5%88%B6%E5%99%A8%E8%AE%BE%E8%AE%A1"><span class="nav-number">10.2.4.</span> <span class="nav-text">单总线CPU微程序控制器设计</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%87%87%E7%94%A8%E5%BE%AE%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%8D%95%E6%80%BB%E7%BA%BFCPU%E8%AE%BE%E8%AE%A1"><span class="nav-number">10.2.5.</span> <span class="nav-text">采用微程序的单总线CPU设计</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%8E%B0%E4%BB%A3%E6%97%B6%E5%BA%8F%E7%A1%AC%E5%B8%83%E7%BA%BF%E7%8A%B6%E6%80%81%E6%9C%BA%E8%AE%BE%E8%AE%A1"><span class="nav-number">10.2.6.</span> <span class="nav-text">现代时序硬布线状态机设计</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%8E%B0%E4%BB%A3%E6%97%B6%E5%BA%8F%E7%A1%AC%E5%B8%83%E7%BA%BF%E6%8E%A7%E5%88%B6%E5%99%A8%E8%AE%BE%E8%AE%A1"><span class="nav-number">10.2.7.</span> <span class="nav-text">现代时序硬布线控制器设计</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MIPS%E5%B8%A6%E4%B8%AD%E6%96%AD%E6%9C%BA%E5%88%B6%E5%AE%9E%E7%8E%B0"><span class="nav-number">10.3.</span> <span class="nav-text">MIPS带中断机制实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#MIPS%E6%8C%87%E4%BB%A4%E8%AF%91%E7%A0%81%E5%99%A8-2"><span class="nav-number">10.3.1.</span> <span class="nav-text">MIPS指令译码器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%94%AF%E6%8C%81%E4%B8%AD%E6%96%AD%E7%9A%84%E5%BE%AE%E7%A8%8B%E5%BA%8F%E5%85%A5%E5%8F%A3%E6%9F%A5%E6%89%BE%E9%80%BB%E8%BE%91"><span class="nav-number">10.3.2.</span> <span class="nav-text">支持中断的微程序入口查找逻辑</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%94%AF%E6%8C%81%E4%B8%AD%E6%96%AD%E7%9A%84%E5%BE%AE%E7%A8%8B%E5%BA%8F%E6%9D%A1%E4%BB%B6%E5%88%A4%E5%88%AB%E6%B5%8B%E8%AF%95%E9%80%BB%E8%BE%91"><span class="nav-number">10.3.3.</span> <span class="nav-text">支持中断的微程序条件判别测试逻辑</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%94%AF%E6%8C%81%E4%B8%AD%E6%96%AD%E7%9A%84%E5%BE%AE%E7%A8%8B%E5%BA%8F%E6%8E%A7%E5%88%B6%E5%99%A8%E8%AE%BE%E8%AE%A1"><span class="nav-number">10.3.4.</span> <span class="nav-text">支持中断的微程序控制器设计</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%94%AF%E6%8C%81%E4%B8%AD%E6%96%AD%E7%9A%84%E5%BE%AE%E7%A8%8B%E5%BA%8F%E5%8D%95%E6%80%BB%E7%BA%BFCPU%E8%AE%BE%E8%AE%A1"><span class="nav-number">10.3.5.</span> <span class="nav-text">支持中断的微程序单总线CPU设计</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%94%AF%E6%8C%81%E4%B8%AD%E6%96%AD%E7%9A%84%E7%8E%B0%E4%BB%A3%E6%97%B6%E5%BA%8F%E7%A1%AC%E5%B8%83%E7%BA%BF%E6%8E%A7%E5%88%B6%E5%99%A8%E7%8A%B6%E6%80%81%E6%9C%BA%E8%AE%BE%E8%AE%A1"><span class="nav-number">10.3.6.</span> <span class="nav-text">支持中断的现代时序硬布线控制器状态机设计</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%94%AF%E6%8C%81%E4%B8%AD%E6%96%AD%E7%9A%84%E7%8E%B0%E4%BB%A3%E6%97%B6%E5%BA%8F%E7%A1%AC%E5%B8%83%E7%BA%BF%E6%8E%A7%E5%88%B6%E5%99%A8%E8%AE%BE%E8%AE%A1"><span class="nav-number">10.3.7.</span> <span class="nav-text">支持中断的现代时序硬布线控制器设计</span></a></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-overview">
            <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="ysjhust"
      src="/images/%E5%A4%B4%E5%83%8F.jpg">
  <p class="site-author-name" itemprop="name">ysjhust</p>
  <div class="site-description" itemprop="description">Hello World!</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">68</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">35</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">30</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/ysjyx7" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;ysjyx7" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/2849458605@qq.com" title="E-Mail → 2849458605@qq.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.zhihu.com/people/yang-lao-er-25-83" title="知乎 → https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;yang-lao-er-25-83" rel="noopener" target="_blank"><i class="fab fa-zhihu fa-fw"></i>知乎</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://blog.csdn.net/m0_55101026?spm=1001.2101.3001.5343" title="CSDN → https:&#x2F;&#x2F;blog.csdn.net&#x2F;m0_55101026?spm&#x3D;1001.2101.3001.5343" rel="noopener" target="_blank"><i class="fa fa-book fa-fw"></i>CSDN</a>
      </span>
  </div>
  <div class="cc-license site-overview-item animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdn.jsdelivr.net/npm/@creativecommons/vocabulary@2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>



          </div>
        </div>
      </div>

    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

  <a href="https://github.com/ysjyx7" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://ysjyx7.github.io/2022/06/19/%E7%BB%84%E5%8E%9F%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/%E5%A4%B4%E5%83%8F.jpg">
      <meta itemprop="name" content="ysjhust">
      <meta itemprop="description" content="Hello World!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ysjhust">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          组原总结
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-06-19 11:59:37" itemprop="dateCreated datePublished" datetime="2022-06-19T11:59:37+08:00">2022-06-19</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2022-06-22 14:22:56" itemprop="dateModified" datetime="2022-06-22T14:22:56+08:00">2022-06-22</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E4%B8%93%E4%B8%9A%E8%AF%BE%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">专业课学习</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>27k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>25 分钟</span>
    </span>
</div>

            <div class="post-description">总结了从运算器、存储器、CPU的重点知识，总结如何从逻辑门逐步构建一个CPU，并且总结了四个实验的简单思路</div>
        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h1 id="计算机系统概述"><a href="#计算机系统概述" class="headerlink" title="计算机系统概述"></a>计算机系统概述</h1><h2 id="计算机硬件系统的组成"><a href="#计算机硬件系统的组成" class="headerlink" title="计算机硬件系统的组成"></a>计算机硬件系统的组成</h2><p>​	根据冯·诺依曼的设计思想，计算机硬件系统共包括运算器、控制器、存储器、输入设备和输出设备，其中运算器和控制器合称为CPU，CPU和存储器合称为主机。后面将依次介绍着五大部件，并且依次实现这五大部件。</p>
<h2 id="计算机性能指标"><a href="#计算机性能指标" class="headerlink" title="计算机性能指标"></a>计算机性能指标</h2><h3 id="基本性能指标"><a href="#基本性能指标" class="headerlink" title="基本性能指标"></a>基本性能指标</h3><p>​	主要有如下两点：</p>
<ol>
<li><code>字长</code>，即CPU一次能处理的数据位数，一般来说，字长越长，计算精确度就越高，定点数的表示范围就越大</li>
<li><code>主存容量</code>，指主存能存储的最大信息量，一般用$M\times N$表示，其中$M$为存储单元数，也称字容量，$N$为每个存储单元存储的二进制位数，也称位容量</li>
</ol>
<h3 id="和时间有关的性能指标"><a href="#和时间有关的性能指标" class="headerlink" title="和时间有关的性能指标"></a>和时间有关的性能指标</h3><p>​	主要有如下几点：</p>
<ol>
<li><code>时钟周期</code>，最基本的、最小的时间单位，一个时钟周期里CPU仅能完成一个基本动作</li>
<li><code>CPI</code>，执行每条指令所需要的平均时钟周期数，我们设一个程序中的总指令条数为$IC$，程序执行所需的时钟周期数为$m$，时钟周期为$T$，频率为$f$，则$CPI&#x3D;\frac{m}{IC}$，当然我们也可以去计算一个加权的$CPI$，如果我们知道一个程序中各种指令所占的比例的话。</li>
<li><code>IPC</code>，指每个时钟周期CPU可以执行的指令条数，显然它是$CPI$的倒数</li>
<li><code>MIPS</code>，指每秒百万条指令，根据上面的定义可以得出$MIPS&#x3D;\frac{f}{CPI}&#x3D;IPC\times f$，其中频率$f$的单位为$MHz$</li>
<li><code>MFLOPS</code>，每秒执行浮点运算百万级次数</li>
</ol>
<h1 id="数据信息的表示"><a href="#数据信息的表示" class="headerlink" title="数据信息的表示"></a>数据信息的表示</h1><h2 id="数值数据的表示"><a href="#数值数据的表示" class="headerlink" title="数值数据的表示"></a>数值数据的表示</h2><h3 id="数的机器码表示"><a href="#数的机器码表示" class="headerlink" title="数的机器码表示"></a>数的机器码表示</h3><p>​	这里关于原码、反码、补码的知识不作过多赘述，仅简单提一些细微的知识。</p>
<p>​	在补码中，由于0的表示唯一，所以会有一个多余的编码状态，此状态在定点整数中表示为$-2^n$，另外要获取补码，除了之前学过的按位取反加一，这里也可以找到数的最右边一个1，它及右边所有的0不变，其余按位取反即可。此外，这里提出了<strong>变形补码</strong>的概念，即用两个二进制位表示符号，00表示正数，11表示负数，那么定点小数变成了模4的补码，定点整数变成了模$2^{n+2}$的补码，其实就是符号位位数发生了变化，剩下的完全一样。</p>
<p>​	然后介绍一下<strong>移码</strong>，移码只用于定点整数的表示，编码方式为直接将真值加上一个偏移量，即$[x]_{移}&#x3D;x+bias,-2^n\le x&lt;x^n$。其中偏移量一般取$2^n$，也就是说移码可以直接比较大小。对比一下补码和移码，可以发现两者除了符号位不同剩下的位是完全一样的。</p>
<h3 id="定点数表示"><a href="#定点数表示" class="headerlink" title="定点数表示"></a>定点数表示</h3><p>​	定点数表示法要求计算机中的所有数据的小数点位置固定，其中将小数点固定到数据最高数位之前或符号位之后称其为定点小数，而将小数点固定到最低数位之后的数据表示称为定点整数。由于本身小数点位置固定，所以可以不表示小数点的位置</p>
<h3 id="浮点数表示"><a href="#浮点数表示" class="headerlink" title="浮点数表示"></a>浮点数表示</h3><p>​	我们采用类似于十进制中的科学计数法的方式来表示浮点数，也即对于二进制数$N$，可以表示为$N&#x3D;2^E\times M$，其中阶码$E$是定点整数，决定了小数点的位置，也即数据的范围，而尾数$M$决定了数据表示的精度以及符号。此外，由于上面的那种表示方法会让一个二进制数有多种表示，所以我们提出了<strong>规格化处理</strong>，也即使得尾数真值的最高有效位为1。类似与定点数的表示，这个1是确定了的，我们可以不表示，只是在进行数据运算的时候再恢复它，我们称其为<strong>隐藏位</strong></p>
<p>​	下面介绍一下IEEE754标准，这个标准就是规定了阶码和尾数的具体位数，以提升程序的可移植性，具体表示如下</p>
<p><img src="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220619132545903.png" alt="image-20220619132545903"></p>
<p>​	注意32位中阶码$E$为移码，偏移量是127，尾数$M$为定点小数，有隐藏位，用原码表示。</p>
<p>​	通过上述的定义也很容易知道如何在IEEE754和真值之间转化，以及数值的表示范围等等。</p>
<h2 id="非数值数据表示法"><a href="#非数值数据表示法" class="headerlink" title="非数值数据表示法"></a>非数值数据表示法</h2><p>​	主要就是字符表示和汉字表示。字符表示就用ASCII码，汉字表示用GB2312，用14位表示汉字</p>
<h2 id="数据信息的校验"><a href="#数据信息的校验" class="headerlink" title="数据信息的校验"></a>数据信息的校验</h2><p>​	数据校验的主要流程是由发送方对原始数据按照预定编码规则进行编码，生成包含冗余信息的校验码，经过传输之后，接收方利用解码模块解析并判断校验码是否符合预定的编码规则。</p>
<h3 id="码距与校验"><a href="#码距与校验" class="headerlink" title="码距与校验"></a>码距与校验</h3><p>​	两个编码对应二进制位不同的个数称为码距，一个编码集中任意两个码字的最小码距称为该编码集的码距。校验码的目的就是扩大码距。一般来说，码距$d$与校验码的检错和纠错能力的关系如下所示：</p>
<ol>
<li>$d\ge e+1$，可检测$e$个错误</li>
<li>$d\ge 2t+1$，可检测$t$个错误</li>
<li>$d\ge e+t+1,e\ge t$，可检测$e$个错误并纠正$t$个错误</li>
</ol>
<h3 id="奇偶校验"><a href="#奇偶校验" class="headerlink" title="奇偶校验"></a>奇偶校验</h3><p>​	奇偶校验的原理很简单，核心就是检测整个二进制代码中1的个数，如果是奇数则是奇校验，否则为偶校验。奇偶校验的编码规则就是增加一位校验位$P$，使得最终校验码中1的个数为奇数或偶数，通过上面的定义，我们可以得到校验位的计算公式，如下图所示。</p>
<p><img src="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220619135509423.png" alt="image-20220619135509423"></p>
<p>​	当然这个校验码也是分奇偶的，这里给出的是偶校验检错位。如果检错位为1则说明发生了错误。</p>
<p>​	通过上面的分析，很容易可以发现奇偶校验原理简单，但是因为仅仅增加了一个校验位，所以只能进行一位检错，为此，我们可以多增加几个校验位来进行纠错，下面简单介绍一下交叉奇偶校验的原理。</p>
<p>​	交叉奇偶校验就是把原始数据构造成矩阵结构，然后对于每一行每一列都设置一个奇偶校验位，如果某一位出错的话，这一位对应的行和列都会报错，进而我们就确定了出错的位置。</p>
<h3 id="循环冗余校验"><a href="#循环冗余校验" class="headerlink" title="循环冗余校验"></a>循环冗余校验</h3><p>​	CRC基于模2运算建立编码规则，模2运算规则如下所示</p>
<ol>
<li>模2加减法就是没有借位和进位的加减法</li>
<li>模2乘法就是按照模2加法进行运算的乘法</li>
<li>模2除法按照模2减法求余数，上商规则也有一些变化，如下：<ul>
<li>余数首位为1时，商上1，按模2减运算</li>
<li>余数首位为0时，商上0，减0</li>
<li>余数位数少于除数位数时，运算停止</li>
</ul>
</li>
</ol>
<p>​	然后介绍CRC的编码规则。设其长度共$n$位，其中原始数据信息有$k$位，为$C_{k-1}C_{k-2}\dots C_1C_0$，校验位共$r$位，为$P_{r-1}\dots P_0$，称为$(n,k)$码，应满足$n\le 2^r-1$，编码过程如下</p>
<ol>
<li>假定待发送的信息可以用一个多项式$M(x)$表示，即$M(x)&#x3D;C_{k-1}x^{k-1}+\dots+C_1x+C_0$</li>
<li>将其左移$r$位，表示为$M(x)·2^r$</li>
<li>选择一个$r+1$为的生成多项式$G(x)$，最高次幂为$r$，最低次幂为$0$</li>
<li>将左移后的多项式除以生成多项式$G(x)$所得的余数$R(x)$作为校验码，放到$M(x)·2^r$左边空缺的位上即可</li>
</ol>
<p>​    其编码规则就是要求一个编码多项式使其能够被$G(x)$整除，根据模2运算规则可知这一定是成立的。</p>
<p>​	通过编码过程可知选取的生成多项式非常重要，生成多项式主要有如下几个要求：</p>
<ol>
<li>p任意1位发生错误余数均不为0，这就保证了可以检测单错</li>
<li>p不同位发生错误余数不同，这就保证了可以检测出有错误</li>
<li>p余数左移一位继续作模2除，应使余数循环</li>
</ol>
<p>​	对于一个$(n,k)$码，要获取生成多项式，我们只需要将$x^n+1$进行质因数分解，注意这里分解也要用模2运算，根据码距要求选择相应的生成多项式即可。</p>
<p>​	下面说一下CRC运算的一些特性</p>
<ol>
<li>求余的时候有分配律，比如如果要对原始数据1001编码，可以先求出1000和0001的余数，然后把两个余数作异或即可。</li>
<li>关于循环特性，是指，我们对每个余数左移一位补0，然后去除生成多项式，是一个循环的过程</li>
</ol>
<p>​    然后说一下CRC运算的检错性能，下面的突发错误指的是几乎连续发生的一串错，突发长度是指从出错的第一位到出错的最后一位的长度，中间不一定每一位都错。</p>
<ol>
<li>所有突发长度小于等于$r$的突发错误</li>
<li>$(1-2^{-(r-1)})$比例的突发长度为$r+1$的突发错误</li>
<li>$(1-2^{-r})$比例的突发长度大于$r+1$的突发错误</li>
<li>小于最小码距的任意位数的错误</li>
<li>如果生成多项式中1的个数为偶数，可以检测出所有奇数位错误。</li>
</ol>
<h1 id="数据表示实验"><a href="#数据表示实验" class="headerlink" title="数据表示实验"></a>数据表示实验</h1><p>​	本次实验主要实现了国标转区位码，偶校验编码与检错和CRC编解码。</p>
<h2 id="国标转区位码"><a href="#国标转区位码" class="headerlink" title="国标转区位码"></a>国标转区位码</h2><p>​	这一部分其实很简单，只需要根据课本上给出的公式$区位码+0A0AH&#x3D;GB2312$即可，这里可以用减法器也可以在两边同时加一个数让$0A0AH$溢出，电路如下。</p>
<p><img src="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220619152126714.png" alt="image-20220619152126714"></p>
<h2 id="偶校验编码"><a href="#偶校验编码" class="headerlink" title="偶校验编码"></a>偶校验编码</h2><p>​	只需要根据课本上的逻辑表达式进行计算即可，也就是将所有的位进行异或然后和数据结合起来得到偶校验码，如下图</p>
<p><img src="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220619152251865.png" alt="1"></p>
<h2 id="偶校验检错"><a href="#偶校验检错" class="headerlink" title="偶校验检错"></a>偶校验检错</h2><p>​	本身的思路也很简单，只需要用分线器将各个位提取出来然后把所有的位异或就行，如下</p>
<p><img src="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220619152518068.png" alt="image-20220619152518068"></p>
<h2 id="CRC编码"><a href="#CRC编码" class="headerlink" title="CRC编码"></a>CRC编码</h2><p>​	这里要求能够检出两位错并纠一位错，由于本身CRC编码要求$2^r-1\ge k+r$，这里的$k&#x3D;16$，所以$r$至少为5，所以最后就要决定到底是选择5位的CRC编码，根据所学的CRC编码的知识，我们要保证能够检出两位错并纠一位错，应当保证两位错和一位错的余数均不为0并且不相同，所以我们这里就用5位的CRC就行，但是这个时候有的两位错和一位错的余数是相同的，所以我们需要加一个奇偶校验位来确定到底是两位错还是一位错，如果是一位错的话，奇偶校验位应该会报错，这个时候也确定是一位错，如果是两位错的话，奇偶校验位不报错，但是可以通过CRC检验检出错误。</p>
<p>​	对于奇偶校验位的得到，其实很简单，只需要全部异或即可。对于CRC编码，我们预处理出每一位对应的余数，然后用多路选择器进行异或即可，最终的电路如下。</p>
<p><img src="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220619163901577.png" alt="image-20220619163901577"></p>
<h2 id="CRC检错与纠错"><a href="#CRC检错与纠错" class="headerlink" title="CRC检错与纠错"></a>CRC检错与纠错</h2><p>​	我们先考虑一下如何纠正1位错误。纠错原理是这样的：我们将传送过来的数据左移五位，用0补齐，然后除以生成多项式，可以得到一个余数，将这个余数和校验码进行异或，得到一个新的余数，这个余数是在编码时候对应的哪一位的余数就说明这一位错了，下面我们考虑证明这一点。根据本身模二除法并异或这个运算具有类似分配律的性质，并且校验码除以生成多项式得到的余数仍然是校验码，所以我们只需要证明传递过来的数据除以生成多项式得到的余数等于出错位的余数，证明过程如下：</p>
<blockquote>
<p>首先假设传过来的CRC编码为$a$，正确的编码为$b$，不妨假设出错位是第5位，出错位对应的余数为$c$，则有$b % G(x)&#x3D;0$，进而有$(a\oplus 0x10)%G(x)&#x3D;0$，进而有$(a %G(x))&#x3D;c$</p>
</blockquote>
<p>​	那么，我们只需要进行一个映射就行，这里主要考虑的就是用多路选择器和异或门来做。另外关于检错的问题，如果总校验位和CRC部分都没有错的话，就说明是0位错，如果总校验位没有问题，但是CRC部分出现了问题，就说明是两位错，一旦总校验位出了问题，说明就是一位错。最终设计的电路如下所示。</p>
<p><img src="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220619160640702.png" alt="image-20220619160640702"></p>
<h2 id="CRC编码流水线传输"><a href="#CRC编码流水线传输" class="headerlink" title="CRC编码流水线传输"></a>CRC编码流水线传输</h2><p>​	关于流水线传输这部分，最主要的就是在最后解码检测到出现两位错误时将前面的状态都清空，并且要求发送方重传，这就要求在出现两位错误时，通过清零端减前面的全部清零，然后让当前寄存器指向的ROM中的单元指回前面，从而实现重传，具体需要使用多路选择器，需要注意的是如果一直出错，在到ROM的开始位置时，需要将寄存器也置为0，如下图所示</p>
<p><img src="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220619161819917.png" alt="image-20220619161819917"></p>
<h1 id="运算方法与运算器"><a href="#运算方法与运算器" class="headerlink" title="运算方法与运算器"></a>运算方法与运算器</h1><p>​	这一部分的重点就是用逻辑电路自动实现算术运算</p>
<h2 id="定点加减法运算"><a href="#定点加减法运算" class="headerlink" title="定点加减法运算"></a>定点加减法运算</h2><p>​	显然有补码加法公式$[x]_补+[y]_补&#x3D;[x+y]_补$，直接分类讨论即可证明</p>
<p>​	同时也有补码减法公式$[x-y]_补&#x3D;[x]_补-[y]_补&#x3D;[x]_补+[-y]_补$，可以利用补码加法公式进行证明</p>
<p>​	在运算过程中显然会有溢出的情况，我们应当注意溢出和模数舍弃之间的区别，不难发现，如果两个同符号数相减或者两个异号数相加就会发生模数舍弃，但是显然这并不是溢出。我们要判断是否溢出，主要有下面三种方法</p>
<ol>
<li>当<strong>正正得负，负负得正</strong>时发生了溢出，当然如果时减法的话会发生相应的变化，不过也可以把减法转化成加法</li>
<li>可以根据运算过程中最高数据位与符号位的进位是否一致判断有无溢出，如果不一致就是发生了溢出</li>
<li>用变形补码进行符号检测，变形补码就是我们前面提到过的用两个二进制位表示符号，一般称左边的是第一符号位，右边的是第二符号位，如果运算后这两个符号位不相同的话就说明发生了溢出</li>
</ol>
<p>​	要用逻辑门实现加减法，可以首先构建全加器，然后将若干个全加器串联起来构成串行加法器。一般我们认为一个异或门时间延迟是$3T$，所有与门和或门的时间延迟都是$T$。要构建减法器的话，根据补码减法公式，我们只需要设置一个设置一个控制信号，当其为减法的时候就把$y$变成$-y$送到加法器里进行运算。本身的时间延迟会比单纯的加法器长$3T$，因为在最开始需要经过一个异或门。</p>
<p>​	上面之所以有很大的时间延迟，是因为每一级全加器都需要等待上一级的进位信号运算完毕，现在我们更换运算方式，打破进位依赖。我们设进位生成函数为$G_i&#x3D;X_iY_i$，进位传递函数为$P_i&#x3D;X_i\oplus Y_i$，那么$S_i&#x3D;P_i\oplus C_i，C_{i+1}&#x3D;G_i+P_iC_i$，通过这种方式，我们可以提前把每一级的进位算出来，这样就打破了进位依赖，使得全加器可以并行。当然本身计算进位也需要一定的时间延迟，所以我们一般选择4位一组来进位。有了这个电路，我们就可以构建出4位并行加法器。然后我们把4位并行加法器进行级联就可以获得位宽更大的加法器。当然也有更快的方法，我们考虑让每一级并行加法器多两个信号$G^*,P^*$，这两个信号可以类似并行的计算出下一级的进位，并且和进位没有关系，这就保证了并行性。</p>
<h2 id="定点乘法运算"><a href="#定点乘法运算" class="headerlink" title="定点乘法运算"></a>定点乘法运算</h2><h3 id="原码一位乘法"><a href="#原码一位乘法" class="headerlink" title="原码一位乘法"></a>原码一位乘法</h3><p>​	首先结果的符号应该是两个被乘数的符号位的异或，数值部分就是两者的绝对值相乘，如果用全加器串联构成乘法器的话硬件开销过大，这里就是考虑用递归公式$P_{i+1}&#x3D;(P_i+y_{n-i}|x|)2^{-1}$，也就是每次判断$y$是否是1，如果是就加上$|x|$，否则就不变，然后进行右移操作。</p>
<p><img src="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220619205142385.png" alt="image-20220619205142385"></p>
<h3 id="补码一位乘法"><a href="#补码一位乘法" class="headerlink" title="补码一位乘法"></a>补码一位乘法</h3><p>​	这里就是Booth算法，主要推导也是分一个被乘数的正负去讨论的，最终公式为$[x\times y]_补&#x3D;[x]_补\times |y|-[x]_补\times y_0$，其中$y_0$为符号位，进行加权展开也可以得到类似的递归式，即$P_{i+1}&#x3D;(P_i+(y_{n-i+1}-y_{n-i})[x]_补)2^{-1},0\le i\le n-1$，最终可以得到$[x\times y]_补&#x3D;P_{n+1}&#x3D;P_n+(y_1-y_0)[x]_补$，注意$y_{n+1}&#x3D;0$，也就是说，相比于原码一位乘法，我们这里是要根据$y_{i}$与$y_{i+1}$的值选择去计算哪一个，最终共进行$n+1$次累加操作，$n$次右移操作，并且符号位是会参与运算的</p>
<p><img src="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220619205216929.png" alt="image-20220619205216929"></p>
<h2 id="浮点运算"><a href="#浮点运算" class="headerlink" title="浮点运算"></a>浮点运算</h2><h3 id="浮点加减法运算"><a href="#浮点加减法运算" class="headerlink" title="浮点加减法运算"></a>浮点加减法运算</h3><p>​	这里先考虑阶码和尾数均使用补码进行运算，设有两个浮点数$X&#x3D;2^m\times M_x,Y&#x3D;2^n\times M_y$，主要进行如下几个阶段</p>
<ol>
<li><code>对阶</code>，如果阶码不相同的话，我们需要进行对阶，原则是小阶码向大阶码看齐，这是因为在小阶码变大阶码时尾数右移，精度损失比较小。对阶要先求阶差，即进行减法运算，然后根据阶码的大小去移位。另外，在尾数右移的时候通常将最低位的移出位暂时保留，称为<strong>保留附加位</strong>，并且这些值会参与中间运算，最后根据运算结果来进行舍入。IEEE754通常有3个保留附加位，从左到右依次为保护位、舍入位、粘位，舍入位右侧有非0数据则粘位为1，否则为0</li>
<li><code>尾数运算</code>，对阶完成之后直接对尾数进行运算即可</li>
<li><code>结果规格化</code>，计算完之后将结果规格化，为了简单起见可以将尾数的符号位扩展为双符号位</li>
<li><code>舍入</code>，主要有<strong>末位恒置1法</strong>，即只要因为移位而丢失的位中有一位是1，就把运算结果的最低位置为1，还有<strong>0舍1入法</strong>，类似于四舍五入，若丢失位数最高位为1就将尾数的末位加1</li>
<li><code>溢出判断</code>，也就是阶码符号位是10或01的时候产生溢出</li>
</ol>
<p>​	然后我们讨论一下IEEE754浮点数加减法运算，整体过程与上面基本类似，但是由于其阶码用移码表示，尾数用原码表示，且尾数最高位隐藏，所以会有一些不同，如下</p>
<ol>
<li>对阶和规格化时，阶码运算采用移码加减法</li>
<li>尾数的运算采用原码运算规则，并且隐藏位需要参与运算</li>
<li>隐藏位参与尾数规格化判断以及尾数规格化过程</li>
<li>对于舍入处理，有如下四种<ul>
<li>就近舍入，舍入为最近可表示的数，如果正好在两个数中间就向偶数舍入</li>
<li>向$+\infty$方向舍入，即总是取右侧最近的可表示的数</li>
<li>向$-\infty$方向舍入，即总是取左侧最近的可表示的数</li>
<li>向0方向舍入，直接丢弃多余位</li>
</ul>
</li>
<li>对于溢出判断，结合IEEE754标准的知识，可知当向右规格化使阶码全为1时发生规格化上溢，向左规格化使阶码全为0时发生规格化下溢</li>
</ol>
<h3 id="浮点乘法运算"><a href="#浮点乘法运算" class="headerlink" title="浮点乘法运算"></a>浮点乘法运算</h3><p>​	设浮点数$X&#x3D;2^m\times M_x,Y&#x3D;2^n\times M_y$，则$X\times Y&#x3D;2^{m+n}\times(M_y\times M_x)$，主要就是如下三个步骤</p>
<ol>
<li><code>阶码相加</code>，直接用一个加法器进行运算即可</li>
<li><code>尾数相乘</code>，直接计算即可</li>
<li><code>规格化舍入</code>，舍入方法与加减法相同</li>
</ol>
<h3 id="浮点除法运算"><a href="#浮点除法运算" class="headerlink" title="浮点除法运算"></a>浮点除法运算</h3><p>​	设浮点数$X&#x3D;2^m\times M_x,Y&#x3D;2^n\times M_y$，则$X\div Y&#x3D;2^{m-n}\times(M_x\div M_y)$，主要就是如下四个步骤</p>
<ol>
<li><code>尾数调整</code>，即检查被除数的尾数的绝对值大小是否小于除数的尾数，如果大于就需要将被除数的尾数右移一位并调整阶码</li>
<li><code>阶码求差</code></li>
<li><code>尾数相除</code></li>
<li><code>规格化舍入</code></li>
</ol>
<h2 id="运算器"><a href="#运算器" class="headerlink" title="运算器"></a>运算器</h2><p>​	经过以上的分析，可以知道各种运算都可以用基本的定点加法和移位运算实现。定点运算部件又称为算术逻辑运算单元（<strong>ALU</strong>），除此之外还有浮点运算部件</p>
<h1 id="运算器实验"><a href="#运算器实验" class="headerlink" title="运算器实验"></a>运算器实验</h1><h2 id="8位可控加减法器"><a href="#8位可控加减法器" class="headerlink" title="8位可控加减法器"></a>8位可控加减法器</h2><p>​	这里要求将八个全加器串联构成一个串行八位可控加减法器，要实现可控的目的，只需要在传递过来的$sub$信号为1时，将$y$变成补码即可，由于我们知道变成补码只需要将这个数按位取反再加1就行，所以我们把减法信号和$y$的每一位进行异或，如果减法信号是0的话就把原本的值传进去，如果减法信号是1的话就把这一位取反再传回去，由于还需要加一，所以我们把减法信号接在第一个全加器的进位端即可，最终电路如下</p>
<p><img src="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220620094142248.png" alt="image-20220620094142248"></p>
<p>​	注意这里还需要进行溢出判断，采用的是判断符号位进位和数值最高位进位是否相同的方法。</p>
<h2 id="4位先行进位电路设计"><a href="#4位先行进位电路设计" class="headerlink" title="4位先行进位电路设计"></a>4位先行进位电路设计</h2><p>​	这里的主要思路就是上文提到的设计思路，即用信号$G_i&#x3D;X_iY_i,P_i&#x3D;X_i\oplus Y_i$来对进位进行优化，这里的进位就用公式$C_{i+1}&#x3D;G_i+P_iC_i$对进位进行展开即可，最终电路如下图所示。</p>
<p><img src="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220620094547449.png" alt="image-20220620094547449"></p>
<h2 id="4位快速加法器设计"><a href="#4位快速加法器设计" class="headerlink" title="4位快速加法器设计"></a>4位快速加法器设计</h2><p>​	这里的主要思路其实就是利用四位先行进位电路，把它需要的输入处理出来送进去就行，然后再加异或门来计算最终的和即可，电路如下图所示。</p>
<p><img src="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220620094806016.png" alt="image-20220620094806016"></p>
<h2 id="16位快速加法器设计"><a href="#16位快速加法器设计" class="headerlink" title="16位快速加法器设计"></a>16位快速加法器设计</h2><p>​	这里的主要思路还是利用前面已经设计好的电路，如果把四个四位快速加法器进行串联的话显然又变成了串行，而根据我们前文提到的知识点，每一个四位先行进位电路都会给出$G^*,P^*$的信号，然后我们可以根据这个信号，计算出后四位所需要的信号，进而构成一个并行的进位电路，因为这些信号和上一级的进位信号是没有关系的，仅仅和最开始输入的加数值有关系，所以可以使用这种方法来计算</p>
<p><img src="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220620102126045.png" alt="image-20220620102126045"></p>
<h2 id="32位快速加法器设计"><a href="#32位快速加法器设计" class="headerlink" title="32位快速加法器设计"></a>32位快速加法器设计</h2><p>​	这里一共提供了三种方法，我们依次分析一下它们的时间延迟</p>
<ol>
<li>2个16位加法器直接串联，C16信号采用下层的进位输出，首先，下层进位的时间延迟已经有了9T了，然后第二级16位加法器还需要12T的延迟，所以总共是21T</li>
<li>2个16位加法器直接串联，C16 进位输入采用上层的进位输出，这个时候和上面那种情况相比仅仅是上层进位的时间延迟为2T，所以总共是19T</li>
<li>在16位快速加法器的基础上再增加一级组间先行进位电路，类似64位快速加法器的方法，这种方法就是利用每级16位快速加法器给出的$P^*,G^*$信号，类似于16位快速加法器，直接根据输入获取进位信号。首先每一级得到$P^*,G^*$信号的延迟为7T，然后通过先行进位电路得到下一级的进位信号，又经过了2T的时间延迟，这时候已经有了9T的时间延迟，然后把在第二级里面，要根据这个结果去计算进位，还需要2T+5T的延迟，最终应当是16T，所以我们应该选择这种方式</li>
</ol>
<p>​	最终电路如下所示</p>
<p><img src="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220620112805886.png" alt="image-20220620112805886"></p>
<h2 id="有符号与无符号阵列乘法器"><a href="#有符号与无符号阵列乘法器" class="headerlink" title="有符号与无符号阵列乘法器"></a>有符号与无符号阵列乘法器</h2><p>​	照着课本上的图去练就行，不考，不看了</p>
<h2 id="乘法流水线设计"><a href="#乘法流水线设计" class="headerlink" title="乘法流水线设计"></a>乘法流水线设计</h2><p>​	主要是要实现5位无符号补码流水线，也是照着课本上的连，不考</p>
<h2 id="原码一位乘法器设计"><a href="#原码一位乘法器设计" class="headerlink" title="原码一位乘法器设计"></a>原码一位乘法器设计</h2><p>​	虽然这里说的是原码，但是实际要实现的是两个八位无符号数相乘，主要就是根据上文提到过的递归的方法去实现，也就是说每次计算的过程中，根据当前$y$的最低位是哪个决定是加上0还是x，所以这里要用一个多路选择器，然后在求和之后，将$y$和当前和右移一位，注意这里选择的是逻辑右移，将$C_{out}$加入到最左边，这样防止了中间计算时的溢出造成的影响，将其放入到保存和的寄存器中，然后把当前的后八位送到另一个寄存器中，用来保存$y$的值，另外还需要有一个寄存器用来记录计算次数，显然当计算次数到达八次的时候就计算完毕了，这个时候要将两个结果保存寄存器的使能端置0，最终两个结果保存寄存器中分别保存结果的低八位和高八位，最终电路如下图所示</p>
<p><img src="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220620123602187.png" alt="image-20220620123602187"></p>
<h2 id="补码一位乘法器设计"><a href="#补码一位乘法器设计" class="headerlink" title="补码一位乘法器设计"></a>补码一位乘法器设计</h2><p>​	补码相比于上面的要复杂一点，不过其实也是根据算法流程图来的，首先，从每次加的逻辑开始说起，这里是要看$y_ny_{n+1}$的值的，如果是00或11的话，本次就加0，如果是01的话就加$x$，如果是10的话就加$-x$，注意都是补码，所以如果是10的话我们可以直接将其转化成减法运算，这个时候初始进位是1，所以在进位输入那里加一个与门就行，另外这里是算术右移，所以移动的时候补当前最高位。另外，由于这里的$y$多了一位，所以需要加一个寄存器专门来存储$y_{n+1}$，不过感觉不加应该也行，只是要把一个八位寄存器变成九位应该也行，然后仍然和上面的思路一致，如果是第0次的话就把$y$和0送到寄存器里，如果到了第八次就将寄存器使能端置为0，最终电路如下图所示</p>
<p><img src="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220620125723038.png" alt="image-20220620125723038"></p>
<h2 id="MIPS运算器设计"><a href="#MIPS运算器设计" class="headerlink" title="MIPS运算器设计"></a>MIPS运算器设计</h2><p>​	就是把各种功能组合在一起，用多路选择器进行选择，注意这里也需要对是否发生溢出进行选择，电路如下图所示</p>
<p><img src="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220620130114615.png" alt="image-20220620130114615"></p>
<h1 id="存储系统"><a href="#存储系统" class="headerlink" title="存储系统"></a>存储系统</h1><h2 id="存储器概述"><a href="#存储器概述" class="headerlink" title="存储器概述"></a>存储器概述</h2><h3 id="存储器分类"><a href="#存储器分类" class="headerlink" title="存储器分类"></a>存储器分类</h3><p>​	主要是一下几种分类方式</p>
<ol>
<li>按存储介质分类<ul>
<li>磁存储器</li>
<li>半导体存储器</li>
<li>光存储器</li>
</ul>
</li>
<li>按存取方式分类<ul>
<li>随机存储器（RAM），可以按照地址随机读写数据存储单元，并且存取时间与内存单元的位置无关</li>
<li>顺序存储器（SAM），存储单元中的内容只能依地址顺序访问，且访问速度与存储单元的位置有关</li>
<li>直接存储器（DAM），不必经过顺序搜索就能在存储器中直接存取信息，兼顾了以上两种存储器</li>
</ul>
</li>
<li>按信息的可改写性分类<ul>
<li>读写存储器</li>
<li>只读存储器（ROM）</li>
</ul>
</li>
<li>按照信息的可保存性分类<ul>
<li>易失性存储器</li>
<li>非易失性存储器</li>
</ul>
</li>
<li>按功能和存取速度分类<ul>
<li>寄存器存储器，就是寄存器</li>
<li>高速缓冲存储器，cache</li>
<li>主存储器，就是俗称的内存，不过也包括了BIOS和硬件端口</li>
<li>外存储器，简称外存或辅助存储器。比如磁盘</li>
</ul>
</li>
</ol>
<h3 id="存储器技术指标"><a href="#存储器技术指标" class="headerlink" title="存储器技术指标"></a>存储器技术指标</h3><p>​	主要有如下几点</p>
<ol>
<li><code>存储容量</code>，主要有位表示法和字节表示法</li>
<li><code>存取速度</code>，主要有存取时间，指启动一次存储器操作到完成所需的时间；存取周期，指连续启动两次访问操作之间的最短时间间隔，对于主存而言，存取周期包括存取时间和存储器状态的稳定恢复时间；存储器贷款，指单位时间内存储器所能传输的信息量，与存取时间的长短和一次传输的数据位的多少有关</li>
</ol>
<h2 id="存储系统层次结构"><a href="#存储系统层次结构" class="headerlink" title="存储系统层次结构"></a>存储系统层次结构</h2><p>​	其实主要就是下面的一张图吧</p>
<p><img src="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220620152758047.png" alt="image-20220620152758047"></p>
<h2 id="主存基本结构"><a href="#主存基本结构" class="headerlink" title="主存基本结构"></a>主存基本结构</h2><p>​	主存从空间逻辑上可以看成是一个一维数组，每个数组元素是一个一定位的数据单元</p>
<p>​	关于主存中数据的存放，首先要明确如下两个概念</p>
<ol>
<li><code>存储字长</code>，主存的一个存储单元所存储的二进制位数</li>
<li><code>数据字长</code>，计算机一次能处理的二进制数的位数，简称字长</li>
</ol>
<p>​	存储字长都是字节的整倍数，而主存通常按字节进行编址，每次可以按照不同的方式进行访存，进而主存地址可以分为字节地址、半字地址、字地址，如下图所示</p>
<p><img src="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220620153821835.png" alt="image-20220620153821835"></p>
<p>​	然后就是大端和小端存储，目前主流的一般都是小端。</p>
<p>​	最后关于数据边界对齐，为了保证效率，一般来说应该要求相应类型的数据的起始字节地址是其相应字节数的整数倍</p>
<h2 id="主存的组织与CPU的连接"><a href="#主存的组织与CPU的连接" class="headerlink" title="主存的组织与CPU的连接"></a>主存的组织与CPU的连接</h2><p>​	本身单片存储芯片的存储容量是有限的，所以我们需要通过某种方式将这些东西组织起来，首先需要注意以下两点</p>
<ol>
<li>连接的地址线的数量与CPU要访问的主存容量有关</li>
<li>连接的数据线的数量与计算机字长有关</li>
</ol>
<p>​	由于存储芯片的容量和字长与目标存储器的容量和字长可能存在差异，所以我们需要对其进行适当的扩展，主要有如下几个思路</p>
<ol>
<li><p><code>位扩展</code>，又称为字长扩展或数据总线扩展，当存储芯片的数据总线位宽小于CPU的数据总线位宽时需要这样的扩展，具体做法就是将所有存储芯片的地址线进行并联，将各个存储芯片的数据线依次相联。比如存储器数据位宽为$N$，存储芯片数据位宽为$k$，如果$N&gt;k$，那么我们需要$N&#x2F;k$个存储芯片，如下图。</p>
<p><img src="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220620155614721.png" alt="image-20220620155614721"></p>
<p>​	注意图中的$MREQ$为访存信号，$R&#x2F;W$为读写信号。</p>
</li>
<li><p><code>字扩展</code>，又称为容量扩展或地址总线扩展，当存储芯片的存储容量小于存储器要求的存储容量时需要这样的扩展。这个时候是将所有存储芯片的数据线、读写控制线各自并联，而各个芯片的片选信号由CPU多余的地址线通过译码器移码产生，比如存储器容量为$M$，存储芯片容量为$l$，如果$M&gt;l$，那么我们需要$M&#x2F;l$个存储芯片。示意图如下</p>
<p><img src="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220620160121900.png" alt="image-20220620160121900"></p>
<p>​	这个时候由于CPU有21条地址线，所以访存空间为$2M\times 8$位，而每个存储芯片是$256K\times 8$位，也就是说我们共需要8个存储芯片，地址线中的低18位连接到各芯片的地址线，然后高3位用译码器进行扩充，决定去选择哪一个存储芯片的值，连接到片选信号$CS$段，为1可用，所以说每个芯片的地址范围也都是不一样的</p>
</li>
<li><p><code>字位同时扩展</code>，我们考虑的是首先通过位扩展满足数据位要求，再通过字扩展满足存储总容量要求。假如存储器容量为$M\times N$位，存储芯片容量为$l\times k$位，则共需芯片$M\times N&#x2F;(k\times l)$个芯片，如下图</p>
<p><img src="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220620160912766.png" alt="image-20220620160912766"></p>
</li>
</ol>
<p>​	PPT上有一个题目，感觉还不错，见下</p>
<p><img src="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220620162001291.png" alt="image-20220620162001291"></p>
<h2 id="并行存储系统"><a href="#并行存储系统" class="headerlink" title="并行存储系统"></a>并行存储系统</h2><p>​	旨在通过提升并行性来提升主存的存取速度，主要有如下几个方法</p>
<ol>
<li><p>双端口存储器，指同一个存储器具有两组相互独立的端口。</p>
<ul>
<li>并行读写，当两个端口的地址不同时，显然不会发生冲突</li>
<li>冲突处理，当两个端口的访问地址相同时，会发生读写冲突。为此，为两个端口专门设置了标志$\overline{BUSY}$，发生冲突时通过判断逻辑决定哪个端口优先访问，另一个的$\overline{BUSY}$置0</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220620163129504.png" alt="image-20220620163129504"></p>
</li>
<li><p>单体多字存储器，其构造类似于位扩展，多个存储模块共享地址总线，按同一地址并行访问不同模块的同一单元，从而实现在同一个存储周期中访问多个存储字，重心在于提升带宽。常见的多通道内存采用的就是这样的技术，有联动模式和非联动模式，如下图</p>
<p><img src="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220620163453411.png" alt="image-20220620163453411"></p>
<p>其中，第一个是联动模式，可以将带宽提升一倍，第二个是非联动模式，可以让两者的访问地址不同步。</p>
</li>
<li><p>多体交叉存储器，也由多个存储模块构成，组织方式有如下两种</p>
<ul>
<li>高位多体交叉，主要是为了扩充存储器容量，和存储器字扩展完全相同，也称为顺序编制方式，因为总是按顺序为下一个模块分配地址的。因为程序具有局部性和连续性的特点，所以有可能会仅仅只用一个模块，剩余的模块空闲，从而不能并行。但这样容易扩容，比如内存条</li>
<li>低位交叉方式，这里和字扩展反过来了，使用低位地址移码进行片选，这个时候各个模块中的地址不相邻，所以也被称为交叉编址模式。为了提升性能按照流水线的方式进行访问，这个时候可以考虑，每个模块都去读，然后根据片选信号决定数据总线用哪个值，或者就是连续的一系列值，只需要按顺序读出即可。假设存储模块的存储周期为$T$，总线传输周期及相应的处理时间延迟总和为$\tau$，交叉模块数为$m$，应满足$T&#x3D;m\tau$，则连续读取$n$个字所需的时间为$T+(n-1)\tau$，而不再是刚刚的$nT$</li>
</ul>
</li>
</ol>
<h2 id="高速缓冲存储器"><a href="#高速缓冲存储器" class="headerlink" title="高速缓冲存储器"></a>高速缓冲存储器</h2><h3 id="cache原理与程序局部性"><a href="#cache原理与程序局部性" class="headerlink" title="cache原理与程序局部性"></a>cache原理与程序局部性</h3><p>​	程序局部性是指当程序在执行时成选出局部性规律，主要有如下两点</p>
<ol>
<li>时间局部性，当程序访问一个存储位置时，该位置未来可能会被多次访问</li>
<li>空间局部性，当程序访问了某个存储单元，则其附近的存储单元也即将被访问</li>
</ol>
<p>​	正是因为这些性质，我们引入了cache，基本思想为在处理器附近增加一个隐藏的小容量快速存储器，对程序员透明，将经常访问的热数据的副本存放在cache中，提高命中率优化读性能，主要有用预读处理来利用空间局部性与淘汰算法来利用时间局部性</p>
<h3 id="cache基本概念"><a href="#cache基本概念" class="headerlink" title="cache基本概念"></a>cache基本概念</h3><p>​	首先记录一下cache相关的一些术语</p>
<ol>
<li><code>命中hit</code>：CPU访问的数据在cache中</li>
<li><code>命中访问时间</code>$t_c$：命中时的数据访问时间，包括查找时间的cache访问时间两部分</li>
<li><code>缺失miss</code>：CPU访问的数据不在cache中</li>
<li><code>缺失补偿</code>$t_m$：数据缺失时的访问时间，包括数据查找时间，主存访问时间，cache访问时间，其中主存访问时间是决定部分。</li>
<li><code>块block</code>：cache与主存交换的最小单元，实现了预读，进行数据分块后，主存和cache地址都可以分成块地址和块内偏移</li>
<li><code>行/槽Line/Slot</code>：一个cache数据块和相关的标记标志信息</li>
<li><code>Cold Cache Warm Cache</code>：</li>
<li><code>命中率h</code>：设$N_c$为某程序运行期间命中cache的次数，$N_m$为从主存中访问信息的次数，则有$h&#x3D;\frac{N_c}{N_c+N_m}$</li>
<li><code>缺失率</code>：显然为$1-h$</li>
<li><code>访问效率e</code>：首先易知cache的平均访问时间为$t_a&#x3D;ht_c+(1-h)t_m$，$r&#x3D;\frac{t_m}{t_c}$表示主存与cache访问时间的倍数，则有$e&#x3D;\frac{t_c}{t_a}&#x3D;\frac{t_c}{ht_c+(1-h)t_m}&#x3D;\frac{1}{h+(1-h)r}$</li>
</ol>
<h3 id="cache读写流程与关键技术"><a href="#cache读写流程与关键技术" class="headerlink" title="cache读写流程与关键技术"></a>cache读写流程与关键技术</h3><p>​	CPU读数据的大致流程如下</p>
<ol>
<li>CPU给出主存地址（块地址，块内偏移）</li>
<li>主存块地址为关键字进行查找</li>
<li>如相符表示副本在cache中，命中，访问cache</li>
<li>否则数据缺失，访问主存<ul>
<li>将数据所在块副本调入cache，这样利用了空间局部性</li>
<li>载入副本过程可能引起替换，主要是在cache满的时候会引起替换</li>
<li>更新查找表，记录当前数据块地址</li>
<li>cache缺失时系统等待数据调入</li>
</ul>
</li>
</ol>
<p>​	当CPU写数据时，流程如下</p>
<ol>
<li>CPU给出主存地址</li>
<li>主存块地址为关键字进行查找<ul>
<li>相符则表示命中，数据副本在cache中</li>
<li>缺失根据写分配策略决定是否将该主存地址对应数据块调入</li>
</ul>
</li>
<li>写入数据到cache</li>
<li>根据写策略决定是否写入主存</li>
</ol>
<p>​	根据上面的流程，可以看出cache主要有如下几项关键技术</p>
<ol>
<li>数据查找，即如何快速判断数据是否在cache中</li>
<li>地址映射，主存中的数据块应当如何放置到cache中，是任意放置还是按照一定的规则放置</li>
<li>替换策略，cache满后的处理方法，应当选择哪一个块去淘汰</li>
<li>写入策略，这里关系到cache和主存数据的一致性，分为写回和写穿两种</li>
</ol>
<p>​	下面会依次介绍这些技术</p>
<h3 id="相联存储器"><a href="#相联存储器" class="headerlink" title="相联存储器"></a>相联存储器</h3><p>​	这里主要解决了查找问题，类似于哈希表，存储单元为键值对，输入是key，输出对应的value。另外每个键值对还对应了一个有效位，为1时说明当前的数据是有效的，否则就是无效的</p>
<p><img src="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220620193810901.png" alt="image-20220620193810901"></p>
<p>​	上图就是示意图，可以看到每个键值对都有一个比较器，所以代价会比较高。其存储容量就是表项数*表项大小，而表项内容就是有效位+主存块地址+cache块地址</p>
<p>​	另外，相联存储器本身有两种结构，如下</p>
<ol>
<li>查找表和缓存副本一体（CPU片内缓存）<ul>
<li>存放cache行</li>
<li>有效位，主存块地址，数据块副本， 标志位（Dirty bit），置换标记</li>
<li>存储容量＝ cache行大小 × 行数</li>
</ul>
</li>
<li>查找表和缓存副本分离（片内查找表，片外缓存）<ul>
<li>存放查找信息</li>
<li>有效位，主存块地址，cache块地址，标志位（Dirty bit），置换标记</li>
<li>存储容量＝查找表表项大小 × 行数</li>
</ul>
</li>
</ol>
<h3 id="地址映射"><a href="#地址映射" class="headerlink" title="地址映射"></a>地址映射</h3><p>​	地址映射就是把主存地址空间映射到cache的地址空间，也就是把存放在主存中的程序或数据块载入cache块的规则，主要有如下三种方法</p>
<ol>
<li><p><code>全相联映射</code>，即各主存块都能映射到cache的任意数据块</p>
<p>在具体实现的过程中，其实也是哪里空了就放在哪里，具体的硬件实现如下图所示</p>
<p><img src="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220620200108375.png" alt="image-20220620200108375"></p>
</li>
</ol>
<p>​		可以看到这里的Hit信号连接了多路选择器的使能端，然后多路选择器的选择端连接了偏移地址，如果是写命中的话需要将脏数据标志位置成1，另外，如果主存地址被划分成了$(s,w)$，则cache实际容量为$n\times (1+s+8\times 2^w)$，当然这里不考虑脏数据位和淘汰计数</p>
<p>​		可以看出，全相联映射的cache利用率高，块冲突概率低，但是成本比较高，替换算法也比较复杂</p>
<ol start="2">
<li><p><code>直接相联映射</code>，直接相连映射中的每个主存块地址只能映射到相应的行，具体规则是$cache行号i&#x3D;主存块号j mod(cache行数n)$</p>
<p>这种方法近似于将主存按cache大小进行分区，每个区中包含的块数和cache行数相同，因此主存地址可以细分成区地址tag、区内行索引index、块内偏移offset三部分，即$(s-r,r,w)$，那么cache行数为$n&#x3D;2^r$，则cache实际容量为$n\times(1+s-r+8\times 2^w)$，实际查找的过程中的逻辑很简单，只需要根据index快速查找cache对应的行，然后判断tag和key是否一样，一样就说明命中，具体硬件实现如下图所示</p>
<p><img src="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220620201724805.png" alt="image-20220620201724805"></p>
</li>
</ol>
<p>​		从上面可以看出，这里并没有使用相联存储器，而是仅仅使用了一个比较器。不过这种方法的映射速度快，替换算法简单，但是命中率低，cache的利用率也低</p>
<ol start="3">
<li><p>组相联映射，这种映射方式是以上两种的折中。将cache分成固定大小的组，每组k行，称为k-路组相联，主存数据块首先采用直接相连映射的方法定位到固定的组，然后用全相联映射的方法映射到组内任意一个cache行，进而可以将主存地址分为标记字段tag、组索引index、块内偏移offset。在进行查找时，首先利用主存块地址中的组索引字段index定位到具体的组，然后将标记字段和组内所有行的标记字段进行全相联并发比较。硬件实现如下图所示</p>
<p><img src="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220620204512504.png" alt="image-20220620204512504"></p>
</li>
</ol>
<h3 id="替换策略"><a href="#替换策略" class="headerlink" title="替换策略"></a>替换策略</h3><p>​	主要有如下四种算法</p>
<ol>
<li><code>先进先出算法</code>，就是最先载入cache的行会被替换掉，这种算法需要维护一个时间戳，虽然简单，但是没有考虑程序运行的局部性</li>
<li><code>最不经常使用算法LFU</code>，淘汰被访问次数最少的cache行，这个时候每行都必须要设置一个淘汰计数器，硬件成本较高。当需要淘汰的时候就对所有的计数值进行比较，然后淘汰次数最少的哪个。但是这种算法并不能严格反应近期访问情况</li>
<li><code>近期最少使用算法LRU</code>，将近期最久没有被使用过的行淘汰。每行也要设置一个计数器，cache每命中一次，对应行的计数器清0，其它行计数器自增，难点就在于如何快速比较多行计数器。当然如果是二路组相联的话就比较简单，只需要用一个二进制位进行标值即可，即如果第一行命中就设置成1，第二行命中就设置成0，然后需要替换的时候就检查这个二进制位就行</li>
<li><code>随机替换算法</code>，就是随机替换，当cache很大的时候效果会比较好</li>
</ol>
<h3 id="写入策略"><a href="#写入策略" class="headerlink" title="写入策略"></a>写入策略</h3><p>​	写入策略主要有两种，如下</p>
<ol>
<li><code>写回法WB</code>，当CPU对cache写命中时，只修改cache内容而不立即写入主存，只有当此行被替换出cache时才会写入主存，这个时候每个cache都必须要配置一个标志位，即<strong>脏位</strong>，用来表示此行是否被改写过</li>
<li><code>写穿法WT</code>，当cache写命中时，同时对cache和主存中的同一数据位进行修改。</li>
</ol>
<h3 id="cache应用"><a href="#cache应用" class="headerlink" title="cache应用"></a>cache应用</h3><p>​	主要有分离cache，多级cache，软件cache，见下图</p>
<p><img src="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220620212605651.png" alt="image-20220620212605651"></p>
<h1 id="存储系统设计实验"><a href="#存储系统设计实验" class="headerlink" title="存储系统设计实验"></a>存储系统设计实验</h1><h2 id="汉字字库存储芯片扩展实验"><a href="#汉字字库存储芯片扩展实验" class="headerlink" title="汉字字库存储芯片扩展实验"></a>汉字字库存储芯片扩展实验</h2><p>​	这里是要用4片4K*32位的ROM构建出一片16K*32位的ROM，主要考察了字扩展的知识。</p>
<p>​	这里的地址总线总共14位，根据上文的知识，需要用2根地址总线决定选择哪个4K*32位的ROM进行输出，剩下的12根地址总线决定了4K*32位的ROM的地址，也就是说我们需要一个译码器来连接4K*32位ROM的译码信号，同时也连接多路选择器决定输出哪一个，最终电路图如下所示</p>
<p><img src="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220621091127467.png" alt="image-20220621091127467"></p>
<p>​	另外需要注意的是这里的4片4K*32位的ROM中的内容，由于我们是通过12根地址线选择其中的内容的，地址范围为$2^{12}$也即4096B，所以我们只需要填满即可，也就是就这样依次去填充就行，也就是说这里其实用3片就足够了，当然如果要构建16K的话还是要4片。</p>
<h2 id="MIPS寄存器文件设计"><a href="#MIPS寄存器文件设计" class="headerlink" title="MIPS寄存器文件设计"></a>MIPS寄存器文件设计</h2><p>​	这里就是要实现一个可读可写的寄存器堆，一共有四个寄存器。</p>
<p>​	要实现写功能，需要用一个译码器来对写信号进行移码，从而决定写哪个寄存器，此外这里需要和写使能信号经过一个与门之后一起连接到寄存器的使能端，由于要求0号寄存器恒0，所以该寄存器输入端连接常量0，其余的输入端都连接输入$D_{in}$，然后将寄存器的输入连接到多路选择器，根据读信号决定输出哪个</p>
<p><img src="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220621092617212.png" alt="image-20220621092617212"></p>
<h2 id="MIPSRAM设计"><a href="#MIPSRAM设计" class="headerlink" title="MIPSRAM设计"></a>MIPSRAM设计</h2><p>​	这里是要实现一个可以进行按字节、双字节、四字节进行访问的存储系统，使用4个8位的RAM实现。</p>
<p>​	首先我们先将4个8位的RAM进行连接，这里的连接方法和位扩展类似，地址都一样，输出用不同的隧道连接，然后输入就是相应的数据，电路图如下</p>
<p><img src="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220621094109281.png"></p>
<p>​	然后我们依次去看$D_{in}$和$D_{out}$，这里两个信号都是32位，不同访问模式的有效信息放在最低位，所以我们需要进行适当的处理。首先看$D_{in}$，我们需要用分线器将其分成4个8位，依次存到这4个RAM中，然后用多路选择器进行相应的连接就行，只需要注意和模式相匹配就行。然后是$D_{out}$，也是用分线器和多路选择器，如果是按字访问的话需要用分线器将四个输出合在一起，如果是按单字节访问的话要根据单字节片选信号决定选择哪一个，然后进行位扩展，双字节访问也是一样的道理，两部分电路如下图所示</p>
<p><img src="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220621094938952.png" alt="image-20220621094938952"></p>
<p>​	接下来我们将字节地址作相应的处理，从中得到我们需要的几个信号，只需要根据题目要求进行译码即可</p>
<p><img src="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220621095616070.png" alt="image-20220621095616070"></p>
<p>​	最后只需要对写信号进行处理即可。首先如果是写入一个字数据的话，说明4个RAM都需要改变，如果是写入一个字节数据的话，要根据片选信号决定是选择哪一个RAM，只有这个会被改变，如果是双字节的话也是一样的，然后通过或门把以上的信号合起来，最后在和写使能信号进行与操作即可，电路如下图所示</p>
<p><img src="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220621100320599.png" alt="image-20220621100320599"></p>
<h2 id="2路组相联cache设计"><a href="#2路组相联cache设计" class="headerlink" title="2路组相联cache设计"></a>2路组相联cache设计</h2><p>​	这一部分很复杂，需要依次实现cache中的一些功能。首先我们对主存地址进行译码，首先每个块有四个字节，所以offset有两位，然后cache共8行，是2路组相联，故共4组，也就是index有2位，剩下的都是标记位，故电路如下图所示</p>
<p><img src="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220621101613536.png" alt="image-20220621101613536"></p>
<p>​	接下来我们来设计命中或缺失时的电路，逻辑其实也比较简单，根据index选择相应的组，然后在组内进行全相联映射，查找有没有相应的tag，如果有的话就去进行相应的输出操作，并且设置hit和miss信号，如下图所示</p>
<p><img src="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220621102949894.png" alt="image-20220621102949894"></p>
<p>​	可以看到在上图中我们将每一行的tag位和valid位合起来，用多路选择器选择相应的组，然后进行并发比较，如果相等的话就通过解复用器，用index选择具体的行，如果两边有一个查找到，就把hit置为1，否则置为0。</p>
<p>​	接下来我们看一下未命中时的处理逻辑，首先未命中的时候我们需要实现一个淘汰算法，这里使用的应该是LRU算法，用标志位C作为计数位。在未命中的时候，我们要么把当前的一个有效cache块通过LRU算法淘汰，要么替换一个无效的cache块。我们分别看这两个的实现。首先对于LRU算法，我们需要比较当前组中两个行的C标志位的大小，然后根据index去输出具体哪一个，这里使用了库中提供的MAX2组件。然后对于无效的cache行，我们只需要使用多路选择器，然后使用优先编码器即可，这里的优先编码器的作用是从两个输入中选择位置最大的值为1的地址，其实就是每一组中的第一行或第二行，另外这里的FULL信号是在当前组中的行全部有效的时候为1，这个时候就要使用LRU算法了。</p>
<p><img src="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220621104445770.png" alt="image-20220621104445770"></p>
<p>​	当然其实根据上文中的知识，只需要在每一组设置一个标志位就可以很轻松的决定如果两个都有效的时候淘汰哪个，不过这里没有这么做。</p>
<p>​	然后我们根据上面实现的这些信号，很容易的就可以实现要写哪一行的逻辑，如下</p>
<p><img src="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220621104944481.png" alt="image-20220621104944481"></p>
<p>​	接下来看一下关于结果输出的电路，其实只需要用用一个多路选择器即可，如下</p>
<p><img src="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220621105158299.png" alt="image-20220621105158299"></p>
<p>​	最后是cache的槽电路，共需要八个，每个电路都需要寄存器去存储各种信息，比如tag，valid，c，blockdata，总体如下所示</p>
<p><img src="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220621110217033.png" alt="image-20220621110217033"></p>
<p>​	可以看到只有当这个cache被写过的时候，将相关寄存器的使能端置成1，然后改变相应的信号，然后用读某个行的信号L结合三态门来决定最后输出的信号Slot，然后这个时候需要将c置成0。通过write信号对valid、tag、data进行锁存，在它不变的时候都不会发生变化。</p>
<p>​	最终我们成功设计出了cache</p>
<h1 id="指令系统"><a href="#指令系统" class="headerlink" title="指令系统"></a>指令系统</h1><h2 id="指令系统概述"><a href="#指令系统概述" class="headerlink" title="指令系统概述"></a>指令系统概述</h2><p>​	指令系统就是一台计算机中所有指令的集合，主要有完备性、规整性、有效性、兼容性、可扩展性几个特征</p>
<h2 id="指令格式"><a href="#指令格式" class="headerlink" title="指令格式"></a>指令格式</h2><p>​	指令格式是用二进制代码表示指令的结构形式，一般格式如下图所示</p>
<p><img src="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220621133257788.png" alt="image-20220621133257788"></p>
<p>​	操作码字段用来明确进行什么操作，地址码字段用来找到操作数，除了上图，寻址方式也可以被隐藏在操作码字段</p>
<h3 id="指令字长度"><a href="#指令字长度" class="headerlink" title="指令字长度"></a>指令字长度</h3><p>​	指令字长度指一条指令中所包含的二进制位数，也称为<strong>指令字长</strong>，定长指令系统的指令长度固定，结构简单，但是平均指令较长，冗余较多；定长指令系统的指令长度可变，结构灵活，但是设计起来更加复杂。无论是哪种系统，指令字长都应该是字节的整数倍，根据其与机器字长的关系，可以分为半字长、单字长、多字长指令。多字长的取指令速度慢，但是功能更强</p>
<h3 id="指令地址码"><a href="#指令地址码" class="headerlink" title="指令地址码"></a>指令地址码</h3><p>​	指令地址码的具体含义由寻址方式和操作码字段决定。根据一条指令中所含操作数地址的数量，可以将其分为三地址指令、双地址指令、单地址指令</p>
<p><img src="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220621133952686.png" alt="image-20220621133952686"></p>
<p>​	此外，对于双地址指令，可以根据操作数指向的存储空间是寄存器还是存储器进一步划分成RR、RS、SS型。通常也会使用隐含地址来压缩指令长度，比如Mul指令</p>
<h3 id="指令操作码"><a href="#指令操作码" class="headerlink" title="指令操作码"></a>指令操作码</h3><p>​	操作码字段长度决定了指令系统的规模。操作码主要有如下两种</p>
<ol>
<li><p><code>定长操作码</code>，此操作码的长度固定，并且在指令中的位置固定，因此移码简单。假设指令系统包括$m$条指令，则操作码的位数$n$满足$n&gt;log_2m$</p>
</li>
<li><p><code>变长操作码</code>，此操作码长度可变且位置不固定。可以使用扩展操作码技术实现，基本思想是操作码长度随地址码的减小而增加，如下图</p>
<p><img src="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220621134745228.png" alt="image-20220621134745228"></p>
<p>图中指令为定长32位。单操作数指令的高8位不能和双操作数的操作码相同，否则译码时无法区分。以上面的为例，假设我们要设计255条双操作数指令、17条单操作数指令，那最多还能设计多少条无操作数指令？首先单操作数总共的状态应该是$(2^8-255)\times 2^{12}$，那么无操作数指令就应该是$((2^8-255)\times2^{12})-17)\times2^{12}$</p>
</li>
</ol>
<h2 id="寻址方式"><a href="#寻址方式" class="headerlink" title="寻址方式"></a>寻址方式</h2><p>​	这里其实和汇编语言中学习的就基本差不多了，主要记录一下之前没有接触过的方式。</p>
<p>​	首先指令和操作数都是要寻址的，先看指令寻址。</p>
<p>​	指令寻址方式主要有如下两种</p>
<ol>
<li><code>顺序寻址</code>，就是按照顺序寻址，通过程序计数器PC进行寻址，即$Mem[pc++]-&gt;IR$</li>
<li><code>跳跃寻址</code>，就是出现分支的时候，通过指令本身给出的值修改PC的值</li>
</ol>
<p>​	然后是操作数寻址方式，需要寻址方式这一字段，字段的位数与需要支持的寻址方式的数量有关，主要有如下几种寻址方式</p>
<ol>
<li><p><code>立即寻址</code></p>
</li>
<li><p><code>寄存器寻址</code></p>
</li>
<li><p><code>直接寻址</code></p>
</li>
<li><p><code>间接寻址</code>，需要两次访存，已淘汰</p>
</li>
<li><p><code>寄存器间接寻址</code>，指令中的地址码是寄存器编号</p>
</li>
<li><p><code>相对寻址</code>，指令中的地址码加上PC中的内容作为操作数的地址，注意这里PC中的值已经是下一条指令的地址了</p>
</li>
<li><p><code>变址寻址</code>，形式地址字段增加一个变址寄存器编号，该寄存器中存放变化的地址，该寄存器中的值与形式地址的和就是目标地址，注意形式地址字段应当是不变的 </p>
</li>
<li><p><code>基址寻址</code>，指定一个寄存器存放基地址，一旦设定之后就不会变化，而形式地址存放变化的地址值，一般情况下会设定一个基址寄存器，所以基本采用隐含寻址，不需要显式指出</p>
</li>
<li><p><code>堆栈寻址方式</code>，主要有存储器堆栈和寄存器堆栈两种，前者就是我们所熟知的堆栈，用SP指向栈顶，而后者比较特殊，如下图所示</p>
<p><img src="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220621142229462.png" alt="image-20220621142229462"></p>
<p>可以发现它的栈顶不动，仅仅只有数据在变动，速度快，容量小</p>
</li>
</ol>
<h2 id="指令格式设计"><a href="#指令格式设计" class="headerlink" title="指令格式设计"></a>指令格式设计</h2><p>​	主要有如下几步</p>
<ol>
<li>指令编码格式的设计，主要是要明确是定长指令、变长指令还是混合编码指令</li>
<li>操作码的设计，比较简单，主要是要确定是采用定长结构还是变长结构</li>
<li>地址码的设计，要把寻址方式考虑进去</li>
<li>寻址方式的设计，这个主要是考虑是和操作码一起编码还是和地址码一起，一般来说如果寻址方式比较多的话应该采用后者</li>
</ol>
<h2 id="CISC和RISC"><a href="#CISC和RISC" class="headerlink" title="CISC和RISC"></a>CISC和RISC</h2><p>​	前者是复杂指令集，后者是精简指令集</p>
<h1 id="中央处理器"><a href="#中央处理器" class="headerlink" title="中央处理器"></a>中央处理器</h1><h2 id="CPU概述"><a href="#CPU概述" class="headerlink" title="CPU概述"></a>CPU概述</h2><p>​	CPU主要有五方面的功能，即程序控制、操作控制、时序控制、数据加工、中断处理五个功能，由运算器和控制器组成，运算器负责执行，控制器负责取指令、译码等等。</p>
<p><img src="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220621163732007.png" alt="image-20220621163732007"></p>
<h2 id="指令周期"><a href="#指令周期" class="headerlink" title="指令周期"></a>指令周期</h2><p>​	通常将一条指令从取出到执行完成所需要的时间称为指令周期，一个程序也可以进一步分成几个不同周期，如取指和执行周期，一条指令执行的基本流程如下图所示</p>
<p><img src="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220621163943305.png" alt="image-20220621163943305"></p>
<p>​	下面介绍几个名词</p>
<ol>
<li>时钟周期&#x3D;节拍脉冲&#x3D;振荡周期，能完成一次位操作</li>
<li>机器周期&#x3D;CPU周期，从主存读出一条指令的最短时间</li>
<li>指令周期，从主存取一条指令并执行指令的时间</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220621164616948.png" alt="image-20220621164616948"></p>
<p>​	可以根据指令周期的具体实现将其划分成定长指令周期和变长指令周期</p>
<ul>
<li>定长指令周期采用传统三级时序系统进行同步，机器周期数固定，节拍数固定，按机器周期同步，如mips单周期</li>
<li>变长指令周期采用现代时序系统进行同步，机器周期数可变，节拍数可变，按时钟周期进行同步，如mips多周期</li>
</ul>
<h2 id="数据通路及指令操作流程"><a href="#数据通路及指令操作流程" class="headerlink" title="数据通路及指令操作流程"></a>数据通路及指令操作流程</h2><p>​	数据在各功能部件之间传送的路径称为数据通路，是在控制信号的控制下进行传送的。</p>
<h3 id="数据通路模型与定时"><a href="#数据通路模型与定时" class="headerlink" title="数据通路模型与定时"></a>数据通路模型与定时</h3><p>​	下面给出一个简单的数据通路模型</p>
<p><img src="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220621165450575.png" alt="image-20220621165450575"></p>
<p>​	显然，我们希望时钟频率尽可能的大，所以下面探究一下时钟周期和什么有关。</p>
<p>​	对于D触发器，有下面几个属性</p>
<ol>
<li>建立时间Setup Time：在时钟触发前输入需要稳定保持的一段时间</li>
<li>保持时间Hold Time：在时钟触发后输入需要稳定保持的一段时间</li>
<li>触发器延迟Clk_to_Q：在时钟出发后经过这段时间才会有稳定输出</li>
</ol>
<p>​	我们看下面这张图</p>
<p><img src="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220621170234651.png" alt="image-20220621170234651"></p>
<p>​	通过这张图，我们可以很清晰的看出来时钟周期$T$应当满足$T&gt;clk_to_q+Setup Time+T_{max}$，此外，保持时间也需要一个限制，即$Clk_to_Q+T_{min}&gt;HoldTime$，其中$T_{min}$是最短路径延迟，不过我们一般关注前面那个</p>
<h3 id="单总线结构的数据通路"><a href="#单总线结构的数据通路" class="headerlink" title="单总线结构的数据通路"></a>单总线结构的数据通路</h3><p>​	CPU单总线架构常用的一个示意图如下</p>
<p><img src="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220621182858605.png" alt="image-20220621182858605"></p>
<p>​	我们下面用具体的例子说明一些MIPS指令的执行周期，这里仅仅以lw命令来距离。</p>
<p>​	lw rt,imm(rs)的作用是访问rs寄存器对应的值加上立即数imm后对应的内存，将其送到寄存器rt中，其执行过程一共需要三个机器周期</p>
<ol>
<li>取指周期$M_{if}$，主要是取指令的整个流程<ol>
<li>将程序计数器PC的值送到AR和X中，则$PC_{out}&#x3D;1,X_{in}&#x3D;1,AR_{in}&#x3D;1$</li>
<li>将PC的值加4送到Z中，则$+4&#x3D;1$</li>
<li>从主存中读数据送到DR，并将Z送回PC，则$PC_{in}&#x3D;1,Z_{out}&#x3D;1,Read&#x3D;1,DRE_{in}&#x3D;1$</li>
<li>把DR中的内容送到指令寄存器IR中，则$DR_{out}&#x3D;1,IR_{in}&#x3D;1$</li>
</ol>
</li>
<li>计算周期$M_{cal}$，主要是去计算相应的值<ol>
<li>将rs寄存器的值送到X，则$X_{in}&#x3D;1,R_{out}&#x3D;1$</li>
<li>将立即数的值扩展后送到B端并运算，则$ADD&#x3D;1,IR(I)_{out}&#x3D;1$</li>
</ol>
</li>
<li>执行周期$M_{ex}$，进行执行<ol>
<li>将Z送到AR，则$Z_{out}&#x3D;1,AR_{in}&#x3D;1$</li>
<li>将AR对应的值送到DR，则$DRE_{in}&#x3D;1,Read&#x3D;1$</li>
<li>将DR的值送到寄存器rt中，则$DR_{out}&#x3D;1,R_{in}&#x3D;1$</li>
</ol>
</li>
</ol>
<p>​	剩下的一些指令其实都是类似的，这里就不作过多赘述了。另外，在上文提到的时钟周期限制处，这里的关键路径应该是所有时钟周期中数据通路的最大时间</p>
<h2 id="时序与控制"><a href="#时序与控制" class="headerlink" title="时序与控制"></a>时序与控制</h2><p>​	在上面我们分析了每个指令执行的流程，在执行的过程中需要各种控制信号的配合，接下来我们要做的就是去控制这些控制信号的开始与结束。这个时候需要<strong>时序产生器</strong>来生成机器周期、节拍周期、节拍脉冲，然后每个控制信号都被这三个周期去控制，这是三级时序系统，现代时序系统的定时信号就是时钟信号。</p>
<p>​	这里主要采取的控制方式就是同步控制，基本思想就是选取各部件中最长的操作时间作为统一的时间间隔标准，使所有部件都在这个时间间隔内启动并完成操作。主要有如下几种同步控制方法</p>
<ol>
<li>定长指令周期，所有指令的周期具有相同的机器周期数和节拍数，容易造成时间浪费</li>
<li>机器周期数固定，节拍数不固定，将大多数指令安排在相对固定和时间较短的机器周期内解决，而对于某些操作采取演唱机器周期的办法解决</li>
<li>中央与局部控制相结合，将大多数指令安排在固定的机器周期内完成（中央控制），对少数复杂而又耗时长的指令就采取另外的时序并进行定时控制（局部控制），也就是说，需要多少个，就给多少个</li>
</ol>
<p>​	然后我们介绍时序发生器，主要根据输入的指令译码信号输出相应的状态周期和节拍电位，当然，在定长指令周期中，仅仅通过时钟信号即可。</p>
<p><img src="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220621192211680.png" alt="image-20220621192211680"></p>
<p>​	定长指令周期的设计主要就是下面这张图，通过构建状态机，然后每个状态都对应了一个机器周期和一个节拍，生成真值表，然后就可以构建一个组合逻辑的时序发生器</p>
<p><img src="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220621192522645.png" alt="image-20220621192522645"></p>
<p>​	而变长指令周期的设计主要如下图所示，相比于定长的，这里需要根据具体的指令来确定状态转移</p>
<p><img src="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220621192735037.png" alt="image-20220621192735037"></p>
<p>​	最后，这里的周期都结束在下跳沿，这是因为我们的数据锁存都在上跳沿，为了符合D触发器对于数据时间的要求，这里必须要使用下跳沿</p>
<p>​	在有了产生具体的周期的电路之后，我们需要产生控制信号的电路，即控制器，下面依次介绍硬布线控制器和微程序控制器</p>
<h2 id="硬布线控制器"><a href="#硬布线控制器" class="headerlink" title="硬布线控制器"></a>硬布线控制器</h2><p>​	硬布线控制器内部结构相对复杂但速度较快，下面是采用传统三级时序的硬布线控制器模型</p>
<p><img src="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220621193723726.png" alt="image-20220621193723726"></p>
<p>​	可以看出，每个控制信号都可以表示成逻辑表达式，即$C_n&#x3D;\sum_{m,i,k,j}(I_m·M_i·T_k·B_j)$，可以看到机器周期和节拍电位都在这个逻辑表达式中，控制着每个控制信号的产生与结束。</p>
<p>​	三级时序的硬布线控制器设计流程如下</p>
<ol>
<li>分析数据通路，明确操作控制信号的具体节拍和机器周期</li>
<li>根据控制信号的同步方式构造合适的时序发生器</li>
<li>获取每个控制信号的逻辑表达式，构造硬布线控制器</li>
</ol>
<p>​	其中第一步就是我们在上文进行的，我们分析了lw指令执行过程中各个机器周期的各个节拍的控制信号，第二步就是选择是变长还是定长，然后去构造时序发生器</p>
<p>​	<strong>另外，我们之前设计的都是没有$Z_{in}$信号的，而是通过三态门来输出，这就导致了如果采用定长指令周期，在将值传给Z和从Z传出值之间不能有空节拍，会导致Z的值失效，这是在设计过程中要考虑的问题。</strong></p>
<p>​	然后我们再来看一下现代时序，很显然现代时序是不需要时许发生器的，因为它的定时信号就是基本时钟，基本模型如下所示</p>
<p><img src="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220621195604969.png" alt="image-20220621195604969"></p>
<p>​	对于现代时序，我们考虑将不同指令执行的每个时钟周期都作为一个状态，根据这些状态得到如下的状态转移图，值得注意的是，并不一定是每条指令都有不同的状态路径，很显然lw和sw中的S4、S5和S9、S10做了相同的事情，也可以把他们合在一起然后在下面做分支，不这样做是为了后面让设计微程序控制器更简单</p>
<p><img src="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220621195833928.png" alt="image-20220621195833928"></p>
<p>​	进而，我们可以总结出现代时序硬布线控制器的设计步骤，如下</p>
<ol>
<li>分析数据通路，明确各个节拍发生的控制信号</li>
<li>构建状态转移图和真值表，获得逻辑表达式</li>
<li>实现状态转移的组合逻辑</li>
<li>实现控制器输出的组合逻辑</li>
</ol>
<h2 id="微程序控制器"><a href="#微程序控制器" class="headerlink" title="微程序控制器"></a>微程序控制器</h2><p>​	微程序是利用了软件思想设计硬件的技术，将指令系统中所有指令功能所需要的所有控制信号按照一定的规则编码成微指令，若干条实现同一条指令功能的微指令构成一段微程序，将实现所有指令的微程序放到ROM中，这个ROM称为<strong>控制存储器</strong>，简称控存。</p>
<p>​	进而，我们只需要取指执行指令然后去执行相应的微程序，进而执行微程序中的伪指令，最终就可以生成控制信号</p>
<p>​	另外还有微命令和微操作的概念</p>
<ul>
<li>微命令，指控制部件向执行部件发出的各种控制命令</li>
<li>微操作，指执行部件收到微命令后所进行的操作，微操作包括相容性和互斥性两种，相容性微操作指一组可以在一个时钟周期内完成的微操作</li>
</ul>
<p>​	下面是一个常见的微指令格式</p>
<p><img src="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220621202030268.png" alt="image-20220621202030268"></p>
<p>​	操作控制字段的每一位对应一个控制信号，顺序控制字段决定一段微程序里的微指令的先后顺序，包括下址字段和判别测试字段，前者存放了下一条微指令的地址，后者指出了微指令执行过程中需要测试的外部条件，如果条件成立就会对下址字段进行修改，实现分支跳转。</p>
<p>​	通常，我们会将取值周期的操作编织成一段公共的微程序，即取指微程序，并将其放在控存最开始的地方。取指令译码分支跳转靠标志位$P_0$来实现，为1则说明不需要检查别的条件，直接根据译码情况进行跳转。</p>
<p>​	我们将取出并执行一条微指令所需的时间定义为微指令周期，简称微周期</p>
<p>​	下面是微程序控制器的原理图</p>
<p><img src="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220622082857870.png" alt="image-20220622082857870"></p>
<p>​	主要由控存、地址转移逻辑、微地址寄存器三部分组成，微地址寄存器最开始被初始化成0，靠时钟控制它的地址更新。对于地址转移逻辑，主要有如下两种方法</p>
<ol>
<li><code>下址字段法</code>，又称断定法，每次都通过下址字段来得到后续微地址，注意一段微程序的最后一条微指令的下址字段通常都是指向取指微程序的入口地址，在判别字段不符合时就选择下址字段，也就是说地址转移逻辑中具体就是一个条件判别测试程序和多路选择器，另外也要根据指令移码信号得到一个地址</li>
<li><code>计数器法</code>，这里的微指令中不再包括下址字段，用类似于程序计数器PC的方法来选择下一条执行的微指令，这意味着微指令必须存储在控存中的连续存储单元中。另外也需要在判别测试字段加一个测试位$P_{end}$，为1则表示当前微指令是当前微程序的最后一条微指令，需要由地址转移逻辑将取指令微程序入口送到微地址寄存器中</li>
</ol>
<p>​	下面给出了具体化的地址转移逻辑</p>
<p><img src="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220622084149693.png" alt="image-20220622084149693"></p>
<p>​	其中的译码测试位$P_0$值为1则说明微指令后续地址应该根据指令译码情况选择指令对应的微程序入口地址</p>
<p>​	下面我们以之前的单总线CPU为例，设计一个微程序控制器</p>
<p>​	首先我们需要分析指令周期、数据通路，各个节拍对应的操作控制信号，这部分上文给出，此处不做赘述。</p>
<p>​	然后我们要设计微指令，之前的单总线CPU有22个控制信号，所以微指令的微操作控制字段应该有22位，然后beq指令需要有一个equal表示，所以如果使用下址字段法的话判别字段应该有两位，如果使用计数器法的话应该有3位。对于下址字段法中的下址字段，和控存的容量以及所有微程序的规模有关，这里暂定为5位。</p>
<p>​	接下来要根据相应的指令设计微程序，首先取指微程序是公操作，根据之前的学习，取指微程序应当如下图所示</p>
<p><img src="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220622090207744.png" alt="image-20220622090207744"></p>
<p>​	可以看到在取指微程序的最后一个节拍，将$P_{IR}$设置成了1。其它具体的微程序，是完全一样的，这里不过多的说。</p>
<p>​	总而言之，微程序控制器的设计主要有如下流程</p>
<ol>
<li>分析指令执行的数据通路，列出每一步需要的操作信号</li>
<li>将每个微操作分配到具体的机器周期的各个时间节拍信号上，然后构建状态图</li>
<li>设计微指令格式，编写微程序，根据状态机顺序存放到控存中</li>
<li>实现地址转移逻辑、微地址寄存器等</li>
</ol>
<p>​	接下来讨论一下微指令及其编码方式。</p>
<p>​	首先对于微命令，也就是微指令中的操作控制字段，主要有如下三种编码方式</p>
<ol>
<li><p>直接表示法，即将每个二进制位都定义成一个微命令，就和前面的一样，但是微指令可能会很长</p>
</li>
<li><p>编码表示法，又称字段译码法，将互斥性微指令分为若干组，一个组对应一个字段，然后通过译码器生成微命令信号，执行速度相对比较慢，注意，<strong>译码器中需要预留一个状态用来表示当前微指令不使用本组互斥性微命令中的任意一个</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220622091218589.png" alt="image-20220622091218589"></p>
</li>
<li><p>混合表示法，就是将上述两种方法混合使用</p>
</li>
</ol>
<p>​	注意微命令的含义，指的就是一个二进制位，课本P240。</p>
<p>​	然后看一下微指令的格式，主要有水平型和垂直型两种</p>
<ol>
<li><p>水平型，指在一个微指令周期中能同时给出多个微命令的微指令。由此可见，上面介绍的几种表示方法都是水平型</p>
</li>
<li><p>垂直型，将全部的微命令代码化，但编制的微程序较长</p>
<p><img src="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220622092903542.png" alt="image-20220622092903542"></p>
<p>​	这里的13位字长采用的是扩展操作码，每个微指令只能执行一到两个微操作</p>
<h2 id="异常与中断处理"><a href="#异常与中断处理" class="headerlink" title="异常与中断处理"></a>异常与中断处理</h2><p>首先先来说明一些基本概念</p>
<ol>
<li><code>异常</code>，指CPU内部引起的异常事件，也称内部中断或软件中断，可进一步分为故障，自陷，终止<ul>
<li><code>故障</code>通常指由指令引发的异常，如除数为零，对于可修复的故障，加的断点就是当前指令而不是下一条指令</li>
<li><code>自陷</code>是一种实现安排好的异常事件，比如单步调试，不存在程序断点</li>
<li><code>终止</code>是指随机出现的使得CPU无法继续执行的硬件故障</li>
</ul>
</li>
<li><code>外部中断</code>，指外部设备向CPU发出的中断请求，要求CPU暂停当前正在执行的程序，转去执行为某个外部设备事件服务的中断服务程序</li>
</ol>
</li>
</ol>
<p>​		异常与终端的处理方法基本一致，即发生中断事件的时候，在当前指令执行结束时CPU会进入中断相应周期，当然有的时候指令并没有执行完毕，但必须立即进行中断响应。中断相应周期主要有如下几个任务</p>
<ol>
<li><code>关中断</code>，临时禁止中断请求。当然在多级嵌套中断中也可以在完成现场保护后通过指令开中断</li>
<li><code>保存断点</code>，保存将来返回被中断程序的位置，对于已经执行完毕的指令，该位置为下一条指令的位置，对于缺页故障、段错等执行指令引起的故障异常，由于指令被没有执行，则断点应该是异常指令的PC值。为了支持多级嵌套中断，通常使用内存堆栈进行保护断点</li>
<li><code>中断识别</code>，即根据当前中断请求识别中断来源，然后将对应中断的中断服务程序入口地址送到PC中</li>
</ol>
<p>​	下面讨论一下支持中断的CPU的设计</p>
<p>​	首先要对数据通路进行升级，使其能够支持中断。在MIPS中，和中断相关的寄存器有异常指令地址EPC和中断使能位IE，前者保存断点地址，后者为1时开中断，同时也需要添加相关的控制信号。然后需要添加中断控制逻辑，用来处理中断优先级和中断识别。</p>
<p><img src="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220622095438874.png" alt="image-20220622095438874"></p>
<p>​	接下来需要升级操作控制器。</p>
<ol>
<li><p>对于三级时序硬布线控制器，需要在指令执行周期结束后增加一个中断响应周期$M_{int}$，需要两个时钟周期，第一个用来关中断和保存断点，第二个用来完成中断识别，进而只需要对状态转换图进行一定的修改即可</p>
<p><img src="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220622100238184.png" alt="image-20220622100238184"></p>
<p>可以看出我们新增了一个指令eret，该指令的作用就是把EPC中保存的断点送到PC，然后开中断，中断返回时还需要给出ClrInt信号来清楚当前的中断请求信号。然后我们再根据执行周期，去设计时序产生器就行了。</p>
</li>
<li><p>对于现代时序硬布线控制器，用类似的思路可以更新状态图，如下所示</p>
<p><img src="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220622100617543.png" alt="image-20220622100617543"></p>
<p>然后根据之前学的知识去进行设计即可</p>
</li>
<li><p>对于微程序控制器，只需要增加三条微指令即可，另外在指令执行结束后需要加中断判断，我们用$P_{end}$来标记当前微指令为最后一条微指令，如果其为1且控制器收到中断请求并且没有别的分支需要执行，就可以将中断响应微程序入口地址送到微地址寄存器中</p>
</li>
</ol>
<h1 id="CPU实验"><a href="#CPU实验" class="headerlink" title="CPU实验"></a>CPU实验</h1><h2 id="变长指令周期3级时序系统"><a href="#变长指令周期3级时序系统" class="headerlink" title="变长指令周期3级时序系统"></a>变长指令周期3级时序系统</h2><p>​	主要是实现传统3级时序系统硬布线控制器。</p>
<h3 id="MIPS指令译码器"><a href="#MIPS指令译码器" class="headerlink" title="MIPS指令译码器"></a>MIPS指令译码器</h3><p>​	根据上面的知识，首先我们需要一个指令译码器，这一部分具体可以参考MIPS指令手册，看一下对应的机器码都是怎么样的，然后使用比较器即可，具体电路如下图所示</p>
<p><img src="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220622101720839.png" alt="image-20220622101720839"></p>
<h3 id="时序发生器设计"><a href="#时序发生器设计" class="headerlink" title="时序发生器设计"></a>时序发生器设计</h3><p>​	这里要设计变长指令周期的时序发生器，根据前面的知识。时序发生器的输入应该是状态和指令信号，输出应该是机器周期和对应的节拍。我们要先设计时序产生器的状态机，真值表如下图所示</p>
<p><img src="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220622102524451.png" alt="image-20220622102524451"></p>
<p>​	具体的状态设计和上文的图是类似的。注意这里有SLT信号，可以参考MIPS指令手册去得到其作用</p>
<p>​	然后要设计时序发生器的输出函数，就是根据当前的状态决定输出是哪个节拍，真值表如下图所示</p>
<p><img src="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220622102835939.png" alt="image-20220622102835939"></p>
<p>​	有了逻辑表达式之后，可以使用Logisim的自动生成电路的功能，最终可以顺利通过这一部分</p>
<h3 id="硬布线组合逻辑控制单元"><a href="#硬布线组合逻辑控制单元" class="headerlink" title="硬布线组合逻辑控制单元"></a>硬布线组合逻辑控制单元</h3><p>​	有了时序发生器，我们需要设计硬布线组合逻辑控制单元，根据当前的机器周期、节拍、译码信号等等生成微操作控制序列，也是需要填真值表的，只需要分析清楚各个节拍对应的操作以及相应所需要的控制信号即可。</p>
<p>​	因为其它的我们都已经分析过了，这里以新增加的Slt信号为例来分析一下。</p>
<p>​	Slt信号的主要功能如下所示</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SLT rd,rs,rt</span><br><span class="line">if R[rs] &lt; R[rt] then</span><br><span class="line">	R[rd]=1</span><br><span class="line">else</span><br><span class="line">	R[rd]=0</span><br><span class="line">endif</span><br></pre></td></tr></table></figure>

<p>​	也就是说，第一步我们需要将寄存器值送到X中，需要的信号为$R_{out},X_{in}$，第二步需要将另一个寄存器送到B端，并且进行SLT运算，也就是说需要信号$R_{out},Rs&#x2F;Rt,Slt$，第三步需要将Z中的值送到寄存器rd中，则需要信号$Z_{out},RegDst,R_{in}$</p>
<p>​	最终的真值表如下图所示</p>
<p><img src="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220622103904010.png" alt="image-20220622103904010"></p>
<p>​	最终成功设计出了硬布线的组合逻辑</p>
<h3 id="硬布线控制器-1"><a href="#硬布线控制器-1" class="headerlink" title="硬布线控制器"></a>硬布线控制器</h3><p>​	接下来我们需要把这几部分合在一起，主要是根据上文中硬布线控制器的模型来连线，首先需要先将时序发生器的状态机和输出函数连接在一起，只需要根据模型去连线即可，电路如下图所示</p>
<p><img src="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220622104220609.png" alt="image-20220622104220609"></p>
<p>​	另外这里的时钟应该选择下跳沿，然后需要把这些信号给硬布线组合逻辑控制单元，电路如下图所示</p>
<p><img src="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220622104338529.png" alt="image-20220622104338529"></p>
<p>​	需要注意的是，这里提供的电路原文件不知道为什么，对于硬布线控制器组合逻辑单元，封装的接口是错误的，也就是和这里的连线是不一致的，可能这就是愚人节特供版的含义？</p>
<h3 id="变长指令周期单总线CPU"><a href="#变长指令周期单总线CPU" class="headerlink" title="变长指令周期单总线CPU"></a>变长指令周期单总线CPU</h3><p>​	在完成了上面的所有设计之后，就完成了本次实验任务</p>
<h2 id="单总线现代时序CPU"><a href="#单总线现代时序CPU" class="headerlink" title="单总线现代时序CPU"></a>单总线现代时序CPU</h2><p>​	这里主要就是设计一个现代时序的CPU，实现了硬布线和微程序两种控制器</p>
<h3 id="MIPS指令译码器-1"><a href="#MIPS指令译码器-1" class="headerlink" title="MIPS指令译码器"></a>MIPS指令译码器</h3><p>​	这里和上面的译码器完全相同。</p>
<h3 id="微程序入口查找逻辑"><a href="#微程序入口查找逻辑" class="headerlink" title="微程序入口查找逻辑"></a>微程序入口查找逻辑</h3><p>​	这里其实就是根据输入的译码信号来确定选择哪一个微程序的入口，和我们总体设计的状态图有关，真值表如下所示</p>
<p><img src="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220622111005329.png" alt="image-20220622111005329"></p>
<p>​	同样的根据逻辑表达式去生成电路即可。</p>
<h3 id="微程序条件判别测试逻辑"><a href="#微程序条件判别测试逻辑" class="headerlink" title="微程序条件判别测试逻辑"></a>微程序条件判别测试逻辑</h3><p>​	这里采用的应该是下址字段法选择下一条微指令地址。我们这里的输入只有$P_0,P_1,equal$三个信号，可以看到如果$P_0$为1，则说明要跳转到译码信号确定的微程序入口，而如果$P_1&amp;equal$为1的话，则说明要跳转到相同时的地址，剩下的情况全都是按照下址地址进行选择。进而可知真值表如下所示</p>
<p><img src="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220622111820692.png" alt="image-20220622111820692"></p>
<p>​	输入信号从左到右依次为$P_0,P_1,equal$，输出信号从左到右依次为$S_2,S_1,S_0$</p>
<h3 id="单总线CPU微程序控制器设计"><a href="#单总线CPU微程序控制器设计" class="headerlink" title="单总线CPU微程序控制器设计"></a>单总线CPU微程序控制器设计</h3><p>​	这里主要是要将微程序加载到控存中，将已有的这些部件进行连线。</p>
<p>​	首先我们先来设计微程序，同样也是只需要填表即可，没有什么难的</p>
<p><img src="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220622112353018.png" alt="image-20220622112353018"></p>
<p>​	不过应当注意这里微程序入口地址的位置，应当和之前的入口查找逻辑完全对应，然后将其载入到控存里就行</p>
<p>​	然后我们来设计微程序控制器，其实只需要把上面设计好的那些部件按照模型图连接起来就行，也就是用多路选择器，下址字段连接到0号位，译码得到的字段连接到1号位，beq指令的跳转位置连接到2号位，根据逻辑这个地址应该就是0x10，所以最终的电路如下图所示</p>
<p><img src="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220622113400732.png" alt="image-20220622113400732"></p>
<h3 id="采用微程序的单总线CPU设计"><a href="#采用微程序的单总线CPU设计" class="headerlink" title="采用微程序的单总线CPU设计"></a>采用微程序的单总线CPU设计</h3><p>​	完成上面的部件之后就可以成功运行了</p>
<h3 id="现代时序硬布线状态机设计"><a href="#现代时序硬布线状态机设计" class="headerlink" title="现代时序硬布线状态机设计"></a>现代时序硬布线状态机设计</h3><p>​	这一部分就是要设计一个状态机，输入就是当前状态以及指令信号，输出就是下一个状态。只需要根据上面提供的现代时序状态图进行填表就行，也没有什么坑，此略</p>
<h3 id="现代时序硬布线控制器设计"><a href="#现代时序硬布线控制器设计" class="headerlink" title="现代时序硬布线控制器设计"></a>现代时序硬布线控制器设计</h3><p>​	这一部分就是设计根据状态去输出相应的控制信号。这里没有重复的去进行填表，而是使用了前面设计的控存，只需要保证状态对应，就可以取出对应微指令的微命令部分作为控制信号，而这是显然对应的，毕竟状态图都是一样的。所以最终的电路图如下所示</p>
<p><img src="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220622114719302.png" alt="image-20220622114719302"></p>
<h2 id="MIPS带中断机制实现"><a href="#MIPS带中断机制实现" class="headerlink" title="MIPS带中断机制实现"></a>MIPS带中断机制实现</h2><p>​	本实验就是在原有的硬布线和微程序控制器的基础上添加中断机制</p>
<h3 id="MIPS指令译码器-2"><a href="#MIPS指令译码器-2" class="headerlink" title="MIPS指令译码器"></a>MIPS指令译码器</h3><p>​	和前面的完全一样</p>
<h3 id="支持中断的微程序入口查找逻辑"><a href="#支持中断的微程序入口查找逻辑" class="headerlink" title="支持中断的微程序入口查找逻辑"></a>支持中断的微程序入口查找逻辑</h3><p>​	相比于之前，只需要增加一个指令ERET即可，最终的真值表如下图所示，只需要把ERET加到原本控存的后面即可</p>
<p><img src="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220622133535076.png" alt="image-20220622133535076"></p>
<h3 id="支持中断的微程序条件判别测试逻辑"><a href="#支持中断的微程序条件判别测试逻辑" class="headerlink" title="支持中断的微程序条件判别测试逻辑"></a>支持中断的微程序条件判别测试逻辑</h3><p>​	相比于之前，这里加了判别位$P_2$，为1则说明这是当前微程序的最后一条微指令。结合测试用例以及后面的实验要求，可以知道我们需要实现计数器法微程序控制器，根据其模型以及后面多路选择器提供的值，可以知道000是按顺序执行，001是根据译码信号进入相应的微程序入口，010是beq分支，011是中断响应入口，100是取指微程序入口，然后我们就根据这样的关系去填表就行。首先当$P_0&#x3D;1$时只会根据译码信号进入相应的微程序，那么这个时候对应的就是001，然后当$P_0&#x3D;P_1&#x3D;P_2&#x3D;0$的时候，这个时候显然没有跳转，就是按照顺序去执行，故对应000，然后对于中断响应，首先需要当前指令执行完，也即$P_2&#x3D;1$，然后$IntR&#x3D;1$允许中断，接着还要求没有别的跳转发生，即$P_0&#x3D;0,P_1&amp;equal!&#x3D;1$，对于beq跳转，显然只需要$P_0&#x3D;0,P_1&amp;equal&#x3D;1$即可，对于跳转到取指令入口，显然有两种情况，即beq条件不对，或者$P_2&#x3D;1$，并且没有别的跳转发生。故最终真值表如下所示</p>
<p><img src="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220622135205427.png" alt="image-20220622135205427"></p>
<h3 id="支持中断的微程序控制器设计"><a href="#支持中断的微程序控制器设计" class="headerlink" title="支持中断的微程序控制器设计"></a>支持中断的微程序控制器设计</h3><p>​	这里和前面不同的点就在于用了计数器法，但是其实区别也不大，因为我们已经在判别测试逻辑处写好了条件转移。</p>
<p>​	和前面不支持中断的微程序表没有太大差别，只是增加了一个eret指令，并且增加了几个中断控制信号，取消了下址字段，另外我们需要对前面已经设计好的指令作修改，也就是把当前微程序的最后一条指令的$P_3$位设置成1，需要注意的是beq指令由于本身的分支跳转，需要有两个$P_3$都被设置成1，然后在之前的真值表后面实现eret指令，接下来继续填写两个公操作，也就是中断相应周期，最终的真值表如下图所示</p>
<p><img src="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220622135944841.png" alt="image-20220622135944841"></p>
<p>​	然后我们去连接一下微程序控制器就行，具体电路如下图所示</p>
<p><img src="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220622141515487.png" alt="image-20220622141515487"></p>
<h3 id="支持中断的微程序单总线CPU设计"><a href="#支持中断的微程序单总线CPU设计" class="headerlink" title="支持中断的微程序单总线CPU设计"></a>支持中断的微程序单总线CPU设计</h3><p>​	这里我们需要完成对于中断的支持，主要添加寄存器EPC，中断使能寄存器IE，中断控制逻辑。</p>
<p>​	首先看EPC，EPC其实就用一个简单的寄存器就行，输入是内总线，输出接一个三态门，EPC写使能信号接EPC寄存器使能端，故电路如下所示</p>
<p><img src="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220622140643324.png" alt="image-20220622140643324"></p>
<p>​	中断使能寄存器IE使用了D触发器，主要连接了STI和CLI两个信号，对于中断控制的话，只需要将输出对应的中断号连接一个多路选择器即可，这部分的逻辑如下图所示</p>
<p><img src="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220622141052241.png" alt="image-20220622141052241"></p>
<h3 id="支持中断的现代时序硬布线控制器状态机设计"><a href="#支持中断的现代时序硬布线控制器状态机设计" class="headerlink" title="支持中断的现代时序硬布线控制器状态机设计"></a>支持中断的现代时序硬布线控制器状态机设计</h3><p>​	这一部分主要就是实现硬布线状态机，其实就是在之前没有中断的基础上加上中断就行，要注意的是，在每次要跳转到取指阶段的时候都要检查一下有没有中断请求，其他的都是一样的。另外新加入的状态转移不仅仅有之前的无中断跳转到取指阶段，也有在每个指令执行结束后有中断跳转到中断响应阶段，当然对于beq，应当满足条件为equal为0</p>
<h3 id="支持中断的现代时序硬布线控制器设计"><a href="#支持中断的现代时序硬布线控制器设计" class="headerlink" title="支持中断的现代时序硬布线控制器设计"></a>支持中断的现代时序硬布线控制器设计</h3><p>​	这里和前面是完全一样的连法，电路如下图所示</p>
<p><img src="https://cdn.jsdelivr.net/gh/ysjyx7/img@main/image-20220622142148627.png" alt="image-20220622142148627"></p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="reward-container">
  <div>Buy me a coffee</div>
  <button>
    赞赏
  </button>
  <div class="post-reward">
      <div>
        <img src="/images/wechatpay.png" alt="ysjhust 微信">
        <span>微信</span>
      </div>
      <div>
        <img src="/images/alipay.png" alt="ysjhust 支付宝">
        <span>支付宝</span>
      </div>

  </div>
</div>

          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>本文作者： </strong>ysjhust
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="https://ysjyx7.github.io/2022/06/19/%E7%BB%84%E5%8E%9F%E6%80%BB%E7%BB%93/" title="组原总结">https://ysjyx7.github.io/2022/06/19/组原总结/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

          <div class="followme">
  <span>欢迎关注我的其它发布渠道</span>

  <div class="social-list">

      <div class="social-item">
        <a target="_blank" class="social-link" href="https://www.zhihu.com/people/yang-lao-er-25-83">
          <span class="icon">
            <i class="fab fa-zhihu"></i>
          </span>

          <span class="label">知乎</span>
        </a>
      </div>

      <div class="social-item">
        <a target="_blank" class="social-link" href="https://blog.csdn.net/m0_55101026?spm=1001.2101.3001.5343">
          <span class="icon">
            <i class="fa fa-book"></i>
          </span>

          <span class="label">CSDN</span>
        </a>
      </div>

      <div class="social-item">
        <a target="_blank" class="social-link" href="https://github.com/ysjyx7">
          <span class="icon">
            <i class="fab fa-github"></i>
          </span>

          <span class="label">GitHub</span>
        </a>
      </div>
  </div>
</div>

          <div class="post-tags">
              <a href="/tags/%E4%B8%93%E4%B8%9A%E8%AF%BE%E5%AD%A6%E4%B9%A0/" rel="tag"># 专业课学习</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2022/05/03/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/" rel="prev" title="贪心算法">
                  <i class="fa fa-chevron-left"></i> 贪心算法
                </a>
            </div>
            <div class="post-nav-item">
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2021 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ysjhust</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
      <span>站点总字数：</span>
    <span title="站点总字数">305k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span>站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">4:37</span>
  </span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
<!--
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>
-->

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script>

  
<script src="/js/third-party/search/local-search.js"></script>




  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js","integrity":"sha256-r+3itOMtGGjap0x+10hu6jW/gZCzxHsoKrOd7gyRSGY="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>



</body>
</html>
